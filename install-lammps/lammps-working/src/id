angle.cpp:  if (!allocated && atom->nangletypes)
angle.cpp:  for (int i = 1; i <= atom->nangletypes; i++)
angle.cpp:  if (eflag_atom && atom->nmax > maxeatom) {
angle.cpp:    maxeatom = atom->nmax;
angle.cpp:  if (vflag_atom && atom->nmax > maxvatom) {
angle.cpp:    maxvatom = atom->nmax;
angle.cpp:  if (cvflag_atom && atom->nmax > maxcvatom) {
angle.cpp:    maxcvatom = atom->nmax;
angle.cpp:    n = atom->nlocal;
angle.cpp:    if (force->newton_bond) n += atom->nghost;
angle.cpp:    n = atom->nlocal;
angle.cpp:    if (force->newton_bond) n += atom->nghost;
angle.cpp:    n = atom->nlocal;
angle.cpp:    if (force->newton_bond) n += atom->nghost;
angle_hybrid.cpp:    const bigint nall = atom->nlocal + atom->nghost;
angle_hybrid.cpp:      n = atom->nlocal;
angle_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
angle_hybrid.cpp:      n = atom->nlocal;
angle_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
angle_hybrid.cpp:      n = atom->nlocal;
angle_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
angle_hybrid.cpp:  int n = atom->nangletypes;
angle_hybrid.cpp:  utils::bounds(FLERR, arg[0], 1, atom->nangletypes, ilo, ihi, error);
angle_zero.cpp:  int n = atom->nangletypes;
angle_zero.cpp:  utils::bounds(FLERR,arg[0],1,atom->nangletypes,ilo,ihi,error);
angle_zero.cpp:  fwrite(&theta0[1],sizeof(double),atom->nangletypes,fp);
angle_zero.cpp:    utils::sfread(FLERR,&theta0[1],sizeof(double),atom->nangletypes,fp,nullptr,error);
angle_zero.cpp:  MPI_Bcast(&theta0[1],atom->nangletypes,MPI_DOUBLE,0,world);
angle_zero.cpp:  for (int i = 1; i <= atom->nangletypes; i++) setflag[i] = 1;
angle_zero.cpp:  for (int i = 1; i <= atom->nangletypes; i++)
atom.cpp:  // use grow() to initialize atom-based arrays to length 1
atom.cpp:  memory->destroy(atom->bond_type);
atom.cpp:  memory->destroy(atom->bond_atom);
atom.cpp:  atom->bond_type = nullptr;
atom.cpp:  atom->bond_atom = nullptr;
atom.cpp:  memory->destroy(atom->angle_type);
atom.cpp:  memory->destroy(atom->angle_atom1);
atom.cpp:  memory->destroy(atom->angle_atom2);
atom.cpp:  memory->destroy(atom->angle_atom3);
atom.cpp:  atom->angle_type = nullptr;
atom.cpp:  atom->angle_atom1 = atom->angle_atom2 = atom->angle_atom3 = nullptr;
atom.cpp:  memory->destroy(atom->dihedral_type);
atom.cpp:  memory->destroy(atom->dihedral_atom1);
atom.cpp:  memory->destroy(atom->dihedral_atom2);
atom.cpp:  memory->destroy(atom->dihedral_atom3);
atom.cpp:  memory->destroy(atom->dihedral_atom4);
atom.cpp:  atom->dihedral_type = nullptr;
atom.cpp:  atom->dihedral_atom1 = atom->dihedral_atom2 =
atom.cpp:    atom->dihedral_atom3 = atom->dihedral_atom4 = nullptr;
atom.cpp:  memory->destroy(atom->improper_type);
atom.cpp:  memory->destroy(atom->improper_atom1);
atom.cpp:  memory->destroy(atom->improper_atom2);
atom.cpp:  memory->destroy(atom->improper_atom3);
atom.cpp:  memory->destroy(atom->improper_atom4);
atom.cpp:  atom->improper_type = nullptr;
atom.cpp:  atom->improper_atom1 = atom->improper_atom2 =
atom.cpp:    atom->improper_atom3 = atom->improper_atom4 = nullptr;
atom.cpp:   unpack N lines from atom-style specific bonus section of data file
atom.cpp:   check that all per-atom-type masses have been set
atom.cpp:   don't have to worry about clearing/setting atom->map since done in comm
atom.cpp:    maxnext = atom->nmax;
atom.cpp:      binsize = fix->binsize(subx, suby, subz, atom->nlocal,
atom.cpp:   register a callback to a fix so it can manage atom-based arrays
atom_vec_body.cpp:  atom->body_flag = 1;
atom_vec_body.cpp:  atom->rmass_flag = 1;
atom_vec_body.cpp:  atom->angmom_flag = atom->torque_flag = 1;
atom_vec_body.cpp:  atom->radius_flag = 1;
atom_vec_body.cpp:  body = atom->body;
atom_vec_body.cpp:  rmass = atom->rmass;
atom_vec_body.cpp:  radius = atom->radius;
atom_vec_body.cpp:  angmom = atom->angmom;
atom_vec_body.cpp:  if (atom->nextra_grow)
atom_vec_body.cpp:    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec_body.cpp:      modify->fix[atom->extra_grow[iextra]]->clear_bonus();
atom_vec_body.cpp:  int nlocal = atom->nlocal;
atom_vec_body.cpp:  tagint *tag = atom->tag;
atom_vec_body.cpp:  int nlocal = atom->nlocal;
atom_vec_body.cpp:  for (int i = 0; i < atom->nlocal; i++) {
atom_vec_body.cpp:  for (int i = atom->nlocal; i < atom->nlocal+atom->nghost; i++) {
atom_vec_body.cpp:    if (bonus[i].ilocal < 0 || bonus[i].ilocal >= atom->nlocal) {
atom_vec_body.cpp:    if (bonus[i].ilocal < atom->nlocal ||
atom_vec_body.cpp:        bonus[i].ilocal >= atom->nlocal+atom->nghost) {
atom_vec_charge.cpp:  atom->q_flag = 1;
atom_vec.cpp:  atom->nmax = nmax;
atom_vec.cpp:  tag = memory->grow(atom->tag,nmax,"atom:tag");
atom_vec.cpp:  type = memory->grow(atom->type,nmax,"atom:type");
atom_vec.cpp:  mask = memory->grow(atom->mask,nmax,"atom:mask");
atom_vec.cpp:  image = memory->grow(atom->image,nmax,"atom:image");
atom_vec.cpp:  x = memory->grow(atom->x,nmax,3,"atom:x");
atom_vec.cpp:  v = memory->grow(atom->v,nmax,3,"atom:v");
atom_vec.cpp:  f = memory->grow(atom->f,nmax*comm->nthreads,3,"atom:f");
atom_vec.cpp:  for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec.cpp:    modify->fix[atom->extra_grow[iextra]]->grow_arrays(nmax);
atom_vec.cpp:  if (atom->nextra_grow)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec.cpp:      modify->fix[atom->extra_grow[iextra]]->copy_arrays(i,j,delflag);
atom_vec.cpp:  if (atom->nextra_border)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
atom_vec.cpp:      m += modify->fix[atom->extra_border[iextra]]->pack_border(n,list,&buf[m]);
atom_vec.cpp:  if (atom->nextra_border)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
atom_vec.cpp:      m += modify->fix[atom->extra_border[iextra]]->pack_border(n,list,&buf[m]);
atom_vec.cpp:  if (atom->nextra_border)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
atom_vec.cpp:      m += modify->fix[atom->extra_border[iextra]]->
atom_vec.cpp:  if (atom->nextra_border)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_border; iextra++)
atom_vec.cpp:      m += modify->fix[atom->extra_border[iextra]]->
atom_vec.cpp:  if (atom->nextra_grow)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec.cpp:      m += modify->fix[atom->extra_grow[iextra]]->pack_exchange(i,&buf[m]);
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  if (atom->nextra_grow)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec.cpp:      m += modify->fix[atom->extra_grow[iextra]]->
atom_vec.cpp:  atom->nlocal++;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  if (atom->nextra_restart)
atom_vec.cpp:    for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
atom_vec.cpp:        n += modify->fix[atom->extra_restart[iextra]]->size_restart(i);
atom_vec.cpp:  for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
atom_vec.cpp:    m += modify->fix[atom->extra_restart[iextra]]->pack_restart(i,&buf[m]);
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:    if (atom->nextra_store)
atom_vec.cpp:      memory->grow(atom->extra,nmax,atom->nextra_store,"atom:extra");
atom_vec.cpp:  double **extra = atom->extra;
atom_vec.cpp:  if (atom->nextra_store) {
atom_vec.cpp:  atom->nlocal++;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  atom->nlocal++;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:        if (array == atom->x) {      // x was already set by coord arg
atom_vec.cpp:  if (type[nlocal] <= 0 || type[nlocal] > atom->ntypes)
atom_vec.cpp:  atom->nlocal++;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  double **v = atom->v;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  tagint *tag = atom->tag;
atom_vec.cpp:  int *num_bond = atom->num_bond;
atom_vec.cpp:  int **bond_type = atom->bond_type;
atom_vec.cpp:  tagint **bond_atom = atom->bond_atom;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  tagint *tag = atom->tag;
atom_vec.cpp:  int *num_angle = atom->num_angle;
atom_vec.cpp:  int **angle_type = atom->angle_type;
atom_vec.cpp:  tagint **angle_atom1 = atom->angle_atom1;
atom_vec.cpp:  tagint **angle_atom2 = atom->angle_atom2;
atom_vec.cpp:  tagint **angle_atom3 = atom->angle_atom3;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  tagint *tag = atom->tag;
atom_vec.cpp:  int *num_dihedral = atom->num_dihedral;
atom_vec.cpp:  int **dihedral_type = atom->dihedral_type;
atom_vec.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
atom_vec.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
atom_vec.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
atom_vec.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  tagint *tag = atom->tag;
atom_vec.cpp:  int *num_improper = atom->num_improper;
atom_vec.cpp:  int **improper_type = atom->improper_type;
atom_vec.cpp:  tagint **improper_atom1 = atom->improper_atom1;
atom_vec.cpp:  tagint **improper_atom2 = atom->improper_atom2;
atom_vec.cpp:  tagint **improper_atom3 = atom->improper_atom3;
atom_vec.cpp:  tagint **improper_atom4 = atom->improper_atom4;
atom_vec.cpp:  int nlocal = atom->nlocal;
atom_vec.cpp:  // return # of fields and matching index into atom->peratom (in Method struct)
atom_vec.cpp:    Atom::PerAtom *field = &atom->peratom[mgrow.index[i]];
atom_vec.cpp:    if (strcmp(atom->peratom[mdata_atom.index[n]].name,"x") == 0)
atom_vec.cpp:  Atom::PerAtom *peratom = atom->peratom;
atom_vec.cpp:  int nperatom = atom->nperatom;
atom_vec.cpp:    Atom::PerAtom *field = &atom->peratom[method->index[i]];
atom_vec_ellipsoid.cpp:  atom->ellipsoid_flag = 1;
atom_vec_ellipsoid.cpp:  atom->rmass_flag = atom->angmom_flag = atom->torque_flag = 1;
atom_vec_ellipsoid.cpp:  ellipsoid = atom->ellipsoid;
atom_vec_ellipsoid.cpp:  rmass = atom->rmass;
atom_vec_ellipsoid.cpp:  angmom = atom->angmom;
atom_vec_ellipsoid.cpp:  if (atom->nextra_grow)
atom_vec_ellipsoid.cpp:    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec_ellipsoid.cpp:      modify->fix[atom->extra_grow[iextra]]->clear_bonus();
atom_vec_ellipsoid.cpp:  int nlocal = atom->nlocal;
atom_vec_ellipsoid.cpp:  ellipsoid_flag = atom->ellipsoid[ilocal];
atom_vec_ellipsoid.cpp:  rmass_one = atom->rmass[ilocal];
atom_vec_ellipsoid.cpp:  tagint *tag = atom->tag;
atom_vec_ellipsoid.cpp:  int nlocal = atom->nlocal;
atom_vec_hybrid.cpp:    styles[nstyles] = atom->new_avec(arg[iarg],1,dummy);
atom_vec_line.cpp:  atom->line_flag = 1;
atom_vec_line.cpp:  atom->molecule_flag = atom->rmass_flag = 1;
atom_vec_line.cpp:  atom->radius_flag = atom->omega_flag = atom->torque_flag = 1;
atom_vec_line.cpp:  atom->sphere_flag = 1;
atom_vec_line.cpp:  line = atom->line;
atom_vec_line.cpp:  radius = atom->radius;
atom_vec_line.cpp:  rmass = atom->rmass;
atom_vec_line.cpp:  omega = atom->omega;
atom_vec_line.cpp:  if (atom->nextra_grow)
atom_vec_line.cpp:    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec_line.cpp:      modify->fix[atom->extra_grow[iextra]]->clear_bonus();
atom_vec_line.cpp:  int nlocal = atom->nlocal;
atom_vec_line.cpp:  double **x = atom->x;
atom_vec_line.cpp:  tagint *tag = atom->tag;
atom_vec_line.cpp:  int nlocal = atom->nlocal;
atom_vec_spfr.cpp:  atom->mu_flag = 1;
atom_vec_spfr.cpp:  atom->molecule_flag = 1;
atom_vec_spfr.cpp:  num_bond = atom->num_bond;
atom_vec_spfr.cpp:  bond_type = atom->bond_type;
atom_vec_spfr.cpp:  num_angle = atom->num_angle;
atom_vec_spfr.cpp:  angle_type = atom->angle_type;
atom_vec_spfr.cpp:  nspecial = atom->nspecial;
atom_vec_spfr.cpp:  mu = atom->mu;
atom_vec_spfr.cpp:  nmu = atom->nmu;
atom_vec_spfr.cpp:  amu = atom->amu;
atom_vec_spfr.cpp:  af = atom->af;
atom_vec_spfr.cpp:  if (bond_per_atom < atom->bond_per_atom) {
atom_vec_spfr.cpp:    bond_per_atom = atom->bond_per_atom;
atom_vec_spfr.cpp:  if (angle_per_atom < atom->angle_per_atom) {
atom_vec_spfr.cpp:    angle_per_atom = atom->angle_per_atom;
atom_vec_sphere.cpp:  atom->sphere_flag = 1;
atom_vec_sphere.cpp:  atom->radius_flag = atom->rmass_flag = atom->omega_flag =
atom_vec_sphere.cpp:    atom->torque_flag = 1;
atom_vec_sphere.cpp:  radius = atom->radius;
atom_vec_sphere.cpp:  rmass = atom->rmass;
atom_vec_sphere.cpp:  omega = atom->omega;
atom_vec_sphere.cpp:  radius_one = 0.5 * atom->radius[ilocal];
atom_vec_tri.cpp:  atom->tri_flag = 1;
atom_vec_tri.cpp:  atom->molecule_flag = atom->rmass_flag = 1;
atom_vec_tri.cpp:  atom->radius_flag = atom->omega_flag = atom->angmom_flag = 1;
atom_vec_tri.cpp:  atom->torque_flag = 1;
atom_vec_tri.cpp:  atom->sphere_flag = 1;
atom_vec_tri.cpp:  tri = atom->tri;
atom_vec_tri.cpp:  radius = atom->radius;
atom_vec_tri.cpp:  rmass = atom->rmass;
atom_vec_tri.cpp:  omega = atom->omega;
atom_vec_tri.cpp:  angmom = atom->angmom;
atom_vec_tri.cpp:  if (atom->nextra_grow)
atom_vec_tri.cpp:    for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
atom_vec_tri.cpp:      modify->fix[atom->extra_grow[iextra]]->clear_bonus();
atom_vec_tri.cpp:  int nlocal = atom->nlocal;
atom_vec_tri.cpp:  double **x = atom->x;
atom_vec_tri.cpp:  tagint *tag = atom->tag;
atom_vec_tri.cpp:  int nlocal = atom->nlocal;
balance.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
balance.cpp:  if (atom->map_style != Atom::MAP_NONE) atom->map_set();
balance.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
balance.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
balance.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
balance.cpp:  bigint nblocal = atom->nlocal;
balance.cpp:  if (natoms != atom->natoms)
balance.cpp:               atom->natoms,natoms);
balance.cpp:  int nlocal = atom->nlocal;
balance.cpp:    int nlocal = atom->nlocal;
balance.cpp:  } else mycost = atom->nlocal;
balance.cpp:  double **x = atom->x;
balance.cpp:  int nlocal = atom->nlocal;
balance.cpp:      rcb->compute_old(dim,atom->nlocal,atom->x,weight,shrinklo,shrinkhi);
balance.cpp:    } else rcb->compute_old(dim,atom->nlocal,atom->x,nullptr,shrinklo,shrinkhi);
balance.cpp:      rcb->compute(dim,atom->nlocal,atom->x,weight,shrinklo,shrinkhi);
balance.cpp:    } else rcb->compute(dim,atom->nlocal,atom->x,nullptr,shrinklo,shrinkhi);
balance.cpp:  bigint natoms = atom->natoms;
balance.cpp:  domain->x2lamda(atom->nlocal);
balance.cpp:      int nlocal = atom->nlocal;
balance.cpp:    } else mycost = atom->nlocal;
balance.cpp:  domain->lamda2x(atom->nlocal);
balance.cpp:  double **x = atom->x;
balance.cpp:  int nlocal = atom->nlocal;
balance.cpp:  double **x = atom->x;
balance.cpp:  int nlocal = atom->nlocal;
bond.cpp:  if (!allocated && atom->nbondtypes)
bond.cpp:  for (int i = 1; i <= atom->nbondtypes; i++)
bond.cpp:  if (eflag_atom && atom->nmax > maxeatom) {
bond.cpp:    maxeatom = atom->nmax;
bond.cpp:  if (vflag_atom && atom->nmax > maxvatom) {
bond.cpp:    maxvatom = atom->nmax;
bond.cpp:    n = atom->nlocal;
bond.cpp:    if (force->newton_bond) n += atom->nghost;
bond.cpp:    n = atom->nlocal;
bond.cpp:    if (force->newton_bond) n += atom->nghost;
bond.cpp:    if (itype < 1 || itype > atom->ntypes || jtype < 1 || jtype > atom->ntypes)
bond_hybrid.cpp:    const bigint nall = atom->nlocal + atom->nghost;
bond_hybrid.cpp:      n = atom->nlocal;
bond_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
bond_hybrid.cpp:      n = atom->nlocal;
bond_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
bond_hybrid.cpp:  int n = atom->nbondtypes;
bond_hybrid.cpp:  utils::bounds(FLERR, arg[0], 1, atom->nbondtypes, ilo, ihi, error);
bond_selfpropulsion.cpp:  double **x = atom->x;
bond_selfpropulsion.cpp:  double **f = atom->f;
bond_selfpropulsion.cpp:  int nlocal = atom->nlocal;
bond_selfpropulsion.cpp:    rsp1 = sp[type] / 2.0;//(double) atom->num_bond[i1];
bond_selfpropulsion.cpp:    rsp2 = sp[type] / 2.0;//(double) atom->num_bond[i2];
bond_selfpropulsion.cpp:  int n = atom->nbondtypes;
bond_selfpropulsion.cpp:  utils::bounds(FLERR,arg[0],1,atom->nbondtypes,ilo,ihi,error);
bond_selfpropulsion.cpp:  fwrite(&k[1],sizeof(double),atom->nbondtypes,fp);
bond_selfpropulsion.cpp:  fwrite(&r0[1],sizeof(double),atom->nbondtypes,fp);
bond_selfpropulsion.cpp:  fwrite(&sp[1],sizeof(double),atom->nbondtypes,fp);
bond_selfpropulsion.cpp:    utils::sfread(FLERR,&k[1],sizeof(double),atom->nbondtypes,fp,nullptr,error);
bond_selfpropulsion.cpp:    utils::sfread(FLERR,&r0[1],sizeof(double),atom->nbondtypes,fp,nullptr,error);
bond_selfpropulsion.cpp:    utils::sfread(FLERR,&sp[1],sizeof(double),atom->nbondtypes,fp,nullptr,error);
bond_selfpropulsion.cpp:  MPI_Bcast(&k[1],atom->nbondtypes,MPI_DOUBLE,0,world);
bond_selfpropulsion.cpp:  MPI_Bcast(&r0[1],atom->nbondtypes,MPI_DOUBLE,0,world);
bond_selfpropulsion.cpp:  MPI_Bcast(&sp[1],atom->nbondtypes,MPI_DOUBLE,0,world);
bond_selfpropulsion.cpp:  for (int i = 1; i <= atom->nbondtypes; i++) setflag[i] = 1;
bond_selfpropulsion.cpp:  for (int i = 1; i <= atom->nbondtypes; i++)
bond_zero.cpp:  int n = atom->nbondtypes;
bond_zero.cpp:  utils::bounds(FLERR,arg[0],1,atom->nbondtypes,ilo,ihi,error);
bond_zero.cpp:  fwrite(&r0[1],sizeof(double),atom->nbondtypes,fp);
bond_zero.cpp:    utils::sfread(FLERR,&r0[1],sizeof(double),atom->nbondtypes,fp,nullptr,error);
bond_zero.cpp:  MPI_Bcast(&r0[1],atom->nbondtypes,MPI_DOUBLE,0,world);
bond_zero.cpp:  for (int i = 1; i <= atom->nbondtypes; i++) setflag[i] = 1;
bond_zero.cpp:  for (int i = 1; i <= atom->nbondtypes; i++)
change_box.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
change_box.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
change_box.cpp:      double **x = atom->x;
change_box.cpp:      int *mask = atom->mask;
change_box.cpp:      int nlocal = atom->nlocal;
change_box.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
change_box.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal);
change_box.cpp:  double **x = atom->x;
change_box.cpp:  imageint *image = atom->image;
change_box.cpp:  int nlocal = atom->nlocal;
change_box.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
change_box.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
change_box.cpp:  bigint nblocal = atom->nlocal;
change_box.cpp:  if (natoms != atom->natoms && comm->me == 0)
change_box.cpp:                   "current {}", atom->natoms,natoms);
comm_brick.cpp:    memory->create(cutghostmultiold,atom->ntypes+1,3,"comm:cutghostmultiold");
comm_brick.cpp:  int ntypes = atom->ntypes;
comm_brick.cpp:  AtomVec *avec = atom->avec;
comm_brick.cpp:  double **x = atom->x;
comm_brick.cpp:  AtomVec *avec = atom->avec;
comm_brick.cpp:  double **f = atom->f;
comm_brick.cpp:  AtomVec *avec = atom->avec;
comm_brick.cpp:  if (map_style != Atom::MAP_NONE) atom->map_clear();
comm_brick.cpp:  atom->nghost = 0;
comm_brick.cpp:  atom->avec->clear_bonus();
comm_brick.cpp:    x = atom->x;
comm_brick.cpp:    nlocal = atom->nlocal;
comm_brick.cpp:    atom->nlocal = nlocal;
comm_brick.cpp:  if (atom->firstgroupname) atom->first_reorder();
comm_brick.cpp:  AtomVec *avec = atom->avec;
comm_brick.cpp:      x = atom->x;
comm_brick.cpp:        type = atom->type;
comm_brick.cpp:        nlast = atom->nlocal + atom->nghost;
comm_brick.cpp:            ngroup = atom->nfirst;
comm_brick.cpp:            for (i = atom->nlocal; i < nlast; i++)
comm_brick.cpp:            ngroup = atom->nfirst;
comm_brick.cpp:            for (i = atom->nlocal; i < nlast; i++) {
comm_brick.cpp:            ngroup = atom->nfirst;
comm_brick.cpp:            for (i = atom->nlocal; i < nlast; i++) {
comm_brick.cpp:        avec->unpack_border_vel(nrecv,atom->nlocal+atom->nghost,buf);
comm_brick.cpp:        avec->unpack_border(nrecv,atom->nlocal+atom->nghost,buf);
comm_brick.cpp:      firstrecv[iswap] = atom->nlocal + atom->nghost;
comm_brick.cpp:      nprior = atom->nlocal + atom->nghost;
comm_brick.cpp:      atom->nghost += nrecv;
comm_brick.cpp:  if ((atom->molecular != Atom::ATOMIC)
comm_brick.cpp:      && ((atom->nlocal + atom->nghost) > NEIGHMASK))
comm_brick.cpp:  if (map_style != Atom::MAP_NONE) atom->map_set();
comm_brick.cpp:  multioldlo = memory->create(multioldlo,n,atom->ntypes+1,"comm:multioldlo");
comm_brick.cpp:  multioldhi = memory->create(multioldhi,n,atom->ntypes+1,"comm:multioldhi");
comm_brick.cpp:      memory->create(localsendlist,atom->nlocal,"comm:localsendlist");
comm_brick.cpp:      memory->grow(localsendlist,atom->nlocal,"comm:localsendlist");
comm_brick.cpp:    for (i = 0; i < atom->nlocal; i++)
comm_brick.cpp:        if (sendlist[iswap][isend] < atom->nlocal)
comm.cpp:    memory->create(cutusermultiold,atom->ntypes+1,"comm:cutusermultiold");
comm.cpp:    memcpy(cutusermultiold,oldcomm->cutusermultiold,atom->ntypes+1);
comm.cpp:  map_style = atom->map_style;
comm.cpp:  comm_x_only = atom->avec->comm_x_only;
comm.cpp:  comm_f_only = atom->avec->comm_f_only;
comm.cpp:  size_forward = atom->avec->size_forward;
comm.cpp:  size_reverse = atom->avec->size_reverse;
comm.cpp:  size_border = atom->avec->size_border;
comm.cpp:  if (ghost_velocity) size_forward += atom->avec->size_velocity;
comm.cpp:  if (ghost_velocity) size_border += atom->avec->size_velocity;
comm.cpp:  maxexchange_atom = atom->avec->maxexchange;
comm.cpp:      if (bordergroup && (atom->firstgroupname == nullptr ||
comm.cpp:                          strcmp(arg[iarg+1],atom->firstgroupname) != 0))
comm.cpp:      const int ntypes = atom->ntypes;
comm.cpp:    int n = atom->nbondtypes;
comm_tiled.cpp:    memory->create(cutghostmultiold,atom->ntypes+1,3,"comm:cutghostmultiold");
comm_tiled.cpp:  int ntypes = atom->ntypes;
comm_tiled.cpp:          for (int itype = 1; itype <= atom->ntypes; itype++) {
comm_tiled.cpp:  AtomVec *avec = atom->avec;
comm_tiled.cpp:  double **x = atom->x;
comm_tiled.cpp:  AtomVec *avec = atom->avec;
comm_tiled.cpp:  double **f = atom->f;
comm_tiled.cpp:  AtomVec *avec = atom->avec;
comm_tiled.cpp:  if (map_style != Atom::MAP_NONE) atom->map_clear();
comm_tiled.cpp:  atom->nghost = 0;
comm_tiled.cpp:  atom->avec->clear_bonus();
comm_tiled.cpp:    x = atom->x;
comm_tiled.cpp:    nlocal = atom->nlocal;
comm_tiled.cpp:    atom->nlocal = nlocal;
comm_tiled.cpp:  if (atom->firstgroupname) atom->first_reorder();
comm_tiled.cpp:  AtomVec *avec = atom->avec;
comm_tiled.cpp:    x = atom->x;
comm_tiled.cpp:    if (iswap % 2 == 0) nlast = atom->nlocal + atom->nghost;
comm_tiled.cpp:          ngroup = atom->nfirst;
comm_tiled.cpp:          for (i = atom->nlocal; i < nlast; i++) {
comm_tiled.cpp:          ngroup = atom->nfirst;
comm_tiled.cpp:          for (i = atom->nlocal; i < nlast; i++) {
comm_tiled.cpp:        int* type=atom->type;
comm_tiled.cpp:          ngroup = atom->nfirst;
comm_tiled.cpp:          for (i = atom->nlocal; i < nlast; i++) {
comm_tiled.cpp:        firstrecv[iswap][0] = atom->nlocal + atom->nghost;
comm_tiled.cpp:      nprior = atom->nghost + atom->nlocal;
comm_tiled.cpp:      atom->nghost += forward_recv_offset[iswap][n-1] + recvnum[iswap][n-1];
comm_tiled.cpp:  if ((atom->molecular != Atom::ATOMIC)
comm_tiled.cpp:      && ((atom->nlocal + atom->nghost) > NEIGHMASK))
comm_tiled.cpp:  if (map_style != Atom::MAP_NONE) atom->map_set();
comm_tiled.cpp:  memory->create(sendbox_multiold[i],n,atom->ntypes+1,6,"comm:sendbox_multiold");
compute_aggregate_atom.cpp:  if (atom->avec->bonds_allow == 0)
compute_aggregate_atom.cpp:  if (atom->tag_enable == 0)
compute_aggregate_atom.cpp:  if (atom->nmax > nmax) {
compute_aggregate_atom.cpp:    nmax = atom->nmax;
compute_aggregate_atom.cpp:  int nlocal = atom->nlocal;
compute_aggregate_atom.cpp:  tagint *tag = atom->tag;
compute_aggregate_atom.cpp:  int *mask = atom->mask;
compute_aggregate_atom.cpp:  int *num_bond = atom->num_bond;
compute_aggregate_atom.cpp:  int **bond_type = atom->bond_type;
compute_aggregate_atom.cpp:  tagint **bond_atom = atom->bond_atom;
compute_aggregate_atom.cpp:  double **x = atom->x;
compute_aggregate_atom.cpp:  for (i = 0; i < nlocal + atom->nghost; i++)
compute_aggregate_atom.cpp:          k = atom->map(bond_atom[i][j]);
compute_aggregate_atom.cpp:    int *mask = atom->mask;
compute_aggregate_atom.cpp:    int *mask = atom->mask;
compute_aggregate_atom.cpp:   memory usage of local atom-based array
compute_angle_local.cpp:  if (atom->avec->angles_allow == 0)
compute_angle_local.cpp:  double **x = atom->x;
compute_angle_local.cpp:  tagint *tag = atom->tag;
compute_angle_local.cpp:  int *num_angle = atom->num_angle;
compute_angle_local.cpp:  tagint **angle_atom1 = atom->angle_atom1;
compute_angle_local.cpp:  tagint **angle_atom2 = atom->angle_atom2;
compute_angle_local.cpp:  tagint **angle_atom3 = atom->angle_atom3;
compute_angle_local.cpp:  int **angle_type = atom->angle_type;
compute_angle_local.cpp:  int *mask = atom->mask;
compute_angle_local.cpp:  int *molindex = atom->molindex;
compute_angle_local.cpp:  int *molatom = atom->molatom;
compute_angle_local.cpp:  Molecule **onemols = atom->avec->onemols;
compute_angle_local.cpp:  int nlocal = atom->nlocal;
compute_angle_local.cpp:  int molecular = atom->molecular;
compute_angle_local.cpp:        atom1 = atom->map(angle_atom1[atom2][i]);
compute_angle_local.cpp:        atom3 = atom->map(angle_atom3[atom2][i]);
compute_angle_local.cpp:        atom1 = atom->map(onemols[imol]->angle_atom1[atom2][i]+tagprev);
compute_angle_local.cpp:        atom3 = atom->map(onemols[imol]->angle_atom3[atom2][i]+tagprev);
compute_angmom_chunk.cpp:  double **x = atom->x;
compute_angmom_chunk.cpp:  int *mask = atom->mask;
compute_angmom_chunk.cpp:  int *type = atom->type;
compute_angmom_chunk.cpp:  imageint *image = atom->image;
compute_angmom_chunk.cpp:  double *mass = atom->mass;
compute_angmom_chunk.cpp:  double *rmass = atom->rmass;
compute_angmom_chunk.cpp:  int nlocal = atom->nlocal;
compute_angmom_chunk.cpp:  double **v = atom->v;
compute_bond_local.cpp:  if (atom->avec->bonds_allow == 0)
compute_bond_local.cpp:  double **x = atom->x;
compute_bond_local.cpp:  double **v = atom->v;
compute_bond_local.cpp:  int *type = atom->type;
compute_bond_local.cpp:  double *mass = atom->mass;
compute_bond_local.cpp:  double *rmass = atom->rmass;
compute_bond_local.cpp:  tagint *tag = atom->tag;
compute_bond_local.cpp:  int *num_bond = atom->num_bond;
compute_bond_local.cpp:  tagint **bond_atom = atom->bond_atom;
compute_bond_local.cpp:  int **bond_type = atom->bond_type;
compute_bond_local.cpp:  int *mask = atom->mask;
compute_bond_local.cpp:  int *molindex = atom->molindex;
compute_bond_local.cpp:  int *molatom = atom->molatom;
compute_bond_local.cpp:  Molecule **onemols = atom->avec->onemols;
compute_bond_local.cpp:  int nlocal = atom->nlocal;
compute_bond_local.cpp:  int molecular = atom->molecular;
compute_bond_local.cpp:        atom2 = atom->map(bond_atom[atom1][i]);
compute_bond_local.cpp:        atom2 = atom->map(onemols[imol]->bond_atom[iatom][i]+tagprev);
compute_bond_local.cpp:  double **v = atom->v;
compute_bond_local.cpp:  double **v = atom->v;
compute_centro_atom.cpp:  if (atom->nmax > nmax) {
compute_centro_atom.cpp:      nmax = atom->nmax;
compute_centro_atom.cpp:      nmax = atom->nmax;
compute_centro_atom.cpp:  double **x = atom->x;
compute_centro_atom.cpp:  int *mask = atom->mask;
compute_centro_atom.cpp:   memory usage of local atom-based array
compute_centroid_stress_atom.cpp:  // needs to be atom->nmax in length
compute_centroid_stress_atom.cpp:  if (atom->nmax > nmax) {
compute_centroid_stress_atom.cpp:    nmax = atom->nmax;
compute_centroid_stress_atom.cpp:  int nlocal = atom->nlocal;
compute_centroid_stress_atom.cpp:  if (force->newton) npair += atom->nghost;
compute_centroid_stress_atom.cpp:  if (force->newton_bond) nbond += atom->nghost;
compute_centroid_stress_atom.cpp:  if (force->newton) ntotal += atom->nghost;
compute_centroid_stress_atom.cpp:  if (force->kspace && force->kspace->tip4pflag) nkspace += atom->nghost;
compute_centroid_stress_atom.cpp:  int *mask = atom->mask;
compute_centroid_stress_atom.cpp:    double **v = atom->v;
compute_centroid_stress_atom.cpp:    double *mass = atom->mass;
compute_centroid_stress_atom.cpp:    double *rmass = atom->rmass;
compute_centroid_stress_atom.cpp:    int *type = atom->type;
compute_centroid_stress_atom.cpp:   memory usage of local atom-based array
compute_chunk_atom.cpp:  if (which == ArgInfo::MOLECULE && !atom->molecule_flag)
compute_chunk_atom.cpp:                 "atom-style variable");
compute_chunk_atom.cpp:    tagint *molecule = atom->molecule;
compute_chunk_atom.cpp:    int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  if (atom->nmax > nmax) {
compute_chunk_atom.cpp:    nmax = atom->nmax;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  const int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  if (which == ArgInfo::TYPE) nchunk = atom->ntypes;
compute_chunk_atom.cpp:    int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  if (atom->nmax > nmaxint) {
compute_chunk_atom.cpp:    nmaxint = atom->nmax;
compute_chunk_atom.cpp:  double **x = atom->x;
compute_chunk_atom.cpp:  int *mask = atom->mask;
compute_chunk_atom.cpp:  const int nlocal = atom->nlocal;
compute_chunk_atom.cpp:    int *type = atom->type;
compute_chunk_atom.cpp:    tagint *molecule = atom->molecule;
compute_chunk_atom.cpp:    if (atom->nmax > maxvar) {
compute_chunk_atom.cpp:      maxvar = atom->nmax;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  tagint *molecule = atom->molecule;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  double **x = atom->x;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  double **x = atom->x;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  double **x = atom->x;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  double **x = atom->x;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:  double **x = atom->x;
compute_chunk_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_atom.cpp:   memory usage of local atom-based arrays and per-chunk arrays
compute_chunk_spread_atom.cpp:  if (atom->nmax > nmax) {
compute_chunk_spread_atom.cpp:      nmax = atom->nmax;
compute_chunk_spread_atom.cpp:      nmax = atom->nmax;
compute_chunk_spread_atom.cpp:  int *mask = atom->mask;
compute_chunk_spread_atom.cpp:  int nlocal = atom->nlocal;
compute_chunk_spread_atom.cpp:   memory usage of local atom-based array
compute_cluster_atom.cpp:  if (atom->tag_enable == 0)
compute_cluster_atom.cpp:  if (atom->nmax > nmax) {
compute_cluster_atom.cpp:    nmax = atom->nmax;
compute_cluster_atom.cpp:  tagint *tag = atom->tag;
compute_cluster_atom.cpp:  int *mask = atom->mask;
compute_cluster_atom.cpp:  double **x = atom->x;
compute_cluster_atom.cpp:    int *mask = atom->mask;
compute_cluster_atom.cpp:    double **x = atom->x;
compute_cluster_atom.cpp:    int *mask = atom->mask;
compute_cluster_atom.cpp:    double **x = atom->x;
compute_cluster_atom.cpp:   memory usage of local atom-based array
compute_cna_atom.cpp:  if (atom->nmax > nmax) {
compute_cna_atom.cpp:    nmax = atom->nmax;
compute_cna_atom.cpp:  double **x = atom->x;
compute_cna_atom.cpp:  int *mask = atom->mask;
compute_cna_atom.cpp:  int nlocal = atom->nlocal;
compute_cna_atom.cpp:   memory usage of local atom-based array
compute_com_chunk.cpp:  double **x = atom->x;
compute_com_chunk.cpp:  int *mask = atom->mask;
compute_com_chunk.cpp:  int *type = atom->type;
compute_com_chunk.cpp:  imageint *image = atom->image;
compute_com_chunk.cpp:  double *mass = atom->mass;
compute_com_chunk.cpp:  double *rmass = atom->rmass;
compute_com_chunk.cpp:  int nlocal = atom->nlocal;
compute_coord_atom.cpp:    int ntypes = atom->ntypes;
compute_coord_atom.cpp:    typehi[0] = atom->ntypes;
compute_coord_atom.cpp:  if (atom->nmax > nmax) {
compute_coord_atom.cpp:      nmax = atom->nmax;
compute_coord_atom.cpp:      nmax = atom->nmax;
compute_coord_atom.cpp:  double **x = atom->x;
compute_coord_atom.cpp:  int *type = atom->type;
compute_coord_atom.cpp:  int *mask = atom->mask;
compute_coord_atom.cpp:   memory usage of local atom-based array
compute_dihedral_local.cpp:  if (atom->avec->dihedrals_allow == 0)
compute_dihedral_local.cpp:  double **x = atom->x;
compute_dihedral_local.cpp:  tagint *tag = atom->tag;
compute_dihedral_local.cpp:  int *num_dihedral = atom->num_dihedral;
compute_dihedral_local.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
compute_dihedral_local.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
compute_dihedral_local.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
compute_dihedral_local.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
compute_dihedral_local.cpp:  int *mask = atom->mask;
compute_dihedral_local.cpp:  int *molindex = atom->molindex;
compute_dihedral_local.cpp:  int *molatom = atom->molatom;
compute_dihedral_local.cpp:  Molecule **onemols = atom->avec->onemols;
compute_dihedral_local.cpp:  int nlocal = atom->nlocal;
compute_dihedral_local.cpp:  int molecular = atom->molecular;
compute_dihedral_local.cpp:        atom1 = atom->map(dihedral_atom1[atom2][i]);
compute_dihedral_local.cpp:        atom3 = atom->map(dihedral_atom3[atom2][i]);
compute_dihedral_local.cpp:        atom4 = atom->map(dihedral_atom4[atom2][i]);
compute_dihedral_local.cpp:        atom1 = atom->map(onemols[imol]->dihedral_atom1[atom2][i]+tagprev);
compute_dihedral_local.cpp:        atom3 = atom->map(onemols[imol]->dihedral_atom3[atom2][i]+tagprev);
compute_dihedral_local.cpp:        atom4 = atom->map(onemols[imol]->dihedral_atom4[atom2][i]+tagprev);
compute_dipole_chunk.cpp:  double **x = atom->x;
compute_dipole_chunk.cpp:  int *mask = atom->mask;
compute_dipole_chunk.cpp:  int *type = atom->type;
compute_dipole_chunk.cpp:  imageint *image = atom->image;
compute_dipole_chunk.cpp:  double *mass = atom->mass;
compute_dipole_chunk.cpp:  double *rmass = atom->rmass;
compute_dipole_chunk.cpp:  double *q = atom->q;
compute_dipole_chunk.cpp:  double **mu = atom->mu;
compute_dipole_chunk.cpp:  int nlocal = atom->nlocal;
compute_dipole_chunk.cpp:      if (atom->q_flag) chrgproc[index] += atom->q[i];
compute_dipole_chunk.cpp:      if (atom->q_flag) {
compute_dipole_chunk.cpp:      if (atom->mu_flag) {
compute_dipole.cpp:  const auto x = atom->x;
compute_dipole.cpp:  const auto mask = atom->mask;
compute_dipole.cpp:  const auto type = atom->type;
compute_dipole.cpp:  const auto image = atom->image;
compute_dipole.cpp:  const auto mass = atom->mass;
compute_dipole.cpp:  const auto rmass = atom->rmass;
compute_dipole.cpp:  const auto q = atom->q;
compute_dipole.cpp:  const auto mu = atom->mu;
compute_dipole.cpp:  const auto nlocal = atom->nlocal;
compute_dipole.cpp:      if (atom->q_flag) chrgproc += q[i];
compute_dipole.cpp:      if (atom->q_flag) {
compute_dipole.cpp:      if (atom->mu_flag) {
compute_displace_atom.cpp:                 "is not atom-style variable");
compute_displace_atom.cpp:    double **x = atom->x;
compute_displace_atom.cpp:    int *mask = atom->mask;
compute_displace_atom.cpp:    imageint *image = atom->image;
compute_displace_atom.cpp:    int nlocal = atom->nlocal;
compute_displace_atom.cpp:  if (atom->nmax > nmax) {
compute_displace_atom.cpp:    nmax = atom->nmax;
compute_displace_atom.cpp:  double **x = atom->x;
compute_displace_atom.cpp:  int *mask = atom->mask;
compute_displace_atom.cpp:  imageint *image = atom->image;
compute_displace_atom.cpp:  int nlocal = atom->nlocal;
compute_displace_atom.cpp:  double **x = atom->x;
compute_displace_atom.cpp:   reset per-atom storage values, based on atom-style variable evaluation
compute_displace_atom.cpp:  if (atom->nmax > nvmax) {
compute_displace_atom.cpp:    nvmax = atom->nmax;
compute_displace_atom.cpp:  double **x = atom->x;
compute_displace_atom.cpp:  imageint *image = atom->image;
compute_displace_atom.cpp:  int nlocal = atom->nlocal;
compute_displace_atom.cpp:   memory usage of local atom-based array
compute_erotate_sphere_atom.cpp:  if (!atom->sphere_flag)
compute_erotate_sphere_atom.cpp:  if (atom->nmax > nmax) {
compute_erotate_sphere_atom.cpp:    nmax = atom->nmax;
compute_erotate_sphere_atom.cpp:  double **omega = atom->omega;
compute_erotate_sphere_atom.cpp:  double *radius = atom->radius;
compute_erotate_sphere_atom.cpp:  double *rmass = atom->rmass;
compute_erotate_sphere_atom.cpp:  int *mask = atom->mask;
compute_erotate_sphere_atom.cpp:  int nlocal = atom->nlocal;
compute_erotate_sphere_atom.cpp:   memory usage of local atom-based array
compute_erotate_sphere.cpp:  if (!atom->sphere_flag)
compute_erotate_sphere.cpp:  double **omega = atom->omega;
compute_erotate_sphere.cpp:  double *radius = atom->radius;
compute_erotate_sphere.cpp:  double *rmass = atom->rmass;
compute_erotate_sphere.cpp:  int *mask = atom->mask;
compute_erotate_sphere.cpp:  int nlocal = atom->nlocal;
compute_fragment_atom.cpp:  if (atom->avec->bonds_allow == 0)
compute_fragment_atom.cpp:  if (atom->tag_enable == 0)
compute_fragment_atom.cpp:  if (atom->molecular != Atom::MOLECULAR)
compute_fragment_atom.cpp:  if (atom->nmax > nmax) {
compute_fragment_atom.cpp:    nmax = atom->nmax;
compute_fragment_atom.cpp:  tagint *tag = atom->tag;
compute_fragment_atom.cpp:  int *mask = atom->mask;
compute_fragment_atom.cpp:  tagint **special = atom->special;
compute_fragment_atom.cpp:  int **nspecial = atom->nspecial;
compute_fragment_atom.cpp:  int nlocal = atom->nlocal;
compute_fragment_atom.cpp:  int nall = nlocal + atom->nghost;
compute_fragment_atom.cpp:          k = atom->map(list[m]);
compute_fragment_atom.cpp:    int *mask = atom->mask;
compute_fragment_atom.cpp:    int *mask = atom->mask;
compute_fragment_atom.cpp:   memory usage of local atom-based arrays
compute_global_atom.cpp:                 "atom-style variable");
compute_global_atom.cpp:  if (atom->nmax > nmax) {
compute_global_atom.cpp:    nmax = atom->nmax;
compute_global_atom.cpp:  int *mask = atom->mask;
compute_global_atom.cpp:  int nlocal = atom->nlocal;
compute_global_atom.cpp:   memory usage of local atom-based array
compute_group_group.cpp:      if (molflag != OFF && atom->molecule_flag == 0)
compute_group_group.cpp:  double **x = atom->x;
compute_group_group.cpp:  tagint *molecule = atom->molecule;
compute_group_group.cpp:  int *type = atom->type;
compute_group_group.cpp:  int *mask = atom->mask;
compute_group_group.cpp:  int nlocal = atom->nlocal;
compute_group_group.cpp:  double *q = atom->q;
compute_group_group.cpp:  int *mask = atom->mask;
compute_group_group.cpp:  for (int i = 0; i < atom->nlocal; i++) {
compute_group_group.cpp:  for (int i = 0; i < atom->nlocal; i++) {
compute_gyration_chunk.cpp:  double **x = atom->x;
compute_gyration_chunk.cpp:  int *mask = atom->mask;
compute_gyration_chunk.cpp:  int *type = atom->type;
compute_gyration_chunk.cpp:  imageint *image = atom->image;
compute_gyration_chunk.cpp:  double *mass = atom->mass;
compute_gyration_chunk.cpp:  double *rmass = atom->rmass;
compute_gyration_chunk.cpp:  int nlocal = atom->nlocal;
compute_gyration_chunk.cpp:  double **x = atom->x;
compute_gyration_chunk.cpp:  int *mask = atom->mask;
compute_gyration_chunk.cpp:  int *type = atom->type;
compute_gyration_chunk.cpp:  imageint *image = atom->image;
compute_gyration_chunk.cpp:  double *mass = atom->mass;
compute_gyration_chunk.cpp:  double *rmass = atom->rmass;
compute_gyration_chunk.cpp:  int nlocal = atom->nlocal;
compute_gyration_chunk.cpp:  double **x = atom->x;
compute_gyration_chunk.cpp:  int *mask = atom->mask;
compute_gyration_chunk.cpp:  int *type = atom->type;
compute_gyration_chunk.cpp:  imageint *image = atom->image;
compute_gyration_chunk.cpp:  double *mass = atom->mass;
compute_gyration_chunk.cpp:  double *rmass = atom->rmass;
compute_gyration_chunk.cpp:  int nlocal = atom->nlocal;
compute_gyration.cpp:  double **x = atom->x;
compute_gyration.cpp:  int *mask = atom->mask;
compute_gyration.cpp:  int *type = atom->type;
compute_gyration.cpp:  imageint *image = atom->image;
compute_gyration.cpp:  double *mass = atom->mass;
compute_gyration.cpp:  double *rmass = atom->rmass;
compute_gyration.cpp:  int nlocal = atom->nlocal;
compute_heat_flux.cpp:  double **v = atom->v;
compute_heat_flux.cpp:  int *mask = atom->mask;
compute_heat_flux.cpp:  int nlocal = atom->nlocal;
compute_improper_local.cpp:  if (atom->avec->impropers_allow == 0)
compute_improper_local.cpp:  double **x = atom->x;
compute_improper_local.cpp:  tagint *tag = atom->tag;
compute_improper_local.cpp:  int *num_improper = atom->num_improper;
compute_improper_local.cpp:  tagint **improper_atom1 = atom->improper_atom1;
compute_improper_local.cpp:  tagint **improper_atom2 = atom->improper_atom2;
compute_improper_local.cpp:  tagint **improper_atom3 = atom->improper_atom3;
compute_improper_local.cpp:  tagint **improper_atom4 = atom->improper_atom4;
compute_improper_local.cpp:  int *mask = atom->mask;
compute_improper_local.cpp:  int *molindex = atom->molindex;
compute_improper_local.cpp:  int *molatom = atom->molatom;
compute_improper_local.cpp:  Molecule **onemols = atom->avec->onemols;
compute_improper_local.cpp:  int nlocal = atom->nlocal;
compute_improper_local.cpp:  int molecular = atom->molecular;
compute_improper_local.cpp:        atom1 = atom->map(improper_atom1[atom2][i]);
compute_improper_local.cpp:        atom3 = atom->map(improper_atom3[atom2][i]);
compute_improper_local.cpp:        atom4 = atom->map(improper_atom4[atom2][i]);
compute_improper_local.cpp:        atom1 = atom->map(onemols[imol]->improper_atom1[atom2][i]+tagprev);
compute_improper_local.cpp:        atom3 = atom->map(onemols[imol]->improper_atom3[atom2][i]+tagprev);
compute_improper_local.cpp:        atom4 = atom->map(onemols[imol]->improper_atom4[atom2][i]+tagprev);
compute_inertia_chunk.cpp:  double **x = atom->x;
compute_inertia_chunk.cpp:  int *mask = atom->mask;
compute_inertia_chunk.cpp:  int *type = atom->type;
compute_inertia_chunk.cpp:  imageint *image = atom->image;
compute_inertia_chunk.cpp:  double *mass = atom->mass;
compute_inertia_chunk.cpp:  double *rmass = atom->rmass;
compute_inertia_chunk.cpp:  int nlocal = atom->nlocal;
compute_ke_atom.cpp:  if (atom->nmax > nmax) {
compute_ke_atom.cpp:    nmax = atom->nmax;
compute_ke_atom.cpp:  double **v = atom->v;
compute_ke_atom.cpp:  double *mass = atom->mass;
compute_ke_atom.cpp:  double *rmass = atom->rmass;
compute_ke_atom.cpp:  int *mask = atom->mask;
compute_ke_atom.cpp:  int *type = atom->type;
compute_ke_atom.cpp:  int nlocal = atom->nlocal;
compute_ke_atom.cpp:   memory usage of local atom-based array
compute_ke.cpp:  double **v = atom->v;
compute_ke.cpp:  double *rmass = atom->rmass;
compute_ke.cpp:  double *mass = atom->mass;
compute_ke.cpp:  int *mask = atom->mask;
compute_ke.cpp:  int *type = atom->type;
compute_ke.cpp:  int nlocal = atom->nlocal;
compute_msd_chunk.cpp:  double **x = atom->x;
compute_msd_chunk.cpp:  int *mask = atom->mask;
compute_msd_chunk.cpp:  int *type = atom->type;
compute_msd_chunk.cpp:  imageint *image = atom->image;
compute_msd_chunk.cpp:  double *mass = atom->mass;
compute_msd_chunk.cpp:  double *rmass = atom->rmass;
compute_msd_chunk.cpp:  int nlocal = atom->nlocal;
compute_msd.cpp:    double **x = atom->x;
compute_msd.cpp:    int *mask = atom->mask;
compute_msd.cpp:    imageint *image = atom->image;
compute_msd.cpp:    int nlocal = atom->nlocal;
compute_msd.cpp:  double **x = atom->x;
compute_msd.cpp:  int *mask = atom->mask;
compute_msd.cpp:  imageint *image = atom->image;
compute_msd.cpp:  int nlocal = atom->nlocal;
compute_msd.cpp:  double **x = atom->x;
compute_omega_chunk.cpp:  double **x = atom->x;
compute_omega_chunk.cpp:  int *mask = atom->mask;
compute_omega_chunk.cpp:  int *type = atom->type;
compute_omega_chunk.cpp:  imageint *image = atom->image;
compute_omega_chunk.cpp:  double *mass = atom->mass;
compute_omega_chunk.cpp:  double *rmass = atom->rmass;
compute_omega_chunk.cpp:  int nlocal = atom->nlocal;
compute_omega_chunk.cpp:  double **v = atom->v;
compute_orientorder_atom.cpp:  if (atom->nmax > nmax) {
compute_orientorder_atom.cpp:    nmax = atom->nmax;
compute_orientorder_atom.cpp:  double **x = atom->x;
compute_orientorder_atom.cpp:  int *mask = atom->mask;
compute_orientorder_atom.cpp:   memory usage of local atom-based array
compute_pair_local.cpp:  if (cutstyle == RADIUS && !atom->radius_flag)
compute_pair_local.cpp:  double **x = atom->x;
compute_pair_local.cpp:  double *radius = atom->radius;
compute_pair_local.cpp:  tagint *tag = atom->tag;
compute_pair_local.cpp:  int *type = atom->type;
compute_pair_local.cpp:  int *mask = atom->mask;
compute_pair_local.cpp:  int nlocal = atom->nlocal;
compute_pe_atom.cpp:  // needs to be atom->nmax in length
compute_pe_atom.cpp:  if (atom->nmax > nmax) {
compute_pe_atom.cpp:    nmax = atom->nmax;
compute_pe_atom.cpp:  int nlocal = atom->nlocal;
compute_pe_atom.cpp:  if (force->newton) npair += atom->nghost;
compute_pe_atom.cpp:  if (force->newton_bond) nbond += atom->nghost;
compute_pe_atom.cpp:  if (force->newton) ntotal += atom->nghost;
compute_pe_atom.cpp:  if (force->kspace && force->kspace->tip4pflag) nkspace += atom->nghost;
compute_pe_atom.cpp:  int *mask = atom->mask;
compute_pe_atom.cpp:   memory usage of local atom-based array
compute_pe.cpp:  if (atom->molecular != Atom::ATOMIC) {
compute_pressure.cpp:  if (atom->molecular != Atom::ATOMIC) {
compute_property_atom.cpp:      if (!atom->molecule_flag)
compute_property_atom.cpp:      if (!atom->q_flag)
compute_property_atom.cpp:      if (!atom->mu_flag)
compute_property_atom.cpp:      if (!atom->mu_flag)
compute_property_atom.cpp:      if (!atom->mu_flag)
compute_property_atom.cpp:      if (!atom->mu_flag)
compute_property_atom.cpp:      if (!atom->sp_flag)
compute_property_atom.cpp:      if (!atom->sp_flag)
compute_property_atom.cpp:      if (!atom->sp_flag)
compute_property_atom.cpp:      if (!atom->sp_flag)
compute_property_atom.cpp:      if (!atom->sp_flag)
compute_property_atom.cpp:      if (!atom->sp_flag)
compute_property_atom.cpp:      if (!atom->sp_flag)
compute_property_atom.cpp:      if (!atom->molecule_flag)
compute_property_atom.cpp:      if (!atom->radius_flag)
compute_property_atom.cpp:      if (!atom->radius_flag)
compute_property_atom.cpp:      if (!atom->omega_flag)
compute_property_atom.cpp:      if (!atom->omega_flag)
compute_property_atom.cpp:      if (!atom->omega_flag)
compute_property_atom.cpp:      if (!atom->angmom_flag)
compute_property_atom.cpp:      if (!atom->angmom_flag)
compute_property_atom.cpp:      if (!atom->angmom_flag)
compute_property_atom.cpp:      avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:      avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:      avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:      avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:      avec_body = (AtomVecBody *) atom->style_match("body");
compute_property_atom.cpp:      avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:      avec_body = (AtomVecBody *) atom->style_match("body");
compute_property_atom.cpp:      avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:      avec_body = (AtomVecBody *) atom->style_match("body");
compute_property_atom.cpp:      avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:      avec_body = (AtomVecBody *) atom->style_match("body");
compute_property_atom.cpp:      if (!atom->torque_flag)
compute_property_atom.cpp:      if (!atom->torque_flag)
compute_property_atom.cpp:      if (!atom->torque_flag)
compute_property_atom.cpp:      avec_line = (AtomVecLine *) atom->style_match("line");
compute_property_atom.cpp:      avec_line = (AtomVecLine *) atom->style_match("line");
compute_property_atom.cpp:      avec_line = (AtomVecLine *) atom->style_match("line");
compute_property_atom.cpp:      avec_line = (AtomVecLine *) atom->style_match("line");
compute_property_atom.cpp:      avec_line = (AtomVecLine *) atom->style_match("line");
compute_property_atom.cpp:      avec_line = (AtomVecLine *) atom->style_match("line");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:      if (!atom->molecule_flag)
compute_property_atom.cpp:      index[i] = atom->find_custom(pname,flag,cols);
compute_property_atom.cpp:      index[i] = atom->avec->property_atom(arg[iarg]);
compute_property_atom.cpp:  avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
compute_property_atom.cpp:  avec_line = (AtomVecLine *) atom->style_match("line");
compute_property_atom.cpp:  avec_tri = (AtomVecTri *) atom->style_match("tri");
compute_property_atom.cpp:  avec_body = (AtomVecBody *) atom->style_match("body");
compute_property_atom.cpp:  if (atom->nmax > nmax) {
compute_property_atom.cpp:    nmax = atom->nmax;
compute_property_atom.cpp:   memory usage of local atom-based array
compute_property_atom.cpp:  tagint *tag = atom->tag;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  tagint *molecule = atom->molecule;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *type = atom->type;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *type = atom->type;
compute_property_atom.cpp:  double *mass = atom->mass;
compute_property_atom.cpp:  double *rmass = atom->rmass;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  imageint *image = atom->image;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **v = atom->v;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **v = atom->v;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **v = atom->v;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **f = atom->f;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **f = atom->f;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **f = atom->f;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double *q = atom->q;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **mu = atom->mu;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **mu = atom->mu;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **mu = atom->mu;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **mu = atom->mu;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **sp = atom->sp;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **sp = atom->sp;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **sp = atom->sp;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **sp = atom->sp;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **fm = atom->fm;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **fm = atom->fm;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **fm = atom->fm;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double *radius = atom->radius;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double *radius = atom->radius;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **omega = atom->omega;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **omega = atom->omega;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **omega = atom->omega;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **angmom = atom->angmom;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **angmom = atom->angmom;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **angmom = atom->angmom;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *ellipsoid = atom->ellipsoid;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *ellipsoid = atom->ellipsoid;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *ellipsoid = atom->ellipsoid;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *ellipsoid = atom->ellipsoid;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *body = atom->body;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *ellipsoid = atom->ellipsoid;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *body = atom->body;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *ellipsoid = atom->ellipsoid;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *body = atom->body;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *ellipsoid = atom->ellipsoid;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:    int *body = atom->body;
compute_property_atom.cpp:    int *mask = atom->mask;
compute_property_atom.cpp:    int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **torque = atom->torque;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **torque = atom->torque;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **torque = atom->torque;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *line = atom->line;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *line = atom->line;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *line = atom->line;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *line = atom->line;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *tri = atom->tri;
compute_property_atom.cpp:  double **x = atom->x;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *num_bond = atom->num_bond;
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int *ivector = atom->ivector[index[n]];
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double *dvector = atom->dvector[index[n]];
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  int **iarray = atom->iarray[index[n]];
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  double **darray = atom->darray[index[n]];
compute_property_atom.cpp:  int *mask = atom->mask;
compute_property_atom.cpp:  int nlocal = atom->nlocal;
compute_property_atom.cpp:  atom->avec->pack_property_atom(index[n],&buf[n],nvalues,groupbit);
compute_property_chunk.cpp:  int *mask = atom->mask;
compute_property_chunk.cpp:  int nlocal = atom->nlocal;
compute_property_local.cpp:  if (atom->molecular == 2 &&
compute_property_local.cpp:  if (kindflag == BOND && atom->avec->bonds_allow == 0)
compute_property_local.cpp:  if (kindflag == ANGLE && atom->avec->angles_allow == 0)
compute_property_local.cpp:  if (kindflag == DIHEDRAL && atom->avec->dihedrals_allow == 0)
compute_property_local.cpp:  if (kindflag == IMPROPER && atom->avec->impropers_allow == 0)
compute_property_local.cpp:  if (cutstyle == RADIUS && !atom->radius_flag)
compute_property_local.cpp:  double **x = atom->x;
compute_property_local.cpp:  double *radius = atom->radius;
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  int *type = atom->type;
compute_property_local.cpp:  int *mask = atom->mask;
compute_property_local.cpp:  int nlocal = atom->nlocal;
compute_property_local.cpp:  int *num_bond = atom->num_bond;
compute_property_local.cpp:  tagint **bond_atom = atom->bond_atom;
compute_property_local.cpp:  int **bond_type = atom->bond_type;
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  int *mask = atom->mask;
compute_property_local.cpp:  int nlocal = atom->nlocal;
compute_property_local.cpp:      atom2 = atom->map(bond_atom[atom1][i]);
compute_property_local.cpp:  int *num_angle = atom->num_angle;
compute_property_local.cpp:  tagint **angle_atom1 = atom->angle_atom1;
compute_property_local.cpp:  tagint **angle_atom2 = atom->angle_atom2;
compute_property_local.cpp:  tagint **angle_atom3 = atom->angle_atom3;
compute_property_local.cpp:  int **angle_type = atom->angle_type;
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  int *mask = atom->mask;
compute_property_local.cpp:  int nlocal = atom->nlocal;
compute_property_local.cpp:      atom1 = atom->map(angle_atom1[atom2][i]);
compute_property_local.cpp:      atom3 = atom->map(angle_atom3[atom2][i]);
compute_property_local.cpp:  int *num_dihedral = atom->num_dihedral;
compute_property_local.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
compute_property_local.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
compute_property_local.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
compute_property_local.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  int *mask = atom->mask;
compute_property_local.cpp:  int nlocal = atom->nlocal;
compute_property_local.cpp:      atom1 = atom->map(dihedral_atom1[atom2][i]);
compute_property_local.cpp:      atom3 = atom->map(dihedral_atom3[atom2][i]);
compute_property_local.cpp:      atom4 = atom->map(dihedral_atom4[atom2][i]);
compute_property_local.cpp:  int *num_improper = atom->num_improper;
compute_property_local.cpp:  tagint **improper_atom1 = atom->improper_atom1;
compute_property_local.cpp:  tagint **improper_atom2 = atom->improper_atom2;
compute_property_local.cpp:  tagint **improper_atom3 = atom->improper_atom3;
compute_property_local.cpp:  tagint **improper_atom4 = atom->improper_atom4;
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  int *mask = atom->mask;
compute_property_local.cpp:  int nlocal = atom->nlocal;
compute_property_local.cpp:      atom1 = atom->map(improper_atom1[atom2][i]);
compute_property_local.cpp:      atom3 = atom->map(improper_atom3[atom2][i]);
compute_property_local.cpp:      atom4 = atom->map(improper_atom4[atom2][i]);
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  int *type = atom->type;
compute_property_local.cpp:  int *type = atom->type;
compute_property_local.cpp:  tagint *tag = atom->tag;
compute_property_local.cpp:  tagint **bond_atom = atom->bond_atom;
compute_property_local.cpp:  int **bond_type = atom->bond_type;
compute_property_local.cpp:  tagint **angle_atom1 = atom->angle_atom1;
compute_property_local.cpp:  tagint **angle_atom2 = atom->angle_atom2;
compute_property_local.cpp:  tagint **angle_atom3 = atom->angle_atom3;
compute_property_local.cpp:  int **angle_type = atom->angle_type;
compute_property_local.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
compute_property_local.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
compute_property_local.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
compute_property_local.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
compute_property_local.cpp:  int **dihedral_type = atom->dihedral_type;
compute_property_local.cpp:  tagint **improper_atom1 = atom->improper_atom1;
compute_property_local.cpp:  tagint **improper_atom2 = atom->improper_atom2;
compute_property_local.cpp:  tagint **improper_atom3 = atom->improper_atom3;
compute_property_local.cpp:  tagint **improper_atom4 = atom->improper_atom4;
compute_property_local.cpp:  int **improper_type = atom->improper_type;
compute_rdf.cpp:  int ntypes = atom->ntypes;
compute_rdf.cpp:      utils::bounds(FLERR,arg[iarg],1,atom->ntypes,ilo[ipair],ihi[ipair],error);
compute_rdf.cpp:      utils::bounds(FLERR,arg[iarg+1],1,atom->ntypes,jlo[ipair],jhi[ipair],error);
compute_rdf.cpp:  natoms_old = atom->natoms;
compute_rdf.cpp:  const int nlocal = atom->nlocal;
compute_rdf.cpp:  const int ntypes = atom->ntypes;
compute_rdf.cpp:  const int * const mask = atom->mask;
compute_rdf.cpp:  const int * const type = atom->type;
compute_rdf.cpp:  if (natoms_old != atom->natoms) {
compute_rdf.cpp:    natoms_old = atom->natoms;
compute_rdf.cpp:  double **x = atom->x;
compute_rdf.cpp:  int *type = atom->type;
compute_rdf.cpp:  int *mask = atom->mask;
compute_rdf.cpp:  int nlocal = atom->nlocal;
compute_reduce_chunk.cpp:                   "not atom-style variable");
compute_reduce_chunk.cpp:  int *mask = atom->mask;
compute_reduce_chunk.cpp:  int nlocal = atom->nlocal;
compute_reduce_chunk.cpp:  // evaluate atom-style variable
compute_reduce_chunk.cpp:    if (atom->nmax > maxatom) {
compute_reduce_chunk.cpp:      maxatom = atom->nmax;
compute_reduce.cpp:        error->all(FLERR,"Compute reduce variable is not atom-style variable");
compute_reduce.cpp:  int *mask = atom->mask;
compute_reduce.cpp:  int nlocal = atom->nlocal;
compute_reduce.cpp:    double **x = atom->x;
compute_reduce.cpp:    double **v = atom->v;
compute_reduce.cpp:    double **f = atom->f;
compute_reduce.cpp:  // evaluate atom-style variable
compute_reduce.cpp:    if (atom->nmax > maxatom) {
compute_reduce.cpp:      maxatom = atom->nmax;
compute_reduce_region.cpp:  double **x = atom->x;
compute_reduce_region.cpp:  int *mask = atom->mask;
compute_reduce_region.cpp:  int nlocal = atom->nlocal;
compute_reduce_region.cpp:    double **v = atom->v;
compute_reduce_region.cpp:    double **f = atom->f;
compute_reduce_region.cpp:  // evaluate atom-style variable
compute_reduce_region.cpp:    if (atom->nmax > maxatom) {
compute_reduce_region.cpp:      maxatom = atom->nmax;
compute_stress_atom.cpp:  // needs to be atom->nmax in length
compute_stress_atom.cpp:  if (atom->nmax > nmax) {
compute_stress_atom.cpp:    nmax = atom->nmax;
compute_stress_atom.cpp:  int nlocal = atom->nlocal;
compute_stress_atom.cpp:  if (force->newton) npair += atom->nghost;
compute_stress_atom.cpp:  if (force->newton_bond) nbond += atom->nghost;
compute_stress_atom.cpp:  if (force->newton) ntotal += atom->nghost;
compute_stress_atom.cpp:  if (force->kspace && force->kspace->tip4pflag) nkspace += atom->nghost;
compute_stress_atom.cpp:  int *mask = atom->mask;
compute_stress_atom.cpp:    double **v = atom->v;
compute_stress_atom.cpp:    double *mass = atom->mass;
compute_stress_atom.cpp:    double *rmass = atom->rmass;
compute_stress_atom.cpp:    int *type = atom->type;
compute_stress_atom.cpp:   memory usage of local atom-based array
compute_temp_chunk.cpp:  double **v = atom->v;
compute_temp_chunk.cpp:  double *mass = atom->mass;
compute_temp_chunk.cpp:  double *rmass = atom->rmass;
compute_temp_chunk.cpp:  int *type = atom->type;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_chunk.cpp:  double **v = atom->v;
compute_temp_chunk.cpp:  double *mass = atom->mass;
compute_temp_chunk.cpp:  double *rmass = atom->rmass;
compute_temp_chunk.cpp:  int *type = atom->type;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_chunk.cpp:  double **v = atom->v;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int *type = atom->type;
compute_temp_chunk.cpp:  double *mass = atom->mass;
compute_temp_chunk.cpp:  double *rmass = atom->rmass;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_chunk.cpp:  double **v = atom->v;
compute_temp_chunk.cpp:  double *mass = atom->mass;
compute_temp_chunk.cpp:  double *rmass = atom->rmass;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int *type = atom->type;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_chunk.cpp:  double *mass = atom->mass;
compute_temp_chunk.cpp:  double *rmass = atom->rmass;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int *type = atom->type;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_chunk.cpp:  double **v = atom->v;
compute_temp_chunk.cpp:  double *mass = atom->mass;
compute_temp_chunk.cpp:  double *rmass = atom->rmass;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int *type = atom->type;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_chunk.cpp:  double **v = atom->v;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_chunk.cpp:  double **v = atom->v;
compute_temp_chunk.cpp:  int *mask = atom->mask;
compute_temp_chunk.cpp:  int nlocal = atom->nlocal;
compute_temp_com.cpp:  double **v = atom->v;
compute_temp_com.cpp:  double *mass = atom->mass;
compute_temp_com.cpp:  double *rmass = atom->rmass;
compute_temp_com.cpp:  int *type = atom->type;
compute_temp_com.cpp:  int *mask = atom->mask;
compute_temp_com.cpp:  int nlocal = atom->nlocal;
compute_temp_com.cpp:  double **v = atom->v;
compute_temp_com.cpp:  double *mass = atom->mass;
compute_temp_com.cpp:  double *rmass = atom->rmass;
compute_temp_com.cpp:  int *type = atom->type;
compute_temp_com.cpp:  int *mask = atom->mask;
compute_temp_com.cpp:  int nlocal = atom->nlocal;
compute_temp_com.cpp:  double **v = atom->v;
compute_temp_com.cpp:  int *mask = atom->mask;
compute_temp_com.cpp:  int nlocal = atom->nlocal;
compute_temp_com.cpp:  double **v = atom->v;
compute_temp_com.cpp:  int *mask = atom->mask;
compute_temp_com.cpp:  int nlocal = atom->nlocal;
compute_temp.cpp:  double **v = atom->v;
compute_temp.cpp:  double *mass = atom->mass;
compute_temp.cpp:  double *rmass = atom->rmass;
compute_temp.cpp:  int *type = atom->type;
compute_temp.cpp:  int *mask = atom->mask;
compute_temp.cpp:  int nlocal = atom->nlocal;
compute_temp.cpp:  double **v = atom->v;
compute_temp.cpp:  double *mass = atom->mass;
compute_temp.cpp:  double *rmass = atom->rmass;
compute_temp.cpp:  int *type = atom->type;
compute_temp.cpp:  int *mask = atom->mask;
compute_temp.cpp:  int nlocal = atom->nlocal;
compute_temp_deform.cpp:  double **x = atom->x;
compute_temp_deform.cpp:  double **v = atom->v;
compute_temp_deform.cpp:  double *mass = atom->mass;
compute_temp_deform.cpp:  double *rmass = atom->rmass;
compute_temp_deform.cpp:  int *type = atom->type;
compute_temp_deform.cpp:  int *mask = atom->mask;
compute_temp_deform.cpp:  int nlocal = atom->nlocal;
compute_temp_deform.cpp:  double **x = atom->x;
compute_temp_deform.cpp:  double **v = atom->v;
compute_temp_deform.cpp:  double *mass = atom->mass;
compute_temp_deform.cpp:  double *rmass = atom->rmass;
compute_temp_deform.cpp:  int *type = atom->type;
compute_temp_deform.cpp:  int *mask = atom->mask;
compute_temp_deform.cpp:  int nlocal = atom->nlocal;
compute_temp_deform.cpp:  domain->x2lamda(atom->x[i], lamda);
compute_temp_deform.cpp:  domain->x2lamda(atom->x[i], lamda);
compute_temp_deform.cpp:  double **v = atom->v;
compute_temp_deform.cpp:  int *mask = atom->mask;
compute_temp_deform.cpp:  int nlocal = atom->nlocal;
compute_temp_deform.cpp:  if (atom->nmax > maxbias) {
compute_temp_deform.cpp:    maxbias = atom->nmax;
compute_temp_deform.cpp:      domain->x2lamda(atom->x[i], lamda);
compute_temp_deform.cpp:  double **v = atom->v;
compute_temp_deform.cpp:  int *mask = atom->mask;
compute_temp_deform.cpp:  int nlocal = atom->nlocal;
compute_temp_partial.cpp:  double **v = atom->v;
compute_temp_partial.cpp:  double *mass = atom->mass;
compute_temp_partial.cpp:  double *rmass = atom->rmass;
compute_temp_partial.cpp:  int *type = atom->type;
compute_temp_partial.cpp:  int *mask = atom->mask;
compute_temp_partial.cpp:  int nlocal = atom->nlocal;
compute_temp_partial.cpp:  double **v = atom->v;
compute_temp_partial.cpp:  double *mass = atom->mass;
compute_temp_partial.cpp:  double *rmass = atom->rmass;
compute_temp_partial.cpp:  int *type = atom->type;
compute_temp_partial.cpp:  int *mask = atom->mask;
compute_temp_partial.cpp:  int nlocal = atom->nlocal;
compute_temp_partial.cpp:  double **v = atom->v;
compute_temp_partial.cpp:  int *mask = atom->mask;
compute_temp_partial.cpp:  int nlocal = atom->nlocal;
compute_temp_partial.cpp:  if (atom->nmax > maxbias) {
compute_temp_partial.cpp:    maxbias = atom->nmax;
compute_temp_partial.cpp:  double **v = atom->v;
compute_temp_partial.cpp:  int *mask = atom->mask;
compute_temp_partial.cpp:  int nlocal = atom->nlocal;
compute_temp_partial.cpp:  double **v = atom->v;
compute_temp_partial.cpp:  int *mask = atom->mask;
compute_temp_partial.cpp:  int nlocal = atom->nlocal;
compute_temp_profile.cpp:  double **v = atom->v;
compute_temp_profile.cpp:  double *mass = atom->mass;
compute_temp_profile.cpp:  double *rmass = atom->rmass;
compute_temp_profile.cpp:  int *type = atom->type;
compute_temp_profile.cpp:  int *mask = atom->mask;
compute_temp_profile.cpp:  int nlocal = atom->nlocal;
compute_temp_profile.cpp:  double **v = atom->v;
compute_temp_profile.cpp:  double *mass = atom->mass;
compute_temp_profile.cpp:  double *rmass = atom->rmass;
compute_temp_profile.cpp:  int *type = atom->type;
compute_temp_profile.cpp:  int *mask = atom->mask;
compute_temp_profile.cpp:  int nlocal = atom->nlocal;
compute_temp_profile.cpp:  double **v = atom->v;
compute_temp_profile.cpp:  double *mass = atom->mass;
compute_temp_profile.cpp:  double *rmass = atom->rmass;
compute_temp_profile.cpp:  int *type = atom->type;
compute_temp_profile.cpp:  int *mask = atom->mask;
compute_temp_profile.cpp:  int nlocal = atom->nlocal;
compute_temp_profile.cpp:  double **v = atom->v;
compute_temp_profile.cpp:  int *mask = atom->mask;
compute_temp_profile.cpp:  int nlocal = atom->nlocal;
compute_temp_profile.cpp:  double **v = atom->v;
compute_temp_profile.cpp:  int *mask = atom->mask;
compute_temp_profile.cpp:  int nlocal = atom->nlocal;
compute_temp_profile.cpp:  double **v = atom->v;
compute_temp_profile.cpp:  double *mass = atom->mass;
compute_temp_profile.cpp:  double *rmass = atom->rmass;
compute_temp_profile.cpp:  int *mask = atom->mask;
compute_temp_profile.cpp:  int *type = atom->type;
compute_temp_profile.cpp:  int nlocal = atom->nlocal;
compute_temp_profile.cpp:  if (atom->nmax > maxatom) {
compute_temp_profile.cpp:    maxatom = atom->nmax;
compute_temp_profile.cpp:  double **x = atom->x;
compute_temp_profile.cpp:  int *mask = atom->mask;
compute_temp_profile.cpp:  int nlocal = atom->nlocal;
compute_temp_ramp.cpp:  double **x = atom->x;
compute_temp_ramp.cpp:  double **v = atom->v;
compute_temp_ramp.cpp:  double *mass = atom->mass;
compute_temp_ramp.cpp:  double *rmass = atom->rmass;
compute_temp_ramp.cpp:  int *type = atom->type;
compute_temp_ramp.cpp:  int *mask = atom->mask;
compute_temp_ramp.cpp:  int nlocal = atom->nlocal;
compute_temp_ramp.cpp:  double **x = atom->x;
compute_temp_ramp.cpp:  double **v = atom->v;
compute_temp_ramp.cpp:  double *mass = atom->mass;
compute_temp_ramp.cpp:  double *rmass = atom->rmass;
compute_temp_ramp.cpp:  int *type = atom->type;
compute_temp_ramp.cpp:  int *mask = atom->mask;
compute_temp_ramp.cpp:  int nlocal = atom->nlocal;
compute_temp_ramp.cpp:  double fraction = (atom->x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
compute_temp_ramp.cpp:  double fraction = (atom->x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
compute_temp_ramp.cpp:  double **v = atom->v;
compute_temp_ramp.cpp:  int *mask = atom->mask;
compute_temp_ramp.cpp:  int nlocal = atom->nlocal;
compute_temp_ramp.cpp:  if (atom->nmax > maxbias) {
compute_temp_ramp.cpp:    maxbias = atom->nmax;
compute_temp_ramp.cpp:      fraction = (atom->x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
compute_temp_ramp.cpp:  double **v = atom->v;
compute_temp_ramp.cpp:  int *mask = atom->mask;
compute_temp_ramp.cpp:  int nlocal = atom->nlocal;
compute_temp_region.cpp:  double *x = atom->x[i];
compute_temp_region.cpp:  double **x = atom->x;
compute_temp_region.cpp:  double **v = atom->v;
compute_temp_region.cpp:  double *mass = atom->mass;
compute_temp_region.cpp:  double *rmass = atom->rmass;
compute_temp_region.cpp:  int *type = atom->type;
compute_temp_region.cpp:  int *mask = atom->mask;
compute_temp_region.cpp:  int nlocal = atom->nlocal;
compute_temp_region.cpp:  double **x = atom->x;
compute_temp_region.cpp:  double **v = atom->v;
compute_temp_region.cpp:  double *mass = atom->mass;
compute_temp_region.cpp:  double *rmass = atom->rmass;
compute_temp_region.cpp:  int *type = atom->type;
compute_temp_region.cpp:  int *mask = atom->mask;
compute_temp_region.cpp:  int nlocal = atom->nlocal;
compute_temp_region.cpp:  double *x = atom->x[i];
compute_temp_region.cpp:  double *x = atom->x[i];
compute_temp_region.cpp:  double **x = atom->x;
compute_temp_region.cpp:  double **v = atom->v;
compute_temp_region.cpp:  int *mask = atom->mask;
compute_temp_region.cpp:  int nlocal = atom->nlocal;
compute_temp_region.cpp:  if (atom->nmax > maxbias) {
compute_temp_region.cpp:    maxbias = atom->nmax;
compute_temp_region.cpp:  double **v = atom->v;
compute_temp_region.cpp:  int *mask = atom->mask;
compute_temp_region.cpp:  int nlocal = atom->nlocal;
compute_temp_sphere.cpp:  if (!atom->sphere_flag)
compute_temp_sphere.cpp:  double *radius = atom->radius;
compute_temp_sphere.cpp:  const int *mask = atom->mask;
compute_temp_sphere.cpp:  const int nlocal = atom->nlocal;
compute_temp_sphere.cpp:  double **v = atom->v;
compute_temp_sphere.cpp:  double **omega = atom->omega;
compute_temp_sphere.cpp:  double *radius = atom->radius;
compute_temp_sphere.cpp:  double *rmass = atom->rmass;
compute_temp_sphere.cpp:  int *mask = atom->mask;
compute_temp_sphere.cpp:  int nlocal = atom->nlocal;
compute_temp_sphere.cpp:  double **v = atom->v;
compute_temp_sphere.cpp:  double **omega = atom->omega;
compute_temp_sphere.cpp:  double *rmass = atom->rmass;
compute_temp_sphere.cpp:  double *radius = atom->radius;
compute_temp_sphere.cpp:  int *mask = atom->mask;
compute_temp_sphere.cpp:  int nlocal = atom->nlocal;
compute_torque_chunk.cpp:  double **x = atom->x;
compute_torque_chunk.cpp:  int *mask = atom->mask;
compute_torque_chunk.cpp:  int *type = atom->type;
compute_torque_chunk.cpp:  imageint *image = atom->image;
compute_torque_chunk.cpp:  double *mass = atom->mass;
compute_torque_chunk.cpp:  double *rmass = atom->rmass;
compute_torque_chunk.cpp:  int nlocal = atom->nlocal;
compute_torque_chunk.cpp:  double **f = atom->f;
compute_vacf.cpp:    double **v = atom->v;
compute_vacf.cpp:    int *mask = atom->mask;
compute_vacf.cpp:    int nlocal = atom->nlocal;
compute_vacf.cpp:  double **v = atom->v;
compute_vacf.cpp:  int *mask = atom->mask;
compute_vacf.cpp:  int nlocal = atom->nlocal;
compute_vacf.cpp:  double **v = atom->v;
compute_vcm_chunk.cpp:  double **v = atom->v;
compute_vcm_chunk.cpp:  int *mask = atom->mask;
compute_vcm_chunk.cpp:  int *type = atom->type;
compute_vcm_chunk.cpp:  double *mass = atom->mass;
compute_vcm_chunk.cpp:  double *rmass = atom->rmass;
compute_vcm_chunk.cpp:  int nlocal = atom->nlocal;
create_atoms.cpp:      if (ibasis <= 0 || ibasis > nbasis || itype <= 0 || itype > atom->ntypes)
create_atoms.cpp:      int imol = atom->find_molecule(arg[iarg+1]);
create_atoms.cpp:      if (atom->molecules[imol]->nset > 1 && me == 0)
create_atoms.cpp:      onemol = atom->molecules[imol];
create_atoms.cpp:  if (mode == ATOM && (ntype <= 0 || ntype > atom->ntypes))
create_atoms.cpp:    if (ntype+onemol->ntypes <= 0 || ntype+onemol->ntypes > atom->ntypes)
create_atoms.cpp:    if (onemol->tag_require && !atom->tag_enable)
create_atoms.cpp:  atom->nghost = 0;
create_atoms.cpp:  atom->avec->clear_bonus();
create_atoms.cpp:  bigint natoms_previous = atom->natoms;
create_atoms.cpp:  int nlocal_previous = atom->nlocal;
create_atoms.cpp:  atom->data_fix_compute_variable(nlocal_previous,atom->nlocal);
create_atoms.cpp:  bigint nblocal = atom->nlocal;
create_atoms.cpp:  MPI_Allreduce(&nblocal,&atom->natoms,1,MPI_LMP_BIGINT,MPI_SUM,world);
create_atoms.cpp:  if (atom->natoms < 0 || atom->natoms >= MAXBIGINT)
create_atoms.cpp:  if (atom->tag_enable) atom->tag_extend();
create_atoms.cpp:  atom->tag_check();
create_atoms.cpp:  if (atom->map_style != Atom::MAP_NONE) {
create_atoms.cpp:    atom->map_init();
create_atoms.cpp:    atom->map_set();
create_atoms.cpp:  // set molecule IDs for created atoms if atom->molecule_flag is set
create_atoms.cpp:    int molecule_flag = atom->molecule_flag;
create_atoms.cpp:    int molecular = atom->molecular;
create_atoms.cpp:    tagint *molecule = atom->molecule;
create_atoms.cpp:    tagint molcreate = (atom->nlocal - nlocal_previous) / onemol->natoms;
create_atoms.cpp:    atom->nbonds += nmoltotal * onemol->nbonds;
create_atoms.cpp:    atom->nangles += nmoltotal * onemol->nangles;
create_atoms.cpp:    atom->ndihedrals += nmoltotal * onemol->ndihedrals;
create_atoms.cpp:    atom->nimpropers += nmoltotal * onemol->nimpropers;
create_atoms.cpp:    tagint *tag = atom->tag;
create_atoms.cpp:    int *num_bond = atom->num_bond;
create_atoms.cpp:    int *num_angle = atom->num_angle;
create_atoms.cpp:    int *num_dihedral = atom->num_dihedral;
create_atoms.cpp:    int *num_improper = atom->num_improper;
create_atoms.cpp:    tagint **bond_atom = atom->bond_atom;
create_atoms.cpp:    tagint **angle_atom1 = atom->angle_atom1;
create_atoms.cpp:    tagint **angle_atom2 = atom->angle_atom2;
create_atoms.cpp:    tagint **angle_atom3 = atom->angle_atom3;
create_atoms.cpp:    tagint **dihedral_atom1 = atom->dihedral_atom1;
create_atoms.cpp:    tagint **dihedral_atom2 = atom->dihedral_atom2;
create_atoms.cpp:    tagint **dihedral_atom3 = atom->dihedral_atom3;
create_atoms.cpp:    tagint **dihedral_atom4 = atom->dihedral_atom4;
create_atoms.cpp:    tagint **improper_atom1 = atom->improper_atom1;
create_atoms.cpp:    tagint **improper_atom2 = atom->improper_atom2;
create_atoms.cpp:    tagint **improper_atom3 = atom->improper_atom3;
create_atoms.cpp:    tagint **improper_atom4 = atom->improper_atom4;
create_atoms.cpp:    int **nspecial = atom->nspecial;
create_atoms.cpp:    tagint **special = atom->special;
create_atoms.cpp:          atom->molindex[ilocal] = 0;
create_atoms.cpp:          atom->molatom[ilocal] = m;
create_atoms.cpp:    double **x = atom->x;
create_atoms.cpp:    imageint *image = atom->image;
create_atoms.cpp:    int nlocal = atom->nlocal;
create_atoms.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
create_atoms.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal);
create_atoms.cpp:    if (atom->molecular == Atom::MOLECULAR && onemol->bondflag && !onemol->specialflag) {
create_atoms.cpp:    utils::logmesg(lmp,"Created {} atoms\n", atom->natoms - natoms_previous);
create_atoms.cpp:    if (mode == ATOM) atom->avec->create_atom(ntype,xone);
create_atoms.cpp:      if (mode == ATOM) atom->avec->create_atom(ntype,xone);
create_atoms.cpp:  bigint nbig = atom->avec->roundup(nadd + atom->nlocal);
create_atoms.cpp:  atom->avec->grow(n);
create_atoms.cpp:            if (mode == ATOM) atom->avec->create_atom(basistype[m],x);
create_atoms.cpp:            if (mode == ATOM) atom->avec->create_atom(basistype[m],x);
create_atoms.cpp:    atom->avec->create_atom(ntype+onemol->type[m],xnew);
create_atoms.cpp:    n = atom->nlocal - 1;
create_atoms.cpp:    atom->add_molecule_atom(onemol,m,n,0);
create_bonds.cpp:  if (atom->tag_enable == 0)
create_bonds.cpp:  if (atom->molecular != Atom::MOLECULAR)
create_bonds.cpp:    if (btype <= 0 || btype > atom->nbondtypes)
create_bonds.cpp:    if (btype <= 0 || btype > atom->nbondtypes)
create_bonds.cpp:    if (atype <= 0 || atype > atom->nangletypes)
create_bonds.cpp:    if (dtype <= 0 || dtype > atom->ndihedraltypes)
create_bonds.cpp:    if (dtype <= 0 || dtype > atom->nimpropertypes)
create_bonds.cpp:  bigint nbonds_previous = atom->nbonds;
create_bonds.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
create_bonds.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
create_bonds.cpp:  tagint *tag = atom->tag;
create_bonds.cpp:  int *mask = atom->mask;
create_bonds.cpp:  double **x = atom->x;
create_bonds.cpp:  int *num_bond = atom->num_bond;
create_bonds.cpp:  int **bond_type = atom->bond_type;
create_bonds.cpp:  tagint **bond_atom = atom->bond_atom;
create_bonds.cpp:  int nlocal = atom->nlocal;
create_bonds.cpp:        if (num_bond[i] == atom->bond_per_atom)
create_bonds.cpp:                                       " of {} in create_bonds",atom->bond_per_atom);
create_bonds.cpp:  MPI_Allreduce(&nbonds,&atom->nbonds,1,MPI_LMP_BIGINT,MPI_SUM,world);
create_bonds.cpp:  if (!force->newton_bond) atom->nbonds /= 2;
create_bonds.cpp:  bigint nadd_bonds = atom->nbonds - nbonds_previous;
create_bonds.cpp:                   nadd_bonds,atom->nbonds);
create_bonds.cpp:  const int nlocal = atom->nlocal;
create_bonds.cpp:  const int idx1 = atom->map(batom1);
create_bonds.cpp:  const int idx2 = atom->map(batom2);
create_bonds.cpp:  int *num_bond = atom->num_bond;
create_bonds.cpp:  int **bond_type = atom->bond_type;
create_bonds.cpp:  tagint **bond_atom = atom->bond_atom;
create_bonds.cpp:    if (num_bond[m] == atom->bond_per_atom)
create_bonds.cpp:  atom->nbonds++;
create_bonds.cpp:    if (num_bond[m] == atom->bond_per_atom)
create_bonds.cpp:  const int nlocal = atom->nlocal;
create_bonds.cpp:  const int idx1 = atom->map(aatom1);
create_bonds.cpp:  const int idx2 = atom->map(aatom2);
create_bonds.cpp:  const int idx3 = atom->map(aatom3);
create_bonds.cpp:  int *num_angle = atom->num_angle;
create_bonds.cpp:  int **angle_type = atom->angle_type;
create_bonds.cpp:  tagint **angle_atom1 = atom->angle_atom1;
create_bonds.cpp:  tagint **angle_atom2 = atom->angle_atom2;
create_bonds.cpp:  tagint **angle_atom3 = atom->angle_atom3;
create_bonds.cpp:    if (num_angle[m] == atom->angle_per_atom)
create_bonds.cpp:  atom->nangles++;
create_bonds.cpp:    if (num_angle[m] == atom->angle_per_atom)
create_bonds.cpp:    if (num_angle[m] == atom->angle_per_atom)
create_bonds.cpp:  const int nlocal = atom->nlocal;
create_bonds.cpp:  const int idx1 = atom->map(datom1);
create_bonds.cpp:  const int idx2 = atom->map(datom2);
create_bonds.cpp:  const int idx3 = atom->map(datom3);
create_bonds.cpp:  const int idx4 = atom->map(datom4);
create_bonds.cpp:  int *num_dihedral = atom->num_dihedral;
create_bonds.cpp:  int **dihedral_type = atom->dihedral_type;
create_bonds.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
create_bonds.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
create_bonds.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
create_bonds.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
create_bonds.cpp:    if (num_dihedral[m] == atom->dihedral_per_atom)
create_bonds.cpp:  atom->ndihedrals++;
create_bonds.cpp:    if (num_dihedral[m] == atom->dihedral_per_atom)
create_bonds.cpp:    if (num_dihedral[m] == atom->dihedral_per_atom)
create_bonds.cpp:    if (num_dihedral[m] == atom->dihedral_per_atom)
create_bonds.cpp:  const int nlocal = atom->nlocal;
create_bonds.cpp:  const int idx1 = atom->map(datom1);
create_bonds.cpp:  const int idx2 = atom->map(datom2);
create_bonds.cpp:  const int idx3 = atom->map(datom3);
create_bonds.cpp:  const int idx4 = atom->map(datom4);
create_bonds.cpp:  int *num_improper = atom->num_improper;
create_bonds.cpp:  int **improper_type = atom->improper_type;
create_bonds.cpp:  tagint **improper_atom1 = atom->improper_atom1;
create_bonds.cpp:  tagint **improper_atom2 = atom->improper_atom2;
create_bonds.cpp:  tagint **improper_atom3 = atom->improper_atom3;
create_bonds.cpp:  tagint **improper_atom4 = atom->improper_atom4;
create_bonds.cpp:    if (num_improper[m] == atom->improper_per_atom)
create_bonds.cpp:  atom->nimpropers++;
create_bonds.cpp:    if (num_improper[m] == atom->improper_per_atom)
create_bonds.cpp:    if (num_improper[m] == atom->improper_per_atom)
create_bonds.cpp:    if (num_improper[m] == atom->improper_per_atom)
create_box.cpp:  if (atom->molecular != Atom::ATOMIC) {
create_box.cpp:    atom->bond_per_atom = 0;
create_box.cpp:    atom->angle_per_atom = 0;
create_box.cpp:    atom->dihedral_per_atom = 0;
create_box.cpp:    atom->improper_per_atom = 0;
create_box.cpp:    atom->nbonds = 0;
create_box.cpp:    atom->nangles = 0;
create_box.cpp:    atom->ndihedrals = 0;
create_box.cpp:    atom->nimpropers = 0;
create_box.cpp:  atom->ntypes = utils::inumeric(FLERR,arg[0],false,lmp);
create_box.cpp:  atom->nbondtypes = 0;
create_box.cpp:  atom->nangletypes = 0;
create_box.cpp:  atom->ndihedraltypes = 0;
create_box.cpp:  atom->nimpropertypes = 0;
create_box.cpp:      if (!atom->avec->bonds_allow)
create_box.cpp:      atom->nbondtypes = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      if (!atom->avec->angles_allow)
create_box.cpp:      atom->nangletypes = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      if (!atom->avec->dihedrals_allow)
create_box.cpp:      atom->ndihedraltypes = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      if (!atom->avec->impropers_allow)
create_box.cpp:      atom->nimpropertypes = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      if (!atom->avec->bonds_allow)
create_box.cpp:      atom->bond_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      if (!atom->avec->angles_allow)
create_box.cpp:      atom->angle_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      if (!atom->avec->dihedrals_allow)
create_box.cpp:      atom->dihedral_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      if (!atom->avec->impropers_allow)
create_box.cpp:      atom->improper_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
create_box.cpp:      atom->maxspecial += force->special_extra;
create_box.cpp:  atom->allocate_type_arrays();
create_box.cpp:  atom->deallocate_topology();
create_box.cpp:  atom->avec->grow(1);
delete_atoms.cpp:  if (atom->tag_enable == 0)
delete_atoms.cpp:  bigint natoms_previous = atom->natoms;
delete_atoms.cpp:  bigint nbonds_previous = atom->nbonds;
delete_atoms.cpp:  bigint nangles_previous = atom->nangles;
delete_atoms.cpp:  bigint ndihedrals_previous = atom->ndihedrals;
delete_atoms.cpp:  bigint nimpropers_previous = atom->nimpropers;
delete_atoms.cpp:  // if allflag = 1, just reset atom->nlocal
delete_atoms.cpp:  if (allflag) atom->nlocal = 0;
delete_atoms.cpp:    AtomVec *avec = atom->avec;
delete_atoms.cpp:    int nlocal = atom->nlocal;
delete_atoms.cpp:    atom->nlocal = nlocal;
delete_atoms.cpp:    if (atom->molecular == Atom::ATOMIC) {
delete_atoms.cpp:      tagint *tag = atom->tag;
delete_atoms.cpp:      int nlocal = atom->nlocal;
delete_atoms.cpp:      atom->tag_extend();
delete_atoms.cpp:  // reset atom->natoms and also topology counts
delete_atoms.cpp:  bigint nblocal = atom->nlocal;
delete_atoms.cpp:  MPI_Allreduce(&nblocal,&atom->natoms,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:    (AtomVecEllipsoid *) atom->style_match("ellipsoid");
delete_atoms.cpp:  AtomVecLine *avec_line = (AtomVecLine *) atom->style_match("line");
delete_atoms.cpp:  AtomVecTri *avec_tri = (AtomVecTri *) atom->style_match("tri");
delete_atoms.cpp:  AtomVecBody *avec_body = (AtomVecBody *) atom->style_match("body");
delete_atoms.cpp:  if (atom->nellipsoids > 0) {
delete_atoms.cpp:    MPI_Allreduce(&nlocal_bonus,&atom->nellipsoids,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:  if (atom->nlines > 0) {
delete_atoms.cpp:    MPI_Allreduce(&nlocal_bonus,&atom->nlines,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:  if (atom->ntris > 0) {
delete_atoms.cpp:    MPI_Allreduce(&nlocal_bonus,&atom->ntris,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:  if (atom->nbodies > 0) {
delete_atoms.cpp:    MPI_Allreduce(&nlocal_bonus,&atom->nbodies,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:  // reset atom->map if it exists
delete_atoms.cpp:  if (atom->map_style != Atom::MAP_NONE) {
delete_atoms.cpp:    atom->nghost = 0;
delete_atoms.cpp:    atom->map_init();
delete_atoms.cpp:    atom->map_set();
delete_atoms.cpp:  bigint ndelete = natoms_previous - atom->natoms;
delete_atoms.cpp:  bigint ndelete_bonds = nbonds_previous - atom->nbonds;
delete_atoms.cpp:  bigint ndelete_angles = nangles_previous - atom->nangles;
delete_atoms.cpp:  bigint ndelete_dihedrals = ndihedrals_previous - atom->ndihedrals;
delete_atoms.cpp:  bigint ndelete_impropers = nimpropers_previous - atom->nimpropers;
delete_atoms.cpp:                                   ndelete,atom->natoms);
delete_atoms.cpp:                            ndelete_bonds,atom->nbonds);
delete_atoms.cpp:                            ndelete_angles,atom->nangles);
delete_atoms.cpp:                            ndelete_dihedrals,atom->ndihedrals);
delete_atoms.cpp:                            ndelete_impropers,atom->nimpropers);
delete_atoms.cpp:  int nlocal = atom->nlocal;
delete_atoms.cpp:  int *mask = atom->mask;
delete_atoms.cpp:  int nlocal = atom->nlocal;
delete_atoms.cpp:  double **x = atom->x;
delete_atoms.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
delete_atoms.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
delete_atoms.cpp:  int nlocal = atom->nlocal;
delete_atoms.cpp:  tagint *tag = atom->tag;
delete_atoms.cpp:  int *mask = atom->mask;
delete_atoms.cpp:  double **x = atom->x;
delete_atoms.cpp:  int nlocal = atom->nlocal;
delete_atoms.cpp:  double **x = atom->x;
delete_atoms.cpp:  tagint *tag = atom->tag;
delete_atoms.cpp:  int nlocal = atom->nlocal;
delete_atoms.cpp:  tagint *molecule = atom->molecule;
delete_atoms.cpp:  int nlocal = atom->nlocal;
delete_atoms.cpp:   different for atom->molecular = Atom::MOLECULAR or Atom::TEMPLATE
delete_atoms.cpp:  if (atom->molecular == Atom::MOLECULAR) {
delete_atoms.cpp:    int *num_bond = atom->num_bond;
delete_atoms.cpp:    int *num_angle = atom->num_angle;
delete_atoms.cpp:    int *num_dihedral = atom->num_dihedral;
delete_atoms.cpp:    int *num_improper = atom->num_improper;
delete_atoms.cpp:    int nlocal = atom->nlocal;
delete_atoms.cpp:  } else if (atom->molecular == Atom::TEMPLATE) {
delete_atoms.cpp:    Molecule **onemols = atom->avec->onemols;
delete_atoms.cpp:    int *molindex = atom->molindex;
delete_atoms.cpp:    int *molatom = atom->molatom;
delete_atoms.cpp:    int nlocal = atom->nlocal;
delete_atoms.cpp:  if (atom->avec->bonds_allow) {
delete_atoms.cpp:    MPI_Allreduce(&nbonds,&atom->nbonds,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:    if (!force->newton_bond) atom->nbonds /= 2;
delete_atoms.cpp:  if (atom->avec->angles_allow) {
delete_atoms.cpp:    MPI_Allreduce(&nangles,&atom->nangles,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:    if (!force->newton_bond) atom->nangles /= 3;
delete_atoms.cpp:  if (atom->avec->dihedrals_allow) {
delete_atoms.cpp:    MPI_Allreduce(&ndihedrals,&atom->ndihedrals,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:    if (!force->newton_bond) atom->ndihedrals /= 4;
delete_atoms.cpp:  if (atom->avec->impropers_allow) {
delete_atoms.cpp:    MPI_Allreduce(&nimpropers,&atom->nimpropers,1,MPI_LMP_BIGINT,MPI_SUM,world);
delete_atoms.cpp:    if (!force->newton_bond) atom->nimpropers /= 4;
delete_atoms.cpp:  int *num_bond = daptr->atom->num_bond;
delete_atoms.cpp:  int *num_angle = daptr->atom->num_angle;
delete_atoms.cpp:  int *num_dihedral = daptr->atom->num_dihedral;
delete_atoms.cpp:  int *num_improper = daptr->atom->num_improper;
delete_atoms.cpp:  int **bond_type = daptr->atom->bond_type;
delete_atoms.cpp:  tagint **bond_atom = daptr->atom->bond_atom;
delete_atoms.cpp:  int **angle_type = daptr->atom->angle_type;
delete_atoms.cpp:  tagint **angle_atom1 = daptr->atom->angle_atom1;
delete_atoms.cpp:  tagint **angle_atom2 = daptr->atom->angle_atom2;
delete_atoms.cpp:  tagint **angle_atom3 = daptr->atom->angle_atom3;
delete_atoms.cpp:  int **dihedral_type = daptr->atom->dihedral_type;
delete_atoms.cpp:  tagint **dihedral_atom1 = daptr->atom->dihedral_atom1;
delete_atoms.cpp:  tagint **dihedral_atom2 = daptr->atom->dihedral_atom2;
delete_atoms.cpp:  tagint **dihedral_atom3 = daptr->atom->dihedral_atom3;
delete_atoms.cpp:  tagint **dihedral_atom4 = daptr->atom->dihedral_atom4;
delete_atoms.cpp:  int **improper_type = daptr->atom->improper_type;
delete_atoms.cpp:  tagint **improper_atom1 = daptr->atom->improper_atom1;
delete_atoms.cpp:  tagint **improper_atom2 = daptr->atom->improper_atom2;
delete_atoms.cpp:  tagint **improper_atom3 = daptr->atom->improper_atom3;
delete_atoms.cpp:  tagint **improper_atom4 = daptr->atom->improper_atom4;
delete_atoms.cpp:  int nlocal = daptr->atom->nlocal;
delete_atoms.cpp:  int nlocal = daptr->atom->nlocal;
delete_atoms.cpp:  tagint *molecule = daptr->atom->molecule;
delete_atoms.cpp:      if (atom->molecular == Atom::ATOMIC)
delete_atoms.cpp:      if (atom->molecular == Atom::TEMPLATE)
delete_atoms.cpp:      if (atom->molecule_flag == 0)
delete_bonds.cpp:  if (atom->natoms == 0)
delete_bonds.cpp:  if (atom->molecular != Atom::MOLECULAR)
delete_bonds.cpp:    if (style == ATOM) n = atom->ntypes;
delete_bonds.cpp:    if (style == BOND) n = atom->nbondtypes;
delete_bonds.cpp:    if (style == ANGLE) n = atom->nangletypes;
delete_bonds.cpp:    if (style == DIHEDRAL) n = atom->ndihedraltypes;
delete_bonds.cpp:    if (style == IMPROPER) n = atom->nimpropertypes;
delete_bonds.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
delete_bonds.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
delete_bonds.cpp:  int *mask = atom->mask;
delete_bonds.cpp:  int *type = atom->type;
delete_bonds.cpp:  int nlocal = atom->nlocal;
delete_bonds.cpp:  if (atom->avec->bonds_allow &&
delete_bonds.cpp:    int *num_bond = atom->num_bond;
delete_bonds.cpp:    int **bond_type = atom->bond_type;
delete_bonds.cpp:        atom1 = atom->map(atom->bond_atom[i][m]);
delete_bonds.cpp:  if (atom->avec->angles_allow &&
delete_bonds.cpp:    int *num_angle = atom->num_angle;
delete_bonds.cpp:    int **angle_type = atom->angle_type;
delete_bonds.cpp:        atom1 = atom->map(atom->angle_atom1[i][m]);
delete_bonds.cpp:        atom2 = atom->map(atom->angle_atom2[i][m]);
delete_bonds.cpp:        atom3 = atom->map(atom->angle_atom3[i][m]);
delete_bonds.cpp:  if (atom->avec->dihedrals_allow &&
delete_bonds.cpp:    int *num_dihedral = atom->num_dihedral;
delete_bonds.cpp:    int **dihedral_type = atom->dihedral_type;
delete_bonds.cpp:        atom1 = atom->map(atom->dihedral_atom1[i][m]);
delete_bonds.cpp:        atom2 = atom->map(atom->dihedral_atom2[i][m]);
delete_bonds.cpp:        atom3 = atom->map(atom->dihedral_atom3[i][m]);
delete_bonds.cpp:        atom4 = atom->map(atom->dihedral_atom4[i][m]);
delete_bonds.cpp:  if (atom->avec->impropers_allow &&
delete_bonds.cpp:    int *num_improper = atom->num_improper;
delete_bonds.cpp:    int **improper_type = atom->improper_type;
delete_bonds.cpp:        atom1 = atom->map(atom->improper_atom1[i][m]);
delete_bonds.cpp:        atom2 = atom->map(atom->improper_atom2[i][m]);
delete_bonds.cpp:        atom3 = atom->map(atom->improper_atom3[i][m]);
delete_bonds.cpp:        atom4 = atom->map(atom->improper_atom4[i][m]);
delete_bonds.cpp:    if (atom->avec->bonds_allow) {
delete_bonds.cpp:        while (m < atom->num_bond[i]) {
delete_bonds.cpp:          if (atom->bond_type[i][m] <= 0) {
delete_bonds.cpp:            atom1 = atom->map(atom->bond_atom[i][m]);
delete_bonds.cpp:              n = atom->num_bond[i];
delete_bonds.cpp:              atom->bond_type[i][m] = atom->bond_type[i][n-1];
delete_bonds.cpp:              atom->bond_atom[i][m] = atom->bond_atom[i][n-1];
delete_bonds.cpp:              atom->num_bond[i]--;
delete_bonds.cpp:    if (atom->avec->angles_allow) {
delete_bonds.cpp:        while (m < atom->num_angle[i]) {
delete_bonds.cpp:          if (atom->angle_type[i][m] <= 0) {
delete_bonds.cpp:            atom1 = atom->map(atom->angle_atom1[i][m]);
delete_bonds.cpp:            atom2 = atom->map(atom->angle_atom2[i][m]);
delete_bonds.cpp:            atom3 = atom->map(atom->angle_atom3[i][m]);
delete_bonds.cpp:              n = atom->num_angle[i];
delete_bonds.cpp:              atom->angle_type[i][m] = atom->angle_type[i][n-1];
delete_bonds.cpp:              atom->angle_atom1[i][m] = atom->angle_atom1[i][n-1];
delete_bonds.cpp:              atom->angle_atom2[i][m] = atom->angle_atom2[i][n-1];
delete_bonds.cpp:              atom->angle_atom3[i][m] = atom->angle_atom3[i][n-1];
delete_bonds.cpp:              atom->num_angle[i]--;
delete_bonds.cpp:    if (atom->avec->dihedrals_allow) {
delete_bonds.cpp:        while (m < atom->num_dihedral[i]) {
delete_bonds.cpp:          if (atom->dihedral_type[i][m] <= 0) {
delete_bonds.cpp:            atom1 = atom->map(atom->dihedral_atom1[i][m]);
delete_bonds.cpp:            atom2 = atom->map(atom->dihedral_atom2[i][m]);
delete_bonds.cpp:            atom3 = atom->map(atom->dihedral_atom3[i][m]);
delete_bonds.cpp:            atom4 = atom->map(atom->dihedral_atom4[i][m]);
delete_bonds.cpp:              n = atom->num_dihedral[i];
delete_bonds.cpp:              atom->dihedral_type[i][m] = atom->dihedral_type[i][n-1];
delete_bonds.cpp:              atom->dihedral_atom1[i][m] = atom->dihedral_atom1[i][n-1];
delete_bonds.cpp:              atom->dihedral_atom2[i][m] = atom->dihedral_atom2[i][n-1];
delete_bonds.cpp:              atom->dihedral_atom3[i][m] = atom->dihedral_atom3[i][n-1];
delete_bonds.cpp:              atom->dihedral_atom4[i][m] = atom->dihedral_atom4[i][n-1];
delete_bonds.cpp:              atom->num_dihedral[i]--;
delete_bonds.cpp:    if (atom->avec->impropers_allow) {
delete_bonds.cpp:        while (m < atom->num_improper[i]) {
delete_bonds.cpp:          if (atom->improper_type[i][m] <= 0) {
delete_bonds.cpp:            atom1 = atom->map(atom->improper_atom1[i][m]);
delete_bonds.cpp:            atom2 = atom->map(atom->improper_atom2[i][m]);
delete_bonds.cpp:            atom3 = atom->map(atom->improper_atom3[i][m]);
delete_bonds.cpp:            atom4 = atom->map(atom->improper_atom4[i][m]);
delete_bonds.cpp:              n = atom->num_improper[i];
delete_bonds.cpp:              atom->improper_type[i][m] = atom->improper_type[i][n-1];
delete_bonds.cpp:              atom->improper_atom1[i][m] = atom->improper_atom1[i][n-1];
delete_bonds.cpp:              atom->improper_atom2[i][m] = atom->improper_atom2[i][n-1];
delete_bonds.cpp:              atom->improper_atom3[i][m] = atom->improper_atom3[i][n-1];
delete_bonds.cpp:              atom->improper_atom4[i][m] = atom->improper_atom4[i][n-1];
delete_bonds.cpp:              atom->num_improper[i]--;
delete_bonds.cpp:    if (atom->avec->bonds_allow) {
delete_bonds.cpp:      for (i = 0; i < nlocal; i++) nbonds += atom->num_bond[i];
delete_bonds.cpp:      MPI_Allreduce(&nbonds,&atom->nbonds,1,MPI_LMP_BIGINT,
delete_bonds.cpp:      if (force->newton_bond == 0) atom->nbonds /= 2;
delete_bonds.cpp:    if (atom->avec->angles_allow) {
delete_bonds.cpp:      for (i = 0; i < nlocal; i++) nangles += atom->num_angle[i];
delete_bonds.cpp:      MPI_Allreduce(&nangles,&atom->nangles,1,MPI_LMP_BIGINT,
delete_bonds.cpp:      if (force->newton_bond == 0) atom->nangles /= 3;
delete_bonds.cpp:    if (atom->avec->dihedrals_allow) {
delete_bonds.cpp:      for (i = 0; i < nlocal; i++) ndihedrals += atom->num_dihedral[i];
delete_bonds.cpp:      MPI_Allreduce(&ndihedrals,&atom->ndihedrals,
delete_bonds.cpp:      if (force->newton_bond == 0) atom->ndihedrals /= 4;
delete_bonds.cpp:    if (atom->avec->impropers_allow) {
delete_bonds.cpp:      for (i = 0; i < nlocal; i++) nimpropers += atom->num_improper[i];
delete_bonds.cpp:      MPI_Allreduce(&nimpropers,&atom->nimpropers,
delete_bonds.cpp:      if (force->newton_bond == 0) atom->nimpropers /= 4;
delete_bonds.cpp:  if (atom->avec->bonds_allow) {
delete_bonds.cpp:      for (m = 0; m < atom->num_bond[i]; m++)
delete_bonds.cpp:        if (atom->bond_type[i][m] > 0) bond_on++;
delete_bonds.cpp:  if (atom->avec->angles_allow) {
delete_bonds.cpp:      for (m = 0; m < atom->num_angle[i]; m++)
delete_bonds.cpp:        if (atom->angle_type[i][m] > 0) angle_on++;
delete_bonds.cpp:  if (atom->avec->dihedrals_allow) {
delete_bonds.cpp:      for (m = 0; m < atom->num_dihedral[i]; m++)
delete_bonds.cpp:        if (atom->dihedral_type[i][m] > 0) dihedral_on++;
delete_bonds.cpp:  if (atom->avec->impropers_allow) {
delete_bonds.cpp:      for (m = 0; m < atom->num_improper[i]; m++)
delete_bonds.cpp:        if (atom->improper_type[i][m] > 0) improper_on++;
delete_bonds.cpp:    if (atom->avec->bonds_allow)
delete_bonds.cpp:                     atom->nbonds,bond_on,bond_off);
delete_bonds.cpp:    if (atom->avec->angles_allow)
delete_bonds.cpp:                     atom->nangles,angle_on,angle_off);
delete_bonds.cpp:    if (atom->avec->dihedrals_allow)
delete_bonds.cpp:                     atom->ndihedrals,dihedral_on,dihedral_off);
delete_bonds.cpp:    if (atom->avec->impropers_allow)
delete_bonds.cpp:                     atom->nimpropers,improper_on,improper_off);
dihedral.cpp:  if (!allocated && atom->ndihedraltypes)
dihedral.cpp:  for (int i = 1; i <= atom->ndihedraltypes; i++)
dihedral.cpp:  if (eflag_atom && atom->nmax > maxeatom) {
dihedral.cpp:    maxeatom = atom->nmax;
dihedral.cpp:  if (vflag_atom && atom->nmax > maxvatom) {
dihedral.cpp:    maxvatom = atom->nmax;
dihedral.cpp:  if (cvflag_atom && atom->nmax > maxcvatom) {
dihedral.cpp:    maxcvatom = atom->nmax;
dihedral.cpp:    n = atom->nlocal;
dihedral.cpp:    if (force->newton_bond) n += atom->nghost;
dihedral.cpp:    n = atom->nlocal;
dihedral.cpp:    if (force->newton_bond) n += atom->nghost;
dihedral.cpp:    n = atom->nlocal;
dihedral.cpp:    if (force->newton_bond) n += atom->nghost;
dihedral.cpp:  const auto x = atom->x;
dihedral.cpp:                          comm->me, update->ntimestep, atom->tag[i1],
dihedral.cpp:                          atom->tag[i2], atom->tag[i3], atom->tag[i4]);
dihedral_hybrid.cpp:    const bigint nall = atom->nlocal + atom->nghost;
dihedral_hybrid.cpp:      n = atom->nlocal;
dihedral_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
dihedral_hybrid.cpp:      n = atom->nlocal;
dihedral_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
dihedral_hybrid.cpp:      n = atom->nlocal;
dihedral_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
dihedral_hybrid.cpp:  int n = atom->ndihedraltypes;
dihedral_hybrid.cpp:  utils::bounds(FLERR, arg[0], 1, atom->ndihedraltypes, ilo, ihi, error);
dihedral_zero.cpp:  int n = atom->ndihedraltypes;
dihedral_zero.cpp:  utils::bounds(FLERR,arg[0],1,atom->ndihedraltypes,ilo,ihi,error);
dihedral_zero.cpp:  for (int i = 1; i <= atom->ndihedraltypes; i++) setflag[i] = 1;
dihedral_zero.cpp:  for (int i = 1; i <= atom->ndihedraltypes; i++)
displace_atoms.cpp:    double **x = atom->x;
displace_atoms.cpp:    int *mask = atom->mask;
displace_atoms.cpp:    int nlocal = atom->nlocal;
displace_atoms.cpp:    double **x = atom->x;
displace_atoms.cpp:    int *mask = atom->mask;
displace_atoms.cpp:    int nlocal = atom->nlocal;
displace_atoms.cpp:    int ellipsoid_flag = atom->ellipsoid_flag;
displace_atoms.cpp:    int line_flag = atom->line_flag;
displace_atoms.cpp:    int tri_flag = atom->tri_flag;
displace_atoms.cpp:    int body_flag = atom->body_flag;
displace_atoms.cpp:      (AtomVecEllipsoid *) atom->style_match("ellipsoid");
displace_atoms.cpp:    AtomVecLine *avec_line = (AtomVecLine *) atom->style_match("line");
displace_atoms.cpp:    AtomVecTri *avec_tri = (AtomVecTri *) atom->style_match("tri");
displace_atoms.cpp:    AtomVecBody *avec_body = (AtomVecBody *) atom->style_match("body");
displace_atoms.cpp:    double **x = atom->x;
displace_atoms.cpp:    int *ellipsoid = atom->ellipsoid;
displace_atoms.cpp:    int *line = atom->line;
displace_atoms.cpp:    int *tri = atom->tri;
displace_atoms.cpp:    int *body = atom->body;
displace_atoms.cpp:    int *mask = atom->mask;
displace_atoms.cpp:    int nlocal = atom->nlocal;
displace_atoms.cpp:    imageint *image = atom->image;
displace_atoms.cpp:          avec_line->bonus[atom->line[i]].theta = theta_new;
displace_atoms.cpp:  double **x = atom->x;
displace_atoms.cpp:  imageint *image = atom->image;
displace_atoms.cpp:  int nlocal = atom->nlocal;
displace_atoms.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
displace_atoms.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
displace_atoms.cpp:  bigint nblocal = atom->nlocal;
displace_atoms.cpp:  if (natoms != atom->natoms && comm->me == 0)
displace_atoms.cpp:                   "current {}",atom->natoms,natoms);
displace_atoms.cpp:  double **x = atom->x;
displace_atoms.cpp:  int *mask = atom->mask;
displace_atoms.cpp:  int nlocal = atom->nlocal;
domain.cpp:  if (atom->natoms == 0) return;
domain.cpp:    double **x = atom->x;
domain.cpp:    int nlocal = atom->nlocal;
domain.cpp:    if (triclinic) lamda2x(atom->nlocal);
domain.cpp:    x2lamda(atom->nlocal);
domain.cpp:  int nlocal = atom->nlocal;
domain.cpp:  double **x = atom->x;
domain.cpp:  double **v = atom->v;
domain.cpp:  int *mask = atom->mask;
domain.cpp:  imageint *image = atom->image;
domain.cpp:  if (atom->molecular == Atom::ATOMIC) return;
domain.cpp:  memory->create(unwrap,atom->nmax,3,"domain:unwrap");
domain.cpp:  double **x = atom->x;
domain.cpp:  imageint *image = atom->image;
domain.cpp:  int nlocal = atom->nlocal;
domain.cpp:  int molecular = atom->molecular;
domain.cpp:  int *num_bond = atom->num_bond;
domain.cpp:  tagint **bond_atom = atom->bond_atom;
domain.cpp:  int **bond_type = atom->bond_type;
domain.cpp:  tagint *tag = atom->tag;
domain.cpp:  int *molindex = atom->molindex;
domain.cpp:  int *molatom = atom->molatom;
domain.cpp:  Molecule **onemols = atom->avec->onemols;
domain.cpp:        k = atom->map(bond_atom[i][j]);
domain.cpp:        k = atom->map(onemols[imol]->bond_atom[iatom][j]+tagprev);
domain.cpp:  if (atom->molecular == Atom::ATOMIC) return;
domain.cpp:  int molecular = atom->molecular;
domain.cpp:  double **x = atom->x;
domain.cpp:  int *num_bond = atom->num_bond;
domain.cpp:  tagint **bond_atom = atom->bond_atom;
domain.cpp:  int **bond_type = atom->bond_type;
domain.cpp:  tagint *tag = atom->tag;
domain.cpp:  int *molindex = atom->molindex;
domain.cpp:  int *molatom = atom->molatom;
domain.cpp:  Molecule **onemols = atom->avec->onemols;
domain.cpp:  int nlocal = atom->nlocal;
domain.cpp:        k = atom->map(bond_atom[i][j]);
domain.cpp:        k = atom->map(onemols[imol]->bond_atom[iatom][j]+tagprev);
domain.cpp:  if (atom->nangles) maxdelta = 2.0 * maxbondall * BONDSTRETCH;
domain.cpp:  if (atom->ndihedrals) maxdelta = 3.0 * maxbondall * BONDSTRETCH;
domain.cpp:     far-away ghost atom returned by atom->map() to be wrapped back into box
domain.cpp:     far-away ghost atom returned by atom->map() to be wrapped back into box
domain.cpp:  int *sametag = atom->sametag;
domain.cpp:  double **x = atom->x;
domain.cpp:  const int * const sametag = atom->sametag;
domain.cpp:  const double * const * const x = atom->x;
domain.cpp:  imageint *image = atom->image;
domain.cpp:  int nlocal = atom->nlocal;
domain.cpp:    for (int i=0; i < atom->nlocal; ++i) {
domain.cpp:      int xbox = (atom->image[i] & IMGMASK) - IMGMAX;
domain.cpp:      int ybox = (atom->image[i] >> IMGBITS & IMGMASK) - IMGMAX;
domain.cpp:      int zbox = (atom->image[i] >> IMG2BITS) - IMGMAX;
domain.cpp:      atom->image[i] = ((imageint) (xbox + IMGMAX) & IMGMASK) |
domain.cpp:  double **x = atom->x;
domain.cpp:  double **x = atom->x;
dump_atom.cpp:  tagint *tag = atom->tag;
dump_atom.cpp:  int *type = atom->type;
dump_atom.cpp:  imageint *image = atom->image;
dump_atom.cpp:  int *mask = atom->mask;
dump_atom.cpp:  double **x = atom->x;
dump_atom.cpp:  int nlocal = atom->nlocal;
dump_atom.cpp:  tagint *tag = atom->tag;
dump_atom.cpp:  int *type = atom->type;
dump_atom.cpp:  int *mask = atom->mask;
dump_atom.cpp:  double **x = atom->x;
dump_atom.cpp:  int nlocal = atom->nlocal;
dump_atom.cpp:  tagint *tag = atom->tag;
dump_atom.cpp:  int *type = atom->type;
dump_atom.cpp:  imageint *image = atom->image;
dump_atom.cpp:  int *mask = atom->mask;
dump_atom.cpp:  double **x = atom->x;
dump_atom.cpp:  int nlocal = atom->nlocal;
dump_atom.cpp:  tagint *tag = atom->tag;
dump_atom.cpp:  int *type = atom->type;
dump_atom.cpp:  int *mask = atom->mask;
dump_atom.cpp:  double **x = atom->x;
dump_atom.cpp:  int nlocal = atom->nlocal;
dump_atom.cpp:  tagint *tag = atom->tag;
dump_atom.cpp:  int *type = atom->type;
dump_atom.cpp:  imageint *image = atom->image;
dump_atom.cpp:  int *mask = atom->mask;
dump_atom.cpp:  double **x = atom->x;
dump_atom.cpp:  int nlocal = atom->nlocal;
dump_atom.cpp:  tagint *tag = atom->tag;
dump_atom.cpp:  int *type = atom->type;
dump_atom.cpp:  int *mask = atom->mask;
dump_atom.cpp:  double **x = atom->x;
dump_atom.cpp:  int nlocal = atom->nlocal;
dump_cfg.cpp:  if (atom->peri_flag) scale = atom->pdscale;
dump.cpp:    if (sortcol == 0 && atom->tag_enable == 0)
dump.cpp:    if (sortcol == 0 && atom->tag_consecutive() && !gcmcflag) {
dump.cpp:      tagint *tag = atom->tag;
dump.cpp:      int *mask = atom->mask;
dump.cpp:      int nlocal = atom->nlocal;
dump.cpp:  if (pbcflag && atom->nlocal > maxpbc) pbc_allocate();
dump.cpp:  if (igroup == 0) return atom->nlocal;
dump.cpp:  int *mask = atom->mask;
dump.cpp:  int nlocal = atom->nlocal;
dump.cpp:    int nlocal = atom->nlocal;
dump.cpp:      memcpy(&xpbc[0][0],&atom->x[0][0],3*nlocal*sizeof(double));
dump.cpp:      memcpy(&vpbc[0][0],&atom->v[0][0],3*nlocal*sizeof(double));
dump.cpp:      memcpy(imagepbc,atom->image,nlocal*sizeof(imageint));
dump.cpp:    xhold = atom->x;
dump.cpp:    vhold = atom->v;
dump.cpp:    imagehold = atom->image;
dump.cpp:    atom->x = xpbc;
dump.cpp:    atom->v = vpbc;
dump.cpp:    atom->image = imagepbc;
dump.cpp:    atom->x = xhold;
dump.cpp:    atom->v = vhold;
dump.cpp:    atom->image = imagehold;
dump.cpp:  maxpbc = atom->nmax;
dump_custom.cpp:  ntypes = atom->ntypes;
dump_custom.cpp:    icustom = atom->find_custom(id_custom[i],flag,cols);
dump_custom.cpp:  const int nlocal = atom->nlocal;
dump_custom.cpp:  if (atom->nmax > maxlocal) {
dump_custom.cpp:    maxlocal = atom->nmax;
dump_custom.cpp:  // evaluate atom-style Variables for per-atom quantities
dump_custom.cpp:    int *mask = atom->mask;
dump_custom.cpp:    double **x = atom->x;
dump_custom.cpp:        tagint *tag = atom->tag;
dump_custom.cpp:        if (!atom->molecule_flag)
dump_custom.cpp:        tagint *molecule = atom->molecule;
dump_custom.cpp:        int *type = atom->type;
dump_custom.cpp:        int *type = atom->type;
dump_custom.cpp:        if (atom->rmass) {
dump_custom.cpp:          ptr = atom->rmass;
dump_custom.cpp:          double *mass = atom->mass;
dump_custom.cpp:          int *type = atom->type;
dump_custom.cpp:        ptr = &atom->x[0][0];
dump_custom.cpp:        ptr = &atom->x[0][1];
dump_custom.cpp:        ptr = &atom->x[0][2];
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        double **x = atom->x;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        imageint *image = atom->image;
dump_custom.cpp:        ptr = &atom->v[0][0];
dump_custom.cpp:        ptr = &atom->v[0][1];
dump_custom.cpp:        ptr = &atom->v[0][2];
dump_custom.cpp:        ptr = &atom->f[0][0];
dump_custom.cpp:        ptr = &atom->f[0][1];
dump_custom.cpp:        ptr = &atom->f[0][2];
dump_custom.cpp:        if (!atom->q_flag)
dump_custom.cpp:        ptr = atom->q;
dump_custom.cpp:        if (!atom->mu_flag)
dump_custom.cpp:        ptr = &atom->mu[0][0];
dump_custom.cpp:        if (!atom->mu_flag)
dump_custom.cpp:        ptr = &atom->mu[0][1];
dump_custom.cpp:        if (!atom->mu_flag)
dump_custom.cpp:        ptr = &atom->mu[0][2];
dump_custom.cpp:        if (!atom->mu_flag)
dump_custom.cpp:        ptr = &atom->mu[0][3];
dump_custom.cpp:        ptr = &atom->af[0];
dump_custom.cpp:        if (!atom->radius_flag)
dump_custom.cpp:        ptr = atom->radius;
dump_custom.cpp:        if (!atom->radius_flag)
dump_custom.cpp:        double *radius = atom->radius;
dump_custom.cpp:        if (!atom->omega_flag)
dump_custom.cpp:        ptr = &atom->omega[0][0];
dump_custom.cpp:        if (!atom->omega_flag)
dump_custom.cpp:        ptr = &atom->omega[0][1];
dump_custom.cpp:        if (!atom->omega_flag)
dump_custom.cpp:        ptr = &atom->omega[0][2];
dump_custom.cpp:        if (!atom->angmom_flag)
dump_custom.cpp:        ptr = &atom->angmom[0][0];
dump_custom.cpp:        if (!atom->angmom_flag)
dump_custom.cpp:        ptr = &atom->angmom[0][1];
dump_custom.cpp:        if (!atom->angmom_flag)
dump_custom.cpp:        ptr = &atom->angmom[0][2];
dump_custom.cpp:        if (!atom->torque_flag)
dump_custom.cpp:        ptr = &atom->torque[0][0];
dump_custom.cpp:        if (!atom->torque_flag)
dump_custom.cpp:        ptr = &atom->torque[0][1];
dump_custom.cpp:        if (!atom->torque_flag)
dump_custom.cpp:        ptr = &atom->torque[0][2];
dump_custom.cpp:        int *ivector = atom->ivector[iwhich];
dump_custom.cpp:        ptr = atom->dvector[iwhich];
dump_custom.cpp:        int **iarray = atom->iarray[iwhich];
dump_custom.cpp:        double **darray = atom->darray[iwhich];
dump_custom.cpp:        nstride = atom->dcols[iwhich];
dump_custom.cpp:    tagint *tag = atom->tag;
dump_custom.cpp:      if (!atom->molecule_flag)
dump_custom.cpp:      if (!atom->q_flag)
dump_custom.cpp:      if (!atom->mu_flag)
dump_custom.cpp:      if (!atom->mu_flag)
dump_custom.cpp:      if (!atom->mu_flag)
dump_custom.cpp:      if (!atom->mu_flag)
dump_custom.cpp:      if (!atom->radius_flag)
dump_custom.cpp:      if (!atom->radius_flag)
dump_custom.cpp:      if (!atom->omega_flag)
dump_custom.cpp:      if (!atom->omega_flag)
dump_custom.cpp:      if (!atom->omega_flag)
dump_custom.cpp:      if (!atom->angmom_flag)
dump_custom.cpp:      if (!atom->angmom_flag)
dump_custom.cpp:      if (!atom->angmom_flag)
dump_custom.cpp:      if (!atom->torque_flag)
dump_custom.cpp:      if (!atom->torque_flag)
dump_custom.cpp:      if (!atom->torque_flag)
dump_custom.cpp:          error->all(FLERR,"Dump custom variable {} is not atom-style variable",name);
dump_custom.cpp:        n = atom->find_custom(name,flag,cols);
dump_custom.cpp:          if (argindex[iarg] > atom->dcols[n])
dump_custom.cpp:        n = atom->find_custom(name,flag,cols);
dump_custom.cpp:          if (argindex[iarg] > atom->icols[n])
dump_custom.cpp:          error->all(FLERR,"Dump modify variable {} is not atom-style variable",name);
dump_custom.cpp:        n = atom->find_custom(name,flag,cols);
dump_custom.cpp:          if (argindex[nfield+nthresh] > atom->dcols[n])
dump_custom.cpp:        n = atom->find_custom(name,flag,cols);
dump_custom.cpp:          if (argindex[nfield+nthresh] > atom->icols[n])
dump_custom.cpp:    int *ivector = atom->ivector[iwhich];
dump_custom.cpp:    double *dvector = atom->dvector[iwhich];
dump_custom.cpp:    int **iarray = atom->iarray[iwhich];
dump_custom.cpp:    double **darray = atom->darray[iwhich];
dump_custom.cpp:  tagint *tag = atom->tag;
dump_custom.cpp:  tagint *molecule = atom->molecule;
dump_custom.cpp:  int *type = atom->type;
dump_custom.cpp:  int *type = atom->type;
dump_custom.cpp:  double *mass = atom->mass;
dump_custom.cpp:  double *rmass = atom->rmass;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **x = atom->x;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  imageint *image = atom->image;
dump_custom.cpp:  double **v = atom->v;
dump_custom.cpp:  double **v = atom->v;
dump_custom.cpp:  double **v = atom->v;
dump_custom.cpp:  double **f = atom->f;
dump_custom.cpp:  double **f = atom->f;
dump_custom.cpp:  double **f = atom->f;
dump_custom.cpp:  double *q = atom->q;
dump_custom.cpp:  double **mu = atom->mu;
dump_custom.cpp:  double **mu = atom->mu;
dump_custom.cpp:  double **mu = atom->mu;
dump_custom.cpp:  double **mu = atom->mu;
dump_custom.cpp:  double *af = atom->af;
dump_custom.cpp:  double *radius = atom->radius;
dump_custom.cpp:  double *radius = atom->radius;
dump_custom.cpp:  double **omega = atom->omega;
dump_custom.cpp:  double **omega = atom->omega;
dump_custom.cpp:  double **omega = atom->omega;
dump_custom.cpp:  double **angmom = atom->angmom;
dump_custom.cpp:  double **angmom = atom->angmom;
dump_custom.cpp:  double **angmom = atom->angmom;
dump_custom.cpp:  double **torque = atom->torque;
dump_custom.cpp:  double **torque = atom->torque;
dump_custom.cpp:  double **torque = atom->torque;
dump_image.cpp:  if (atom->nbondtypes == 0) bondflag = NO;
dump_image.cpp:      if (atom->nbondtypes == 0)
dump_image.cpp:    avec_line = (AtomVecLine *) atom->style_match("line");
dump_image.cpp:    avec_tri = (AtomVecTri *) atom->style_match("tri");
dump_image.cpp:    avec_body = (AtomVecBody *) atom->style_match("body");
dump_image.cpp:    bdiamtype = new double[atom->nbondtypes+1];
dump_image.cpp:    bcolortype = new double*[atom->nbondtypes+1];
dump_image.cpp:    for (int i = 1; i <= atom->nbondtypes; i++) {
dump_image.cpp:    double **x = atom->x;
dump_image.cpp:    int *line = atom->line;
dump_image.cpp:    int *tri = atom->tri;
dump_image.cpp:    int *body = atom->body;
dump_image.cpp:    double **x = atom->x;
dump_image.cpp:    int *line = atom->line;
dump_image.cpp:    int *type = atom->type;
dump_image.cpp:    double **x = atom->x;
dump_image.cpp:    int *tri = atom->tri;
dump_image.cpp:    int *type = atom->type;
dump_image.cpp:    int *body = atom->body;
dump_image.cpp:    double **x = atom->x;
dump_image.cpp:    tagint *tag = atom->tag;
dump_image.cpp:    tagint **bond_atom = atom->bond_atom;
dump_image.cpp:    int **bond_type = atom->bond_type;
dump_image.cpp:    int *num_bond = atom->num_bond;
dump_image.cpp:    int *molindex = atom->molindex;
dump_image.cpp:    int *molatom = atom->molatom;
dump_image.cpp:    int *type = atom->type;
dump_image.cpp:    int nlocal = atom->nlocal;
dump_image.cpp:    int molecular = atom->molecular;
dump_image.cpp:    Molecule **onemols = atom->avec->onemols;
dump_image.cpp:    if (atom->nmax > maxbufcopy) {
dump_image.cpp:      maxbufcopy = atom->nmax;
dump_image.cpp:          atom2 = atom->map(bond_atom[atom1][m]);
dump_image.cpp:          btype = atom->map(onemols[imol]->bond_type[iatom][m]);
dump_image.cpp:          atom2 = atom->map(onemols[imol]->bond_atom[iatom][m]+tagprev);
dump_image.cpp:    utils::bounds(FLERR,arg[1],1,atom->ntypes,nlo,nhi,error);
dump_image.cpp:    utils::bounds(FLERR,arg[1],1,atom->ntypes,nlo,nhi,error);
dump_image.cpp:    if (atom->nbondtypes == 0)
dump_image.cpp:    utils::bounds(FLERR,arg[1],1,atom->nbondtypes,nlo,nhi,error);
dump_image.cpp:    if (atom->nbondtypes == 0)
dump_image.cpp:    utils::bounds(FLERR,arg[1],1,atom->nbondtypes,nlo,nhi,error);
dump_xyz.cpp:  ntypes = atom->ntypes;
dump_xyz.cpp:  tagint *tag = atom->tag;
dump_xyz.cpp:  int *type = atom->type;
dump_xyz.cpp:  int *mask = atom->mask;
dump_xyz.cpp:  double **x = atom->x;
dump_xyz.cpp:  int nlocal = atom->nlocal;
finish.cpp:  bigint nblocal = atom->nlocal;
finish.cpp:  MPI_Allreduce(&nblocal,&atom->natoms,1,MPI_LMP_BIGINT,MPI_SUM,world);
finish.cpp:                     ntasks,update->nsteps,atom->natoms);
finish.cpp:    if (atom->molecular != Atom::ATOMIC)
finish.cpp:      if (atom->molecular != Atom::ATOMIC)
finish.cpp:    tmp = atom->nlocal;
finish.cpp:    tmp = atom->nghost;
finish.cpp:    if (atom->molecular == Atom::MOLECULAR) {
finish.cpp:      int **nspecial = atom->nspecial;
finish.cpp:      int nlocal = atom->nlocal;
finish.cpp:    } else if (atom->molecular == Atom::TEMPLATE) {
finish.cpp:      Molecule **onemols = atom->avec->onemols;
finish.cpp:      int *molindex = atom->molindex;
finish.cpp:      int *molatom = atom->molatom;
finish.cpp:      int nlocal = atom->nlocal;
finish.cpp:      if (atom->natoms > 0)
finish.cpp:        mesg += fmt::format("Ave neighs/atom = {:.8}\n",nall/atom->natoms);
finish.cpp:      if ((atom->molecular != Atom::ATOMIC) && (atom->natoms > 0))
finish.cpp:                            nspec_all/atom->natoms);
fix_adapt.cpp:      utils::bounds(FLERR,arg[iarg+3],1,atom->ntypes,
fix_adapt.cpp:      utils::bounds(FLERR,arg[iarg+4],1,atom->ntypes,
fix_adapt.cpp:      utils::bounds(FLERR,arg[iarg+3],1,atom->nbondtypes,
fix_adapt.cpp:  int n = atom->ntypes;
fix_adapt.cpp:  n = atom->nbondtypes;
fix_adapt.cpp:  if (diamflag && atom->radius_flag) {
fix_adapt.cpp:      double *radius = atom->radius;
fix_adapt.cpp:      int *mask = atom->mask;
fix_adapt.cpp:      int nlocal = atom->nlocal;
fix_adapt.cpp:  if (chgflag && atom->q_flag) {
fix_adapt.cpp:      double *q = atom->q;
fix_adapt.cpp:      int *mask = atom->mask;
fix_adapt.cpp:      int nlocal = atom->nlocal;
fix_adapt.cpp:        if (!atom->radius_flag)
fix_adapt.cpp:        if (!atom->rmass_flag)
fix_adapt.cpp:        if (!atom->q_flag)
fix_adapt.cpp:        double *radius = atom->radius;
fix_adapt.cpp:        double *rmass = atom->rmass;
fix_adapt.cpp:        int *mask = atom->mask;
fix_adapt.cpp:        int nlocal = atom->nlocal;
fix_adapt.cpp:        int nall = nlocal + atom->nghost;
fix_adapt.cpp:        double *q = atom->q;
fix_adapt.cpp:        int *mask = atom->mask;
fix_adapt.cpp:        int nlocal = atom->nlocal;
fix_adapt.cpp:        int nall = nlocal + atom->nghost;
fix_adapt.cpp:        double *radius = atom->radius;
fix_adapt.cpp:        double *rmass = atom->rmass;
fix_adapt.cpp:        int *mask = atom->mask;
fix_adapt.cpp:        int nlocal = atom->nlocal;
fix_adapt.cpp:        double *q = atom->q;
fix_adapt.cpp:        int *mask = atom->mask;
fix_adapt.cpp:        int nlocal = atom->nlocal;
fix_adapt.cpp:  if (fix_diam) fix_diam->vstore[i] = atom->radius[i];
fix_adapt.cpp:  if (fix_chg) fix_chg->vstore[i] = atom->q[i];
fix_addforce.cpp:  double **x = atom->x;
fix_addforce.cpp:  double **f = atom->f;
fix_addforce.cpp:  int *mask = atom->mask;
fix_addforce.cpp:  imageint *image = atom->image;
fix_addforce.cpp:  int nlocal = atom->nlocal;
fix_addforce.cpp:    atom->sync_modify(Host, (unsigned int) (F_MASK | MASK_MASK),
fix_addforce.cpp:  if ((varflag == ATOM || estyle == ATOM) && atom->nmax > maxatom) {
fix_addforce.cpp:    maxatom = atom->nmax;
fix_addforce.cpp:   memory usage of local atom-based array
fix_ave_atom.cpp:        error->all(FLERR,"Fix ave/atom variable is not atom-style variable");
fix_ave_atom.cpp:  // perform initial allocation of atom-based array
fix_ave_atom.cpp:  FixAveAtom::grow_arrays(atom->nmax);
fix_ave_atom.cpp:  atom->add_callback(Atom::GROW);
fix_ave_atom.cpp:  int nlocal = atom->nlocal;
fix_ave_atom.cpp:  atom->delete_callback(id,Atom::GROW);
fix_ave_atom.cpp:  int nlocal = atom->nlocal;
fix_ave_atom.cpp:  int *mask = atom->mask;
fix_ave_atom.cpp:      double **x = atom->x;
fix_ave_atom.cpp:      double **v = atom->v;
fix_ave_atom.cpp:      double **f = atom->f;
fix_ave_atom.cpp:    // evaluate atom-style variable
fix_ave_atom.cpp:   memory usage of local atom-based array
fix_ave_atom.cpp:  bytes = (double)atom->nmax*nvalues * sizeof(double);
fix_ave_atom.cpp:   allocate atom-based array
fix_ave_atom.cpp:   copy values within local atom-based array
fix_ave_atom.cpp:   pack values in local atom-based array for exchange with another proc
fix_ave_atom.cpp:   unpack values in local atom-based array from exchange with another proc
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ave/chunk variable is not atom-style variable");
fix_ave_chunk.cpp:  int *mask = atom->mask;
fix_ave_chunk.cpp:  int nlocal = atom->nlocal;
fix_ave_chunk.cpp:      if (which[m] == ArgInfo::V) attribute = atom->v;
fix_ave_chunk.cpp:      else attribute = atom->f;
fix_ave_chunk.cpp:      int *type = atom->type;
fix_ave_chunk.cpp:      double *mass = atom->mass;
fix_ave_chunk.cpp:      double *rmass = atom->rmass;
fix_ave_chunk.cpp:      double **v = atom->v;
fix_ave_chunk.cpp:      int *type = atom->type;
fix_ave_chunk.cpp:      double *mass = atom->mass;
fix_ave_chunk.cpp:      double *rmass = atom->rmass;
fix_ave_chunk.cpp:    // evaluate atom-style variable
fix_ave_chunk.cpp:      if (atom->nmax > maxvar) {
fix_ave_chunk.cpp:        maxvar = atom->nmax;
fix_aveforce.cpp:  double **x = atom->x;
fix_aveforce.cpp:  double **f = atom->f;
fix_aveforce.cpp:  int *mask = atom->mask;
fix_aveforce.cpp:  int nlocal = atom->nlocal;
fix_aveforce.cpp:    double **x = atom->x;
fix_aveforce.cpp:    double **f = atom->f;
fix_aveforce.cpp:    int *mask = atom->mask;
fix_aveforce.cpp:    int nlocal = atom->nlocal;
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo variable is not atom-style variable");
fix_ave_histo.cpp:      bin_atoms(&atom->x[0][j],3);
fix_ave_histo.cpp:      bin_atoms(&atom->v[0][j],3);
fix_ave_histo.cpp:      bin_atoms(&atom->f[0][j],3);
fix_ave_histo.cpp:    // evaluate equal-style or vector-style or atom-style variable
fix_ave_histo.cpp:        if (atom->nmax > maxatom) {
fix_ave_histo.cpp:          maxatom = atom->nmax;
fix_ave_histo.cpp:  int *mask = atom->mask;
fix_ave_histo.cpp:  int nlocal = atom->nlocal;
fix_ave_histo_weight.cpp:      size[i] = atom->nlocal;
fix_ave_histo_weight.cpp:      size[i] = atom->nlocal;
fix_ave_histo_weight.cpp:      size[i] = atom->nlocal;
fix_ave_histo_weight.cpp:      size[i] = atom->nlocal;
fix_ave_histo_weight.cpp:    weights = &atom->x[0][j];
fix_ave_histo_weight.cpp:    weights = &atom->v[0][j];
fix_ave_histo_weight.cpp:    bin_atoms(&atom->v[0][j],3);
fix_ave_histo_weight.cpp:    weights = &atom->f[0][j];
fix_ave_histo_weight.cpp:    if (atom->nmax > maxatom) {
fix_ave_histo_weight.cpp:      maxatom = atom->nmax;
fix_ave_histo_weight.cpp:    bin_atoms_weights(&atom->x[0][j],3,weights,stride);
fix_ave_histo_weight.cpp:    bin_atoms_weights(&atom->v[0][j],3,weights,stride);
fix_ave_histo_weight.cpp:    bin_atoms_weights(&atom->f[0][j],3,weights,stride);
fix_ave_histo_weight.cpp:    if (atom->nmax > maxatom) {
fix_ave_histo_weight.cpp:      maxatom = atom->nmax;
fix_ave_histo_weight.cpp:  int *mask = atom->mask;
fix_ave_histo_weight.cpp:  int nlocal = atom->nlocal;
fix_balance.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
fix_balance.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
fix_balance.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
fix_balance.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
fix_balance.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
fix_balance.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal);
fix_box_relax.cpp:  double **x = atom->x;
fix_box_relax.cpp:  int *mask = atom->mask;
fix_box_relax.cpp:  n = atom->nlocal + atom->nghost;
fix.cpp:  if (eflag_atom && atom->nlocal > maxeatom) {
fix.cpp:    maxeatom = atom->nmax;
fix.cpp:  if (vflag_atom && atom->nlocal > maxvatom) {
fix.cpp:    maxvatom = atom->nmax;
fix.cpp:    n = atom->nlocal;
fix.cpp:    n = atom->nlocal;
fix.cpp:  if (vflag_atom && atom->nlocal > maxvatom) {
fix.cpp:    maxvatom = atom->nmax;
fix.cpp:    n = atom->nlocal;
fix_deform.cpp:  double **x = atom->x;
fix_deform.cpp:  imageint *image = atom->image;
fix_deform.cpp:  int nlocal = atom->nlocal;
fix_deform.cpp:  domain->x2lamda(atom->nlocal);
fix_deform.cpp:  domain->lamda2x(atom->nlocal);
fix_deform.cpp:    double **x = atom->x;
fix_deform.cpp:    int *mask = atom->mask;
fix_deform.cpp:    int nlocal = atom->nlocal;
fix_deform.cpp:    double **x = atom->x;
fix_deform.cpp:    int *mask = atom->mask;
fix_deform.cpp:    int nlocal = atom->nlocal;
fix_deposit.cpp:  if (mode == ATOM && (ntype <= 0 || ntype > atom->ntypes))
fix_deposit.cpp:  if (atom->tag_enable == 0)
fix_deposit.cpp:          ntype+onemols[i]->ntypes > atom->ntypes)
fix_deposit.cpp:      if (atom->molecular == Atom::TEMPLATE && onemols != atom->avec->onemols)
fix_deposit.cpp:  if (atom->radius_flag) {
fix_deposit.cpp:    double *radius = atom->radius;
fix_deposit.cpp:    int nlocal = atom->nlocal;
fix_deposit.cpp:  if (atom->map_style != Atom::MAP_NONE) atom->map_clear();
fix_deposit.cpp:  atom->nghost = 0;
fix_deposit.cpp:  atom->avec->clear_bonus();
fix_deposit.cpp:      double **x = atom->x;
fix_deposit.cpp:      int nlocal = atom->nlocal;
fix_deposit.cpp:    double **x = atom->x;
fix_deposit.cpp:    int nlocal = atom->nlocal;
fix_deposit.cpp:    nlocalprev = atom->nlocal;
fix_deposit.cpp:        if (mode == ATOM) atom->avec->create_atom(ntype,coords[m]);
fix_deposit.cpp:        else atom->avec->create_atom(ntype+onemols[imol]->type[m],coords[m]);
fix_deposit.cpp:        n = atom->nlocal - 1;
fix_deposit.cpp:        atom->tag[n] = maxtag_all + m+1;
fix_deposit.cpp:          if (atom->molecule_flag) {
fix_deposit.cpp:              atom->molecule[n] = maxmol_all + onemols[imol]->molecule[m];
fix_deposit.cpp:              atom->molecule[n] = maxmol_all+1;
fix_deposit.cpp:          if (atom->molecular == Atom::TEMPLATE) {
fix_deposit.cpp:            atom->molindex[n] = 0;
fix_deposit.cpp:            atom->molatom[n] = m;
fix_deposit.cpp:        atom->mask[n] = 1 | groupbit;
fix_deposit.cpp:        atom->image[n] = imageflags[m];
fix_deposit.cpp:        atom->v[n][0] = vnew[0];
fix_deposit.cpp:        atom->v[n][1] = vnew[1];
fix_deposit.cpp:        atom->v[n][2] = vnew[2];
fix_deposit.cpp:          atom->add_molecule_atom(onemols[imol],m,n,maxtag_all);
fix_deposit.cpp:    atom->natoms += natom;
fix_deposit.cpp:    if (atom->natoms < 0)
fix_deposit.cpp:      atom->nbonds += onemols[imol]->nbonds;
fix_deposit.cpp:      atom->nangles += onemols[imol]->nangles;
fix_deposit.cpp:      atom->ndihedrals += onemols[imol]->ndihedrals;
fix_deposit.cpp:      atom->nimpropers += onemols[imol]->nimpropers;
fix_deposit.cpp:    if (mode == MOLECULE && atom->molecule_flag) {
fix_deposit.cpp:  if (atom->map_style != Atom::MAP_NONE) {
fix_deposit.cpp:    if (success) atom->map_init();
fix_deposit.cpp:    atom->map_set();
fix_deposit.cpp:  tagint *tag = atom->tag;
fix_deposit.cpp:  tagint *molecule = atom->molecule;
fix_deposit.cpp:  int nlocal = atom->nlocal;
fix_deposit.cpp:      int imol = atom->find_molecule(arg[iarg+1]);
fix_deposit.cpp:      onemols = &atom->molecules[imol];
fix_deposit.cpp:        //   same as atom->avec->create_atom(), invoked in pre_exchange()
fix_dt_reset.cpp:  double **v = atom->v;
fix_dt_reset.cpp:  double **f = atom->f;
fix_dt_reset.cpp:  double *mass = atom->mass;
fix_dt_reset.cpp:  double *rmass = atom->rmass;
fix_dt_reset.cpp:  int *type = atom->type;
fix_dt_reset.cpp:  int *mask = atom->mask;
fix_dt_reset.cpp:  int nlocal = atom->nlocal;
fix_efield.cpp:  maxatom = atom->nmax;
fix_efield.cpp:  if (atom->q_flag) qflag = 1;
fix_efield.cpp:  if (atom->mu_flag && atom->torque_flag) muflag = 1;
fix_efield.cpp:    error->all(FLERR,"Fix efield with dipoles cannot use atom-style variables");
fix_efield.cpp:  double **f = atom->f;
fix_efield.cpp:  double *q = atom->q;
fix_efield.cpp:  int *mask = atom->mask;
fix_efield.cpp:  imageint *image = atom->image;
fix_efield.cpp:  int nlocal = atom->nlocal;
fix_efield.cpp:  if (varflag == ATOM && atom->nmax > maxatom) {
fix_efield.cpp:    maxatom = atom->nmax;
fix_efield.cpp:  double **x = atom->x;
fix_efield.cpp:      double **mu = atom->mu;
fix_efield.cpp:      double **t = atom->torque;
fix_efield.cpp:      double **mu = atom->mu;
fix_efield.cpp:      double **t = atom->torque;
fix_efield.cpp:   memory usage of local atom-based array
fix_efield.cpp:  if (varflag == ATOM) bytes = atom->nmax*4 * sizeof(double);
fix_enforce2d.cpp:  double **v = atom->v;
fix_enforce2d.cpp:  double **f = atom->f;
fix_enforce2d.cpp:  int *mask = atom->mask;
fix_enforce2d.cpp:  int nlocal = atom->nlocal;
fix_enforce2d.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_enforce2d.cpp:  if (atom->omega_flag) {
fix_enforce2d.cpp:    double **omega = atom->omega;
fix_enforce2d.cpp:  if (atom->angmom_flag) {
fix_enforce2d.cpp:    double **angmom = atom->angmom;
fix_enforce2d.cpp:  if (atom->torque_flag) {
fix_enforce2d.cpp:    double **torque = atom->torque;
fix_evaporate.cpp:  // check that no deletable atoms are in atom->firstgroup
fix_evaporate.cpp:  if (atom->firstgroup >= 0) {
fix_evaporate.cpp:    int *mask = atom->mask;
fix_evaporate.cpp:    int nlocal = atom->nlocal;
fix_evaporate.cpp:    int firstgroupbit = group->bitmask[atom->firstgroup];
fix_evaporate.cpp:  if (molflag == 0 && atom->molecule_flag) {
fix_evaporate.cpp:    tagint *molecule = atom->molecule;
fix_evaporate.cpp:    int *mask = atom->mask;
fix_evaporate.cpp:    int nlocal = atom->nlocal;
fix_evaporate.cpp:  if (molflag && atom->molecule_flag == 0)
fix_evaporate.cpp:  if (atom->nmax > nmax) {
fix_evaporate.cpp:    nmax = atom->nmax;
fix_evaporate.cpp:  double **x = atom->x;
fix_evaporate.cpp:  int *mask = atom->mask;
fix_evaporate.cpp:  tagint *tag = atom->tag;
fix_evaporate.cpp:  int nlocal = atom->nlocal;
fix_evaporate.cpp:    tagint *molecule = atom->molecule;
fix_evaporate.cpp:    int *molindex = atom->molindex;
fix_evaporate.cpp:    int *molatom = atom->molatom;
fix_evaporate.cpp:    int molecular = atom->molecular;
fix_evaporate.cpp:    Molecule **onemols = atom->avec->onemols;
fix_evaporate.cpp:      // for atom->molecular = Atom::MOLECULAR, do this for each deleted atom in molecule
fix_evaporate.cpp:      // for atom->molecular = Atom::TEMPLATE, use Molecule counts for just 1st atom in mol
fix_evaporate.cpp:            if (atom->avec->bonds_allow) {
fix_evaporate.cpp:              if (force->newton_bond) ndeltopo[0] += atom->num_bond[i];
fix_evaporate.cpp:                for (j = 0; j < atom->num_bond[i]; j++) {
fix_evaporate.cpp:                  if (tag[i] < atom->bond_atom[i][j]) ndeltopo[0]++;
fix_evaporate.cpp:            if (atom->avec->angles_allow) {
fix_evaporate.cpp:              if (force->newton_bond) ndeltopo[1] += atom->num_angle[i];
fix_evaporate.cpp:                for (j = 0; j < atom->num_angle[i]; j++) {
fix_evaporate.cpp:                  m = atom->map(atom->angle_atom2[i][j]);
fix_evaporate.cpp:            if (atom->avec->dihedrals_allow) {
fix_evaporate.cpp:              if (force->newton_bond) ndeltopo[2] += atom->num_dihedral[i];
fix_evaporate.cpp:                for (j = 0; j < atom->num_dihedral[i]; j++) {
fix_evaporate.cpp:                  m = atom->map(atom->dihedral_atom2[i][j]);
fix_evaporate.cpp:            if (atom->avec->impropers_allow) {
fix_evaporate.cpp:              if (force->newton_bond) ndeltopo[3] += atom->num_improper[i];
fix_evaporate.cpp:                for (j = 0; j < atom->num_improper[i]; j++) {
fix_evaporate.cpp:                  m = atom->map(atom->improper_atom2[i][j]);
fix_evaporate.cpp:  AtomVec *avec = atom->avec;
fix_evaporate.cpp:      avec->copy(atom->nlocal-1,i,1);
fix_evaporate.cpp:      atom->nlocal--;
fix_evaporate.cpp:  atom->natoms -= ndel;
fix_evaporate.cpp:    atom->nbonds -= all[0];
fix_evaporate.cpp:    atom->nangles -= all[1];
fix_evaporate.cpp:    atom->ndihedrals -= all[2];
fix_evaporate.cpp:    atom->nimpropers -= all[3];
fix_evaporate.cpp:  if (ndel && (atom->map_style != Atom::MAP_NONE)) {
fix_evaporate.cpp:    atom->nghost = 0;
fix_evaporate.cpp:    atom->map_init();
fix_evaporate.cpp:    atom->map_set();
fix_evaporate.cpp:   memory usage of local atom-based arrays
fix_external.cpp:  // perform initial allocation of atom-based array
fix_external.cpp:  FixExternal::grow_arrays(atom->nmax);
fix_external.cpp:  atom->add_callback(Atom::GROW);
fix_external.cpp:  atom->delete_callback(id,Atom::GROW);
fix_external.cpp:                     atom->nlocal,atom->tag,atom->x,fexternal);
fix_external.cpp:    double **f = atom->f;
fix_external.cpp:    int *mask = atom->mask;
fix_external.cpp:    int nlocal = atom->nlocal;
fix_external.cpp:  int nlocal = atom->nlocal;
fix_external.cpp:  int nlocal = atom->nlocal;
fix_external.cpp:   memory usage of local atom-based array
fix_external.cpp:  double bytes = 3*atom->nmax * sizeof(double);
fix_external.cpp:   allocate atom-based array
fix_external.cpp:   copy values within local atom-based array
fix_external.cpp:   pack values in local atom-based array for exchange with another proc
fix_external.cpp:   unpack values in local atom-based array from exchange with another proc
fix_gravity.cpp:  double **x = atom->x;
fix_gravity.cpp:  double **f = atom->f;
fix_gravity.cpp:  double *rmass = atom->rmass;
fix_gravity.cpp:  double *mass = atom->mass;
fix_gravity.cpp:  int *mask = atom->mask;
fix_gravity.cpp:  int *type = atom->type;
fix_gravity.cpp:  int nlocal = atom->nlocal;
fix_group.cpp:      iprop = atom->find_custom(arg[iarg+1],flag,cols);
fix_group.cpp:    iprop = atom->find_custom(idprop,proptype,cols);
fix_group.cpp:  int nlocal = atom->nlocal;
fix_group.cpp:  // invoke atom-style variable if defined
fix_group.cpp:  if (propflag && !proptype) ivector = atom->ivector[iprop];
fix_group.cpp:  if (propflag && proptype) dvector = atom->dvector[iprop];
fix_group.cpp:  double **x = atom->x;
fix_group.cpp:  int *mask = atom->mask;
fix_halt.cpp:  double **x = atom->x;
fix_heat.cpp:  double **x = atom->x;
fix_heat.cpp:  double **v = atom->v;
fix_heat.cpp:  int *mask = atom->mask;
fix_heat.cpp:  int nlocal = atom->nlocal;
fix_heat.cpp:  int *type = atom->type;
fix_heat.cpp:  double *mass = atom->mass;
fix_heat.cpp:  double *rmass = atom->rmass;
fix_heat.cpp:  if (hstyle == ATOM && atom->nmax > maxatom) {
fix_heat.cpp:    maxatom = atom->nmax;
fix_heat.cpp:    int *mask = atom->mask;
fix_heat.cpp:    double **x = atom->x;
fix_heat.cpp:    int nlocal = atom->nlocal;
fix_heat.cpp:   memory usage of local atom-based arrays
fix_heat.cpp:  if (hstyle == ATOM) bytes = atom->nmax*2 * sizeof(double);
fix_indent.cpp:    double **x = atom->x;
fix_indent.cpp:    double **f = atom->f;
fix_indent.cpp:    int *mask = atom->mask;
fix_indent.cpp:    int nlocal = atom->nlocal;
fix_indent.cpp:    double **x = atom->x;
fix_indent.cpp:    double **f = atom->f;
fix_indent.cpp:    int *mask = atom->mask;
fix_indent.cpp:    int nlocal = atom->nlocal;
fix_indent.cpp:    double **x = atom->x;
fix_indent.cpp:    double **f = atom->f;
fix_indent.cpp:    int *mask = atom->mask;
fix_indent.cpp:    int nlocal = atom->nlocal;
fix_langevin.cpp:  gfactor1 = new double[atom->ntypes+1];
fix_langevin.cpp:  gfactor2 = new double[atom->ntypes+1];
fix_langevin.cpp:  ratio = new double[atom->ntypes+1];
fix_langevin.cpp:  for (int i = 1; i <= atom->ntypes; i++) ratio[i] = 1.0;
fix_langevin.cpp:      if (itype <= 0 || itype > atom->ntypes)
fix_langevin.cpp:  // setup atom-based array for franprev
fix_langevin.cpp:    FixLangevin::grow_arrays(atom->nmax);
fix_langevin.cpp:    atom->add_callback(Atom::GROW);
fix_langevin.cpp:    int nlocal = atom->nlocal;
fix_langevin.cpp:    atom->delete_callback(id,Atom::GROW);
fix_langevin.cpp:  if (oflag && !atom->sphere_flag)
fix_langevin.cpp:  if (ascale && !atom->ellipsoid_flag)
fix_langevin.cpp:    double *radius = atom->radius;
fix_langevin.cpp:    int *mask = atom->mask;
fix_langevin.cpp:    int nlocal = atom->nlocal;
fix_langevin.cpp:    avec = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
fix_langevin.cpp:    int *ellipsoid = atom->ellipsoid;
fix_langevin.cpp:    int *mask = atom->mask;
fix_langevin.cpp:    int nlocal = atom->nlocal;
fix_langevin.cpp:  if (!atom->rmass) {
fix_langevin.cpp:    for (int i = 1; i <= atom->ntypes; i++) {
fix_langevin.cpp:      gfactor1[i] = -atom->mass[i] / t_period / force->ftm2v;
fix_langevin.cpp:        gfactor2[i] = sqrt(atom->mass[i]) *
fix_langevin.cpp:        gfactor2[i] = sqrt(atom->mass[i]) *
fix_langevin.cpp:    double **v = atom->v;
fix_langevin.cpp:    double **f = atom->f;
fix_langevin.cpp:    int *mask = atom->mask;
fix_langevin.cpp:    int nlocal = atom->nlocal;
fix_langevin.cpp:    double *rmass = atom->rmass;
fix_langevin.cpp:    double *mass = atom->mass;
fix_langevin.cpp:    int *type = atom->type;
fix_langevin.cpp:    double **f = atom->f;
fix_langevin.cpp:    double **v = atom->v;
fix_langevin.cpp:    int *mask = atom->mask;
fix_langevin.cpp:    int nlocal = atom->nlocal;
fix_langevin.cpp:    double *rmass = atom->rmass;
fix_langevin.cpp:    double *mass = atom->mass;
fix_langevin.cpp:    int *type = atom->type;
fix_langevin.cpp:  double **v = atom->v;
fix_langevin.cpp:  double **f = atom->f;
fix_langevin.cpp:  int *mask = atom->mask;
fix_langevin.cpp:  int nlocal = atom->nlocal;
fix_langevin.cpp:  double *rmass = atom->rmass;
fix_langevin.cpp:  double **v = atom->v;
fix_langevin.cpp:  double **f = atom->f;
fix_langevin.cpp:  double *rmass = atom->rmass;
fix_langevin.cpp:  int *type = atom->type;
fix_langevin.cpp:  int *mask = atom->mask;
fix_langevin.cpp:  int nlocal = atom->nlocal;
fix_langevin.cpp:    if (atom->nmax > maxatom1) {
fix_langevin.cpp:      maxatom1 = atom->nmax;
fix_langevin.cpp:  int *mask = atom->mask;
fix_langevin.cpp:  int nlocal = atom->nlocal;
fix_langevin.cpp:      if (atom->nmax > maxatom2) {
fix_langevin.cpp:        maxatom2 = atom->nmax;
fix_langevin.cpp:  double **torque = atom->torque;
fix_langevin.cpp:  double **omega = atom->omega;
fix_langevin.cpp:  double *radius = atom->radius;
fix_langevin.cpp:  double *rmass = atom->rmass;
fix_langevin.cpp:  int *mask = atom->mask;
fix_langevin.cpp:  int *type = atom->type;
fix_langevin.cpp:  int nlocal = atom->nlocal;
fix_langevin.cpp:  double **torque = atom->torque;
fix_langevin.cpp:  double **angmom = atom->angmom;
fix_langevin.cpp:  double *rmass = atom->rmass;
fix_langevin.cpp:  int *ellipsoid = atom->ellipsoid;
fix_langevin.cpp:  int *mask = atom->mask;
fix_langevin.cpp:  int *type = atom->type;
fix_langevin.cpp:  int nlocal = atom->nlocal;
fix_langevin.cpp:  double **v = atom->v;
fix_langevin.cpp:  int *mask = atom->mask;
fix_langevin.cpp:  int nlocal = atom->nlocal;
fix_langevin.cpp:  double *mass = atom->mass;
fix_langevin.cpp:  double *rmass = atom->rmass;
fix_langevin.cpp:  double **f = atom->f;
fix_langevin.cpp:  int *type = atom->type;
fix_langevin.cpp:          if (atom->rmass) {
fix_langevin.cpp:  if (atom->mass) {
fix_langevin.cpp:    for (int i = 1; i <= atom->ntypes; i++) {
fix_langevin.cpp:        gfactor2[i] = sqrt(atom->mass[i]) *
fix_langevin.cpp:        gfactor2[i] = sqrt(atom->mass[i]) *
fix_langevin.cpp:  double **v = atom->v;
fix_langevin.cpp:  int *mask = atom->mask;
fix_langevin.cpp:  int nlocal = atom->nlocal;
fix_langevin.cpp:  if (gjfflag) bytes += (double)atom->nmax*6 * sizeof(double);
fix_langevin.cpp:  if (tallyflag || osflag) bytes += (double)atom->nmax*3 * sizeof(double);
fix_langevin.cpp:  if (tforce) bytes += (double)atom->nmax * sizeof(double);
fix_langevin.cpp:   allocate atom-based array for franprev
fix_langevin.cpp:   copy values within local atom-based array
fix_langevin.cpp:   pack values in local atom-based array for exchange with another proc
fix_langevin.cpp:   unpack values in local atom-based array from exchange with another proc
fix_lineforce.cpp:  double **f = atom->f;
fix_lineforce.cpp:  int *mask = atom->mask;
fix_lineforce.cpp:  int nlocal = atom->nlocal;
fix_minimize.cpp:  atom->add_callback(Atom::GROW);
fix_minimize.cpp:  atom->delete_callback(id,Atom::GROW);
fix_minimize.cpp:  memory->create(vectors[nvector],atom->nmax*n,"minimize:vector");
fix_minimize.cpp:  int ntotal = n*atom->nlocal;
fix_minimize.cpp:  double **x = atom->x;
fix_minimize.cpp:  int nlocal = atom->nlocal;
fix_minimize.cpp:   memory usage of local atom-based arrays
fix_minimize.cpp:    bytes += (double)atom->nmax*peratom[m]*sizeof(double);
fix_minimize.cpp:   allocate local atom-based arrays
fix_minimize.cpp:   copy values within local atom-based arrays
fix_minimize.cpp:   pack values in local atom-based arrays for exchange with another proc
fix_minimize.cpp:   unpack values in local atom-based arrays from exchange with another proc
fix_momentum.cpp:  double **x = atom->x;
fix_momentum.cpp:  double **v = atom->v;
fix_momentum.cpp:  int *mask = atom->mask;
fix_momentum.cpp:  imageint *image = atom->image;
fix_momentum.cpp:  const int nlocal = atom->nlocal;
fix_momentum.cpp:    double *rmass = atom->rmass;
fix_momentum.cpp:    double *mass = atom->mass;
fix_momentum.cpp:    int *type = atom->type;
fix_momentum.cpp:    double *rmass = atom->rmass;
fix_momentum.cpp:    double *mass = atom->mass;
fix_momentum.cpp:    int *type = atom->type;
fix_move.cpp:  omega_flag = atom->omega_flag;
fix_move.cpp:  angmom_flag = atom->angmom_flag;
fix_move.cpp:  radius_flag = atom->radius_flag;
fix_move.cpp:  ellipsoid_flag = atom->ellipsoid_flag;
fix_move.cpp:  line_flag = atom->line_flag;
fix_move.cpp:  tri_flag = atom->tri_flag;
fix_move.cpp:  body_flag = atom->body_flag;
fix_move.cpp:  // perform initial allocation of atom-based array
fix_move.cpp:  FixMove::grow_arrays(atom->nmax);
fix_move.cpp:  atom->add_callback(Atom::GROW);
fix_move.cpp:  atom->add_callback(Atom::RESTART);
fix_move.cpp:  avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
fix_move.cpp:  avec_line = (AtomVecLine *) atom->style_match("line");
fix_move.cpp:  avec_tri = (AtomVecTri *) atom->style_match("tri");
fix_move.cpp:  avec_body = (AtomVecBody *) atom->style_match("body");
fix_move.cpp:  double **x = atom->x;
fix_move.cpp:  imageint *image = atom->image;
fix_move.cpp:  int *ellipsoid = atom->ellipsoid;
fix_move.cpp:  int *line = atom->line;
fix_move.cpp:  int *tri = atom->tri;
fix_move.cpp:  int *body = atom->body;
fix_move.cpp:  int *mask = atom->mask;
fix_move.cpp:  int nlocal = atom->nlocal;
fix_move.cpp:  atom->delete_callback(id,Atom::GROW);
fix_move.cpp:  atom->delete_callback(id,Atom::RESTART);
fix_move.cpp:  maxatom = atom->nmax;
fix_move.cpp:  double **x = atom->x;
fix_move.cpp:  double **v = atom->v;
fix_move.cpp:  double **f = atom->f;
fix_move.cpp:  double **omega = atom->omega;
fix_move.cpp:  double **angmom = atom->angmom;
fix_move.cpp:  double *radius = atom->radius;
fix_move.cpp:  double *rmass = atom->rmass;
fix_move.cpp:  double *mass = atom->mass;
fix_move.cpp:  int *type = atom->type;
fix_move.cpp:  int *ellipsoid = atom->ellipsoid;
fix_move.cpp:  int *line = atom->line;
fix_move.cpp:  int *tri = atom->tri;
fix_move.cpp:  int *body = atom->body;
fix_move.cpp:  int *mask = atom->mask;
fix_move.cpp:  int nlocal = atom->nlocal;
fix_move.cpp:            avec_line->bonus[atom->line[i]].theta = theta_new;
fix_move.cpp:    if ((displaceflag || velocityflag) && atom->nmax > maxatom) {
fix_move.cpp:      maxatom = atom->nmax;
fix_move.cpp:  double **v = atom->v;
fix_move.cpp:  double **f = atom->f;
fix_move.cpp:  double *rmass = atom->rmass;
fix_move.cpp:  double *mass = atom->mass;
fix_move.cpp:  int *type = atom->type;
fix_move.cpp:  int *mask = atom->mask;
fix_move.cpp:  int nlocal = atom->nlocal;
fix_move.cpp:   memory usage of local atom-based array
fix_move.cpp:  double bytes = (double)atom->nmax*3 * sizeof(double);
fix_move.cpp:  if (theta_flag) bytes += (double)atom->nmax * sizeof(double);
fix_move.cpp:  if (quat_flag) bytes += (double)atom->nmax*4 * sizeof(double);
fix_move.cpp:  if (displaceflag) bytes += (double)atom->nmax*3 * sizeof(double);
fix_move.cpp:  if (velocityflag) bytes += (double)atom->nmax*3 * sizeof(double);
fix_move.cpp:   allocate atom-based array
fix_move.cpp:   copy values within local atom-based array
fix_move.cpp:  double **x = atom->x;
fix_move.cpp:  imageint *image = atom->image;
fix_move.cpp:  int *ellipsoid = atom->ellipsoid;
fix_move.cpp:  int *line = atom->line;
fix_move.cpp:  int *tri = atom->tri;
fix_move.cpp:  int *body = atom->body;
fix_move.cpp:  int *mask = atom->mask;
fix_move.cpp:        theta = avec_line->bonus[atom->line[i]].theta;
fix_move.cpp:   pack values in local atom-based array for exchange with another proc
fix_move.cpp:   unpack values in local atom-based array from exchange with another proc
fix_move.cpp:   pack values in local atom-based arrays for restart file
fix_move.cpp:   unpack values from atom->extra array to restart the fix
fix_move.cpp:  double **extra = atom->extra;
fix_neigh_history.cpp:  // perform initial allocation of atom-based arrays
fix_neigh_history.cpp:  FixNeighHistory::grow_arrays(atom->nmax);
fix_neigh_history.cpp:  atom->add_callback(Atom::GROW);
fix_neigh_history.cpp:  atom->add_callback(Atom::RESTART);
fix_neigh_history.cpp:  int nlocal = atom->nlocal;
fix_neigh_history.cpp:  atom->delete_callback(id,Atom::GROW);
fix_neigh_history.cpp:  atom->delete_callback(id,Atom::RESTART);
fix_neigh_history.cpp:  if (atom->tag_enable == 0)
fix_neigh_history.cpp:  ipage_atom->reset();
fix_neigh_history.cpp:  dpage_atom->reset();
fix_neigh_history.cpp:  tagint *tag = atom->tag;
fix_neigh_history.cpp:    partner[i] = ipage_atom->get(n);
fix_neigh_history.cpp:    valuepartner[i] = dpage_atom->get(dnum*n);
fix_neigh_history.cpp:  int nlocal = atom->nlocal;
fix_neigh_history.cpp:  ipage_atom->reset();
fix_neigh_history.cpp:  dpage_atom->reset();
fix_neigh_history.cpp:  tagint *tag = atom->tag;
fix_neigh_history.cpp:    partner[i] = ipage_atom->get(n);
fix_neigh_history.cpp:    valuepartner[i] = dpage_atom->get(dnum*n);
fix_neigh_history.cpp:    partner[i] = ipage_atom->get(n);
fix_neigh_history.cpp:    valuepartner[i] = dpage_atom->get(dnum*n);
fix_neigh_history.cpp:  int nlocal = atom->nlocal;
fix_neigh_history.cpp:  ipage_atom->reset();
fix_neigh_history.cpp:  dpage_atom->reset();
fix_neigh_history.cpp:  tagint *tag = atom->tag;
fix_neigh_history.cpp:    partner[i] = ipage_atom->get(n);
fix_neigh_history.cpp:    valuepartner[i] = dpage_atom->get(dnum*n);
fix_neigh_history.cpp:  int nlocal = atom->nlocal;
fix_neigh_history.cpp:  int nlocal = atom->nlocal;
fix_neigh_history.cpp:  int nall = nlocal + atom->nghost;
fix_neigh_history.cpp:  tagint *tag = atom->tag;
fix_neigh_history.cpp:   memory usage of local atom-based arrays
fix_neigh_history.cpp:  int nmax = atom->nmax;
fix_neigh_history.cpp:   allocate local atom-based arrays
fix_neigh_history.cpp:   copy values within local atom-based arrays
fix_neigh_history.cpp:   pack values in local atom-based arrays for exchange with another proc
fix_neigh_history.cpp:   unpack values in local atom-based arrays from exchange with another proc
fix_neigh_history.cpp:  partner[nlocal] = ipage_atom->get(npartner[nlocal]);
fix_neigh_history.cpp:  valuepartner[nlocal] = dpage_atom->get(dnum*npartner[nlocal]);
fix_neigh_history.cpp:   pack values in local atom-based arrays for restart file
fix_neigh_history.cpp:   unpack values from atom->extra array to restart the fix
fix_neigh_history.cpp:  double **extra = atom->extra;
fix_neigh_history.cpp:  partner[nlocal] = ipage_atom->get(npartner[nlocal]);
fix_neigh_history.cpp:  valuepartner[nlocal] = dpage_atom->get(dnum*npartner[nlocal]);
fix_nh.cpp:    if (!atom->sphere_flag)
fix_nh.cpp:    if (!atom->mu_flag)
fix_nh.cpp:    double nkt = (atom->natoms + 1) * kt;
fix_nh.cpp:  double **x = atom->x;
fix_nh.cpp:  int *mask = atom->mask;
fix_nh.cpp:  int nlocal = atom->nlocal;
fix_nh.cpp:    double nkt = (atom->natoms + 1) * kt;
fix_nh.cpp:  double **v = atom->v;
fix_nh.cpp:  int *mask = atom->mask;
fix_nh.cpp:  int nlocal = atom->nlocal;
fix_nh.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nh.cpp:  double **v = atom->v;
fix_nh.cpp:  double **f = atom->f;
fix_nh.cpp:  double *rmass = atom->rmass;
fix_nh.cpp:  double *mass = atom->mass;
fix_nh.cpp:  int *type = atom->type;
fix_nh.cpp:  int *mask = atom->mask;
fix_nh.cpp:  int nlocal = atom->nlocal;
fix_nh.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nh.cpp:  double **x = atom->x;
fix_nh.cpp:  double **v = atom->v;
fix_nh.cpp:  int *mask = atom->mask;
fix_nh.cpp:  int nlocal = atom->nlocal;
fix_nh.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nh.cpp:  double **v = atom->v;
fix_nh.cpp:  int *mask = atom->mask;
fix_nh.cpp:  int nlocal = atom->nlocal;
fix_nh.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nh.cpp:      mtk_term1 /= pdim * atom->natoms;
fix_nh.cpp:      mtk_term1 /= pdim * atom->natoms;
fix_nh.cpp:    if (pdim > 0) mtk_term2 /= pdim * atom->natoms;
fix_nh.cpp:    double **x = atom->x;
fix_nh.cpp:    imageint *image = atom->image;
fix_nh.cpp:    int nlocal = atom->nlocal;
fix_nh.cpp:    domain->x2lamda(atom->nlocal);
fix_nh.cpp:    domain->lamda2x(atom->nlocal);
fix_nh_sphere.cpp:  if (!atom->sphere_flag)
fix_nh_sphere.cpp:  double *radius = atom->radius;
fix_nh_sphere.cpp:  int *mask = atom->mask;
fix_nh_sphere.cpp:  int nlocal = atom->nlocal;
fix_nh_sphere.cpp:  double **omega = atom->omega;
fix_nh_sphere.cpp:  double **torque = atom->torque;
fix_nh_sphere.cpp:  double *radius = atom->radius;
fix_nh_sphere.cpp:  double *rmass = atom->rmass;
fix_nh_sphere.cpp:  int *mask = atom->mask;
fix_nh_sphere.cpp:  int nlocal = atom->nlocal;
fix_nh_sphere.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nh_sphere.cpp:    double **mu = atom->mu;
fix_nh_sphere.cpp:    double **omega = atom->omega;
fix_nh_sphere.cpp:    int *mask = atom->mask;
fix_nh_sphere.cpp:    int nlocal = atom->nlocal;
fix_nh_sphere.cpp:  double **omega = atom->omega;
fix_nh_sphere.cpp:  int *mask = atom->mask;
fix_nh_sphere.cpp:  int nlocal = atom->nlocal;
fix_nh_sphere.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nve.cpp:  double **x = atom->x;
fix_nve.cpp:  double **v = atom->v;
fix_nve.cpp:  double **f = atom->f;
fix_nve.cpp:  double *rmass = atom->rmass;
fix_nve.cpp:  double *mass = atom->mass;
fix_nve.cpp:  int *type = atom->type;
fix_nve.cpp:  int *mask = atom->mask;
fix_nve.cpp:  int nlocal = atom->nlocal;
fix_nve.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nve.cpp:  double **v = atom->v;
fix_nve.cpp:  double **f = atom->f;
fix_nve.cpp:  double *rmass = atom->rmass;
fix_nve.cpp:  double *mass = atom->mass;
fix_nve.cpp:  int *type = atom->type;
fix_nve.cpp:  int *mask = atom->mask;
fix_nve.cpp:  int nlocal = atom->nlocal;
fix_nve.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nve_limit.cpp:  double **x = atom->x;
fix_nve_limit.cpp:  double **v = atom->v;
fix_nve_limit.cpp:  double **f = atom->f;
fix_nve_limit.cpp:  double *mass = atom->mass;
fix_nve_limit.cpp:  double *rmass = atom->rmass;
fix_nve_limit.cpp:  int *type = atom->type;
fix_nve_limit.cpp:  int *mask = atom->mask;
fix_nve_limit.cpp:  int nlocal = atom->nlocal;
fix_nve_limit.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nve_limit.cpp:  double **v = atom->v;
fix_nve_limit.cpp:  double **f = atom->f;
fix_nve_limit.cpp:  double *mass = atom->mass;
fix_nve_limit.cpp:  double *rmass = atom->rmass;
fix_nve_limit.cpp:  int *type = atom->type;
fix_nve_limit.cpp:  int *mask = atom->mask;
fix_nve_limit.cpp:  int nlocal = atom->nlocal;
fix_nve_limit.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nve_noforce.cpp:  double **x = atom->x;
fix_nve_noforce.cpp:  double **v = atom->v;
fix_nve_noforce.cpp:  int *mask = atom->mask;
fix_nve_noforce.cpp:  int nlocal = atom->nlocal;
fix_nve_noforce.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nve_sphere.cpp:  if (!atom->sphere_flag)
fix_nve_sphere.cpp:  if (extra == DIPOLE && !atom->mu_flag)
fix_nve_sphere.cpp:  double *radius = atom->radius;
fix_nve_sphere.cpp:  int *mask = atom->mask;
fix_nve_sphere.cpp:  int nlocal = atom->nlocal;
fix_nve_sphere.cpp:  double **x = atom->x;
fix_nve_sphere.cpp:  double **v = atom->v;
fix_nve_sphere.cpp:  double **f = atom->f;
fix_nve_sphere.cpp:  double **omega = atom->omega;
fix_nve_sphere.cpp:  double **torque = atom->torque;
fix_nve_sphere.cpp:  double *radius = atom->radius;
fix_nve_sphere.cpp:  double *rmass = atom->rmass;
fix_nve_sphere.cpp:  int *mask = atom->mask;
fix_nve_sphere.cpp:  int nlocal = atom->nlocal;
fix_nve_sphere.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nve_sphere.cpp:    double **mu = atom->mu;
fix_nve_sphere.cpp:  double **v = atom->v;
fix_nve_sphere.cpp:  double **f = atom->f;
fix_nve_sphere.cpp:  double **omega = atom->omega;
fix_nve_sphere.cpp:  double **torque = atom->torque;
fix_nve_sphere.cpp:  double *rmass = atom->rmass;
fix_nve_sphere.cpp:  double *radius = atom->radius;
fix_nve_sphere.cpp:  int *mask = atom->mask;
fix_nve_sphere.cpp:  int nlocal = atom->nlocal;
fix_nve_sphere.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_nvt_sllod.cpp:  double **v = atom->v;
fix_nvt_sllod.cpp:  int *mask = atom->mask;
fix_nvt_sllod.cpp:  int nlocal = atom->nlocal;
fix_nvt_sllod.cpp:  if (igroup == atom->firstgroup) nlocal = atom->nfirst;
fix_planeforce.cpp:  double **f = atom->f;
fix_planeforce.cpp:  int *mask = atom->mask;
fix_planeforce.cpp:  int nlocal = atom->nlocal;
fix_press_berendsen.cpp:  double **x = atom->x;
fix_press_berendsen.cpp:  int *mask = atom->mask;
fix_press_berendsen.cpp:  int nlocal = atom->nlocal;
fix_property_atom.cpp:      if (atom->molecule_flag)
fix_property_atom.cpp:      atom->molecule_flag = molecule_flag = 1;
fix_property_atom.cpp:      if (atom->q_flag)
fix_property_atom.cpp:      atom->q_flag = q_flag = 1;
fix_property_atom.cpp:      if (atom->rmass_flag)
fix_property_atom.cpp:      atom->rmass_flag = rmass_flag = 1;
fix_property_atom.cpp:      index[nvalue] = atom->find_custom(&arg[iarg][2],flag,ncols);
fix_property_atom.cpp:      index[nvalue] = atom->add_custom(&arg[iarg][2],0,0);
fix_property_atom.cpp:      index[nvalue] = atom->find_custom(&arg[iarg][2],flag,ncols);
fix_property_atom.cpp:      index[nvalue] = atom->add_custom(&arg[iarg][2],1,0);
fix_property_atom.cpp:      which = atom->find_custom(&arg[iarg][3],flag,ncols);
fix_property_atom.cpp:      index[nvalue] = atom->add_custom(&arg[iarg][3],which,ncols);
fix_property_atom.cpp:  astyle = utils::strdup(atom->atom_style);
fix_property_atom.cpp:  // perform initial allocation of atom-based array
fix_property_atom.cpp:  if (!lmp->kokkos) FixPropertyAtom::grow_arrays(atom->nmax);
fix_property_atom.cpp:  atom->add_callback(Atom::GROW);
fix_property_atom.cpp:  atom->add_callback(Atom::RESTART);
fix_property_atom.cpp:  if (border) atom->add_callback(Atom::BORDER);
fix_property_atom.cpp:  atom->delete_callback(id,Atom::GROW);
fix_property_atom.cpp:  atom->delete_callback(id,Atom::RESTART);
fix_property_atom.cpp:  if (border) atom->delete_callback(id,Atom::BORDER);
fix_property_atom.cpp:      atom->molecule_flag = 0;
fix_property_atom.cpp:      memory->destroy(atom->molecule);
fix_property_atom.cpp:      atom->molecule = nullptr;
fix_property_atom.cpp:      atom->q_flag = 0;
fix_property_atom.cpp:      memory->destroy(atom->q);
fix_property_atom.cpp:      atom->q = nullptr;
fix_property_atom.cpp:      atom->rmass_flag = 0;
fix_property_atom.cpp:      memory->destroy(atom->rmass);
fix_property_atom.cpp:      atom->rmass = nullptr;
fix_property_atom.cpp:      atom->remove_custom(index[nv],0,cols[nv]);
fix_property_atom.cpp:      atom->remove_custom(index[nv],1,cols[nv]);
fix_property_atom.cpp:      atom->remove_custom(index[nv],0,cols[nv]);
fix_property_atom.cpp:      atom->remove_custom(index[nv],1,cols[nv]);
fix_property_atom.cpp:  if (strcmp(astyle,atom->atom_style) != 0)
fix_property_atom.cpp:  if (atom->map_style == Atom::MAP_NONE) {
fix_property_atom.cpp:    atom->map_init();
fix_property_atom.cpp:    atom->map_set();
fix_property_atom.cpp:  tagint map_tag_max = atom->map_tag_max;
fix_property_atom.cpp:      if ((m = atom->map(itag)) >= 0) {
fix_property_atom.cpp:            atom->molecule[m] = values.next_tagint();
fix_property_atom.cpp:            atom->q[m] = values.next_double();
fix_property_atom.cpp:            atom->rmass[m] = values.next_double();
fix_property_atom.cpp:            atom->ivector[index[j]][m] = values.next_int();
fix_property_atom.cpp:            atom->dvector[index[j]][m] = values.next_double();
fix_property_atom.cpp:              atom->iarray[index[j]][m][k] = values.next_int();
fix_property_atom.cpp:              atom->darray[index[j]][m][k] = values.next_double();
fix_property_atom.cpp:    atom->map_delete();
fix_property_atom.cpp:    atom->map_style = 0;
fix_property_atom.cpp:  return atom->natoms;
fix_property_atom.cpp:  nx = atom->nlocal;
fix_property_atom.cpp:  tagint *tag = atom->tag;
fix_property_atom.cpp:  int nlocal = atom->nlocal;
fix_property_atom.cpp:      tagint *molecule = atom->molecule;
fix_property_atom.cpp:      double *q = atom->q;
fix_property_atom.cpp:      double *rmass = atom->rmass;
fix_property_atom.cpp:      int *ivec = atom->ivector[index[nv]];
fix_property_atom.cpp:      double *dvec = atom->dvector[index[nv]];
fix_property_atom.cpp:      int **iarray = atom->iarray[index[nv]];
fix_property_atom.cpp:      double **darray = atom->darray[index[nv]];
fix_property_atom.cpp:      else if (styles[i] == IVEC) fprintf(fp," i_%s", atom->ivname[index[i]]);
fix_property_atom.cpp:      else if (styles[i] == DVEC) fprintf(fp, " d_%s", atom->dvname[index[i]]);
fix_property_atom.cpp:      else if (styles[i] == IARRAY) fprintf(fp, " i_%s", atom->ianame[index[i]]);
fix_property_atom.cpp:      else if (styles[i] == DARRAY) fprintf(fp, " d_%s", atom->daname[index[i]]);
fix_property_atom.cpp:   memory usage of local atom-based array
fix_property_atom.cpp:    if (styles[m] == MOLECULE) bytes = atom->nmax * sizeof(tagint);
fix_property_atom.cpp:    else if (styles[m] == CHARGE) bytes = atom->nmax * sizeof(double);
fix_property_atom.cpp:    else if (styles[m] == RMASS) bytes = atom->nmax * sizeof(double);
fix_property_atom.cpp:    else if (styles[m] == IVEC) bytes = atom->nmax * sizeof(int);
fix_property_atom.cpp:    else if (styles[m] == DVEC) bytes = atom->nmax * sizeof(double);
fix_property_atom.cpp:    else if (styles[m] == IARRAY) bytes = (size_t) atom->nmax * cols[m] * sizeof(int);
fix_property_atom.cpp:    else if (styles[m] == DARRAY) bytes = (size_t) atom->nmax * cols[m] * sizeof(double);
fix_property_atom.cpp:   allocate atom-based arrays
fix_property_atom.cpp:      memory->grow(atom->molecule,nmax,"atom:molecule");
fix_property_atom.cpp:      memset(&atom->molecule[nmax_old],0,nbytes);
fix_property_atom.cpp:      memory->grow(atom->q,nmax,"atom:q");
fix_property_atom.cpp:      memset(&atom->q[nmax_old],0,nbytes);
fix_property_atom.cpp:      memory->grow(atom->rmass,nmax,"atom:rmass");
fix_property_atom.cpp:      memset(&atom->rmass[nmax_old],0,nbytes);
fix_property_atom.cpp:      memory->grow(atom->ivector[index[nv]],nmax,"atom:ivector");
fix_property_atom.cpp:      memset(&atom->ivector[index[nv]][nmax_old],0,nbytes);
fix_property_atom.cpp:      memory->grow(atom->dvector[index[nv]],nmax,"atom:dvector");
fix_property_atom.cpp:      memset(&atom->dvector[index[nv]][nmax_old],0,nbytes);
fix_property_atom.cpp:      memory->grow(atom->iarray[index[nv]],nmax,cols[nv],"atom:iarray");
fix_property_atom.cpp:      if (nbytes) memset(&atom->iarray[index[nv]][nmax_old][0],0,nbytes);
fix_property_atom.cpp:      memory->grow(atom->darray[index[nv]],nmax,cols[nv],"atom:darray");
fix_property_atom.cpp:      if (nbytes) memset(&atom->darray[index[nv]][nmax_old][0],0,nbytes);
fix_property_atom.cpp:   copy values within local atom-based arrays
fix_property_atom.cpp:      atom->molecule[j] = atom->molecule[i];
fix_property_atom.cpp:      atom->q[j] = atom->q[i];
fix_property_atom.cpp:      atom->rmass[j] = atom->rmass[i];
fix_property_atom.cpp:      atom->ivector[index[nv]][j] = atom->ivector[index[nv]][i];
fix_property_atom.cpp:      atom->dvector[index[nv]][j] = atom->dvector[index[nv]][i];
fix_property_atom.cpp:        atom->iarray[index[nv]][j][k] = atom->iarray[index[nv]][i][k];
fix_property_atom.cpp:        atom->darray[index[nv]][j][k] = atom->darray[index[nv]][i][k];
fix_property_atom.cpp:      tagint *molecule = atom->molecule;
fix_property_atom.cpp:      double *q = atom->q;
fix_property_atom.cpp:      double *rmass = atom->rmass;
fix_property_atom.cpp:      int *ivector = atom->ivector[index[nv]];
fix_property_atom.cpp:      double *dvector = atom->dvector[index[nv]];
fix_property_atom.cpp:      int **iarray = atom->iarray[index[nv]];
fix_property_atom.cpp:      double **darray = atom->darray[index[nv]];
fix_property_atom.cpp:      tagint *molecule = atom->molecule;
fix_property_atom.cpp:      double *q = atom->q;
fix_property_atom.cpp:      double *rmass = atom->rmass;
fix_property_atom.cpp:      int *ivector = atom->ivector[index[nv]];
fix_property_atom.cpp:      double *dvector = atom->dvector[index[nv]];
fix_property_atom.cpp:      int **iarray = atom->iarray[index[nv]];
fix_property_atom.cpp:      double **darray = atom->darray[index[nv]];
fix_property_atom.cpp:   pack values in local atom-based array for exchange with another proc
fix_property_atom.cpp:    if (styles[nv] == MOLECULE) buf[m++] = ubuf(atom->molecule[i]).d;
fix_property_atom.cpp:    else if (styles[nv] == CHARGE) buf[m++] = atom->q[i];
fix_property_atom.cpp:    else if (styles[nv] == RMASS) buf[m++] = atom->rmass[i];
fix_property_atom.cpp:    else if (styles[nv] == IVEC) buf[m++] = ubuf(atom->ivector[index[nv]][i]).d;
fix_property_atom.cpp:    else if (styles[nv] == DVEC) buf[m++] = atom->dvector[index[nv]][i];
fix_property_atom.cpp:        buf[m++] = ubuf(atom->iarray[index[nv]][i][k]).d;
fix_property_atom.cpp:        buf[m++] = atom->darray[index[nv]][i][k];
fix_property_atom.cpp:   unpack values in local atom-based array from exchange with another proc
fix_property_atom.cpp:      atom->molecule[nlocal] = (tagint) ubuf(buf[m++]).i;
fix_property_atom.cpp:      atom->q[nlocal] = buf[m++];
fix_property_atom.cpp:      atom->rmass[nlocal] = buf[m++];
fix_property_atom.cpp:      atom->ivector[index[nv]][nlocal] = (int) ubuf(buf[m++]).i;
fix_property_atom.cpp:      atom->dvector[index[nv]][nlocal] = buf[m++];
fix_property_atom.cpp:        atom->iarray[index[nv]][nlocal][k] = (int) ubuf(buf[m++]).i;
fix_property_atom.cpp:        atom->darray[index[nv]][nlocal][k] = buf[m++];
fix_property_atom.cpp:   pack values in local atom-based arrays for restart file
fix_property_atom.cpp:    if (styles[nv] == MOLECULE) buf[m++] = ubuf(atom->molecule[i]).d;
fix_property_atom.cpp:    else if (styles[nv] == CHARGE) buf[m++] = atom->q[i];
fix_property_atom.cpp:    else if (styles[nv] == RMASS) buf[m++] = atom->rmass[i];
fix_property_atom.cpp:    else if (styles[nv] == IVEC) buf[m++] = ubuf(atom->ivector[index[nv]][i]).d;
fix_property_atom.cpp:    else if (styles[nv] == DVEC) buf[m++] = atom->dvector[index[nv]][i];
fix_property_atom.cpp:        buf[m++] = ubuf(atom->iarray[index[nv]][i][k]).d;
fix_property_atom.cpp:        buf[m++] = atom->darray[index[nv]][i][k];
fix_property_atom.cpp:   unpack values from atom->extra array to restart the fix
fix_property_atom.cpp:  double **extra = atom->extra;
fix_property_atom.cpp:      atom->molecule[nlocal] = (tagint) ubuf(extra[nlocal][m++]).i;
fix_property_atom.cpp:      atom->q[nlocal] = extra[nlocal][m++];
fix_property_atom.cpp:      atom->rmass[nlocal] = extra[nlocal][m++];
fix_property_atom.cpp:      atom->ivector[index[nv]][nlocal] = (int) ubuf(extra[nlocal][m++]).i;
fix_property_atom.cpp:      atom->dvector[index[nv]][nlocal] = extra[nlocal][m++];
fix_property_atom.cpp:        atom->iarray[index[nv]][nlocal][k] = (int) ubuf(extra[nlocal][m++]).i;
fix_property_atom.cpp:        atom->darray[index[nv]][nlocal][k] = extra[nlocal][m++];
fix_read_restart.cpp:  // perform initial allocation of atom-based array
fix_read_restart.cpp:  FixReadRestart::grow_arrays(atom->nmax);
fix_read_restart.cpp:  atom->add_callback(Atom::GROW);
fix_read_restart.cpp:  // extra = copy of atom->extra
fix_read_restart.cpp:  double **atom_extra = atom->extra;
fix_read_restart.cpp:  int nlocal = atom->nlocal;
fix_read_restart.cpp:  atom->delete_callback(id,Atom::GROW);
fix_read_restart.cpp:   memory usage of local atom-based array
fix_read_restart.cpp:  double bytes = (double)atom->nmax*nextra * sizeof(double);
fix_read_restart.cpp:  bytes += (double)atom->nmax * sizeof(int);
fix_read_restart.cpp:   allocate atom-based array
fix_read_restart.cpp:   copy values within local atom-based array
fix_read_restart.cpp:   pack values in local atom-based array for exchange with another proc
fix_read_restart.cpp:   unpack values in local atom-based array from exchange with another proc
fix_recenter.cpp:  double **x = atom->x;
fix_recenter.cpp:  int *mask = atom->mask;
fix_recenter.cpp:  int nlocal = atom->nlocal;
fix_respa.cpp:  // perform initial allocation of atom-based arrays
fix_respa.cpp:  FixRespa::grow_arrays(atom->nmax);
fix_respa.cpp:  atom->add_callback(Atom::GROW);
fix_respa.cpp:  atom->delete_callback(id,Atom::GROW);
fix_respa.cpp:   memory usage of local atom-based arrays
fix_respa.cpp:  double bytes = (double)atom->nmax*nlevels*3 * sizeof(double);
fix_respa.cpp:  if (store_torque) bytes += (double)atom->nmax*nlevels*3 * sizeof(double);
fix_respa.cpp:   allocate local atom-based arrays
fix_respa.cpp:   copy values within local atom-based arrays
fix_respa.cpp:   pack values in local atom-based arrays for exchange with another proc
fix_respa.cpp:   unpack values in local atom-based arrays from exchange with another proc
fix_restrain.cpp:  if (atom->map_style == Atom::MAP_NONE)
fix_restrain.cpp:  double **x = atom->x;
fix_restrain.cpp:  double **f = atom->f;
fix_restrain.cpp:  int nlocal = atom->nlocal;
fix_restrain.cpp:  i1 = atom->map(ids[m][0]);
fix_restrain.cpp:  i2 = atom->map(ids[m][1]);
fix_restrain.cpp:  double **x = atom->x;
fix_restrain.cpp:  double **f = atom->f;
fix_restrain.cpp:  int nlocal = atom->nlocal;
fix_restrain.cpp:  i1 = atom->map(ids[m][0]);
fix_restrain.cpp:  i2 = atom->map(ids[m][1]);
fix_restrain.cpp:  double **x = atom->x;
fix_restrain.cpp:  double **f = atom->f;
fix_restrain.cpp:  int nlocal = atom->nlocal;
fix_restrain.cpp:  i1 = atom->map(ids[m][0]);
fix_restrain.cpp:  i2 = atom->map(ids[m][1]);
fix_restrain.cpp:  i3 = atom->map(ids[m][2]);
fix_restrain.cpp:  double **x = atom->x;
fix_restrain.cpp:  double **f = atom->f;
fix_restrain.cpp:  int nlocal = atom->nlocal;
fix_restrain.cpp:  i1 = atom->map(ids[m][0]);
fix_restrain.cpp:  i2 = atom->map(ids[m][1]);
fix_restrain.cpp:  i3 = atom->map(ids[m][2]);
fix_restrain.cpp:  i4 = atom->map(ids[m][3]);
fix_restrain.cpp:                                    me,update->ntimestep,atom->tag[i1],
fix_restrain.cpp:                                    atom->tag[i2],atom->tag[i3],atom->tag[i4]);
fix_setforce.cpp:  double **x = atom->x;
fix_setforce.cpp:  double **f = atom->f;
fix_setforce.cpp:  int *mask = atom->mask;
fix_setforce.cpp:  int nlocal = atom->nlocal;
fix_setforce.cpp:  if (varflag == ATOM && atom->nmax > maxatom) {
fix_setforce.cpp:    maxatom = atom->nmax;
fix_setforce.cpp:    double **x = atom->x;
fix_setforce.cpp:    double **f = atom->f;
fix_setforce.cpp:    int *mask = atom->mask;
fix_setforce.cpp:    int nlocal = atom->nlocal;
fix_setforce.cpp:   memory usage of local atom-based array
fix_spfr.cpp:  double *af = atom->af;
fix_spfr.cpp:  int *mol = atom->molecule;
fix_spfr.cpp:  int nlocal = atom->nlocal;
fix_spfr.cpp:  double **x = atom->x;
fix_spfr.cpp:  double **mu = atom->mu;
fix_spfr.cpp:  double **nmu = atom->nmu;
fix_spfr.cpp:  double **amu = atom->amu;
fix_spfr.cpp:  double *af = atom->af;
fix_spfr.cpp:  int *mid = atom->molecule;
fix_spfr.cpp:  int *id = atom->id;
fix_spfr.cpp:  int *type = atom->type;
fix_spfr.cpp:  int nlocal = atom->nlocal;
fix_spring_chunk.cpp:  double **f = atom->f;
fix_spring_chunk.cpp:  int *type = atom->type;
fix_spring_chunk.cpp:  double *mass = atom->mass;
fix_spring_chunk.cpp:  double *rmass = atom->rmass;
fix_spring_chunk.cpp:  int nlocal = atom->nlocal;
fix_spring.cpp:  double **f = atom->f;
fix_spring.cpp:  int *mask = atom->mask;
fix_spring.cpp:  int *type = atom->type;
fix_spring.cpp:  double *mass = atom->mass;
fix_spring.cpp:  double *rmass = atom->rmass;
fix_spring.cpp:  int nlocal = atom->nlocal;
fix_spring.cpp:  double **f = atom->f;
fix_spring.cpp:  int *mask = atom->mask;
fix_spring.cpp:  int *type = atom->type;
fix_spring.cpp:  double *mass = atom->mass;
fix_spring.cpp:  double *rmass = atom->rmass;
fix_spring.cpp:  int nlocal = atom->nlocal;
fix_spring_self.cpp:  // perform initial allocation of atom-based array
fix_spring_self.cpp:  FixSpringSelf::grow_arrays(atom->nmax);
fix_spring_self.cpp:  atom->add_callback(Atom::GROW);
fix_spring_self.cpp:  atom->add_callback(Atom::RESTART);
fix_spring_self.cpp:  double **x = atom->x;
fix_spring_self.cpp:  int *mask = atom->mask;
fix_spring_self.cpp:  imageint *image = atom->image;
fix_spring_self.cpp:  int nlocal = atom->nlocal;
fix_spring_self.cpp:  atom->delete_callback(id,Atom::GROW);
fix_spring_self.cpp:  atom->delete_callback(id,Atom::RESTART);
fix_spring_self.cpp:  double **x = atom->x;
fix_spring_self.cpp:  double **f = atom->f;
fix_spring_self.cpp:  int *mask = atom->mask;
fix_spring_self.cpp:  imageint *image = atom->image;
fix_spring_self.cpp:  int nlocal = atom->nlocal;
fix_spring_self.cpp:   memory usage of local atom-based array
fix_spring_self.cpp:  double bytes = (double)atom->nmax*3 * sizeof(double);
fix_spring_self.cpp:   allocate atom-based array
fix_spring_self.cpp:   copy values within local atom-based array
fix_spring_self.cpp:   pack values in local atom-based array for exchange with another proc
fix_spring_self.cpp:   unpack values in local atom-based array from exchange with another proc
fix_spring_self.cpp:   pack values in local atom-based arrays for restart file
fix_spring_self.cpp:   unpack values from atom->extra array to restart the fix
fix_spring_self.cpp:  double **extra = atom->extra;
fix_store.cpp:    FixStore::grow_arrays(atom->nmax);
fix_store.cpp:    atom->add_callback(Atom::GROW);
fix_store.cpp:    if (restart_peratom) atom->add_callback(Atom::RESTART);
fix_store.cpp:    int nlocal = atom->nlocal;
fix_store.cpp:    atom->delete_callback(id,Atom::GROW);
fix_store.cpp:    if (restart_peratom) atom->delete_callback(id,Atom::RESTART);
fix_store.cpp:   allocate atom-based array
fix_store.cpp:   copy values within local atom-based array
fix_store.cpp:   pack values in local atom-based array for exchange with another proc
fix_store.cpp:   unpack values in local atom-based array from exchange with another proc
fix_store.cpp:   pack values in local atom-based arrays for restart file
fix_store.cpp:   unpack values from atom->extra array to restart the fix
fix_store.cpp:  double **extra = atom->extra;
fix_store.cpp:   memory usage of local atom-based array
fix_store.cpp:  if (flavor == PERATOM) bytes += (double)atom->nmax*nvalues * sizeof(double);
fix_store_force.cpp:  nmax = atom->nmax;
fix_store_force.cpp:  int nlocal = atom->nlocal;
fix_store_force.cpp:  if (atom->nmax > nmax) {
fix_store_force.cpp:    nmax = atom->nmax;
fix_store_force.cpp:  double **f = atom->f;
fix_store_force.cpp:  int *mask = atom->mask;
fix_store_force.cpp:  int nlocal = atom->nlocal;
fix_store_force.cpp:   memory usage of local atom-based array
fix_store_force.cpp:  double bytes = (double)atom->nmax*3 * sizeof(double);
fix_store_state.cpp:      if (!atom->molecule_flag)
fix_store_state.cpp:      if (!atom->q_flag)
fix_store_state.cpp:      if (!atom->mu_flag)
fix_store_state.cpp:      if (!atom->mu_flag)
fix_store_state.cpp:      if (!atom->mu_flag)
fix_store_state.cpp:      if (!atom->mu_flag)
fix_store_state.cpp:      if (!atom->radius_flag)
fix_store_state.cpp:      if (!atom->radius_flag)
fix_store_state.cpp:      if (!atom->omega_flag)
fix_store_state.cpp:      if (!atom->omega_flag)
fix_store_state.cpp:      if (!atom->omega_flag)
fix_store_state.cpp:      if (!atom->angmom_flag)
fix_store_state.cpp:      if (!atom->angmom_flag)
fix_store_state.cpp:      if (!atom->angmom_flag)
fix_store_state.cpp:      if (!atom->torque_flag)
fix_store_state.cpp:      if (!atom->torque_flag)
fix_store_state.cpp:      if (!atom->torque_flag)
fix_store_state.cpp:        error->all(FLERR,"Fix store/state variable is not atom-style variable");
fix_store_state.cpp:      icustom = atom->find_custom(ids[i],iflag,icol);
fix_store_state.cpp:        if (argindex[i] > atom->dcols[icustom])
fix_store_state.cpp:      icustom = atom->find_custom(ids[i],iflag,icol);
fix_store_state.cpp:        if (argindex[i] > atom->icols[icustom])
fix_store_state.cpp:  // perform initial allocation of atom-based array
fix_store_state.cpp:  FixStoreState::grow_arrays(atom->nmax);
fix_store_state.cpp:  atom->add_callback(Atom::GROW);
fix_store_state.cpp:  atom->add_callback(Atom::RESTART);
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  atom->delete_callback(id,Atom::GROW);
fix_store_state.cpp:  atom->delete_callback(id,Atom::RESTART);
fix_store_state.cpp:      icustom = atom->find_custom(ids[m],iflag,cols);
fix_store_state.cpp:      int *mask = atom->mask;
fix_store_state.cpp:      int nlocal = atom->nlocal;
fix_store_state.cpp:      // evaluate atom-style variable
fix_store_state.cpp:          double *dvector = atom->dvector[n];
fix_store_state.cpp:          double **darray = atom->darray[n];
fix_store_state.cpp:          int *ivector = atom->ivector[n];
fix_store_state.cpp:          int **iarray = atom->iarray[n];
fix_store_state.cpp:   memory usage of local atom-based array
fix_store_state.cpp:  double bytes = (double)atom->nmax*nvalues * sizeof(double);
fix_store_state.cpp:   allocate atom-based array
fix_store_state.cpp:   copy values within local atom-based array
fix_store_state.cpp:   pack values in local atom-based array for exchange with another proc
fix_store_state.cpp:   unpack values in local atom-based array from exchange with another proc
fix_store_state.cpp:   pack values in local atom-based arrays for restart file
fix_store_state.cpp:   unpack values from atom->extra array to restart the fix
fix_store_state.cpp:  double **extra = atom->extra;
fix_store_state.cpp:  tagint *tag = atom->tag;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  tagint *molecule = atom->molecule;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  int *type = atom->type;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  int *type = atom->type;
fix_store_state.cpp:  double *mass = atom->mass;
fix_store_state.cpp:  double *rmass = atom->rmass;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **x = atom->x;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  imageint *image = atom->image;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **v = atom->v;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **v = atom->v;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **v = atom->v;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **f = atom->f;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **f = atom->f;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **f = atom->f;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double *q = atom->q;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **mu = atom->mu;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **mu = atom->mu;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **mu = atom->mu;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **mu = atom->mu;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double *radius = atom->radius;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double *radius = atom->radius;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **omega = atom->omega;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **omega = atom->omega;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **omega = atom->omega;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **angmom = atom->angmom;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **angmom = atom->angmom;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **angmom = atom->angmom;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **torque = atom->torque;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **torque = atom->torque;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_store_state.cpp:  double **torque = atom->torque;
fix_store_state.cpp:  int *mask = atom->mask;
fix_store_state.cpp:  int nlocal = atom->nlocal;
fix_temp_berendsen.cpp:  double **v = atom->v;
fix_temp_berendsen.cpp:  int *mask = atom->mask;
fix_temp_berendsen.cpp:  int nlocal = atom->nlocal;
fix_temp_rescale.cpp:    double **v = atom->v;
fix_temp_rescale.cpp:    int *mask = atom->mask;
fix_temp_rescale.cpp:    int nlocal = atom->nlocal;
fix_thermal_conductivity.cpp:  double **x = atom->x;
fix_thermal_conductivity.cpp:  double **v = atom->v;
fix_thermal_conductivity.cpp:  double *mass = atom->mass;
fix_thermal_conductivity.cpp:  double *rmass = atom->rmass;
fix_thermal_conductivity.cpp:  int *type = atom->type;
fix_thermal_conductivity.cpp:  int *mask = atom->mask;
fix_thermal_conductivity.cpp:  int nlocal = atom->nlocal;
fix_viscous.cpp:  gamma = new double[atom->ntypes+1];
fix_viscous.cpp:  for (int i = 1; i <= atom->ntypes; i++) gamma[i] = gamma_one;
fix_viscous.cpp:      if (itype <= 0 || itype > atom->ntypes)
fix_viscous.cpp:  double **v = atom->v;
fix_viscous.cpp:  double **f = atom->f;
fix_viscous.cpp:  int *mask = atom->mask;
fix_viscous.cpp:  int *type = atom->type;
fix_viscous.cpp:  int nlocal = atom->nlocal;
fix_wall_harmonic.cpp:  double **x = atom->x;
fix_wall_harmonic.cpp:  double **f = atom->f;
fix_wall_harmonic.cpp:  int *mask = atom->mask;
fix_wall_harmonic.cpp:  int nlocal = atom->nlocal;
fix_wall_lj1043.cpp:  double **x = atom->x;
fix_wall_lj1043.cpp:  double **f = atom->f;
fix_wall_lj1043.cpp:  int *mask = atom->mask;
fix_wall_lj1043.cpp:  int nlocal = atom->nlocal;
fix_wall_lj126.cpp:  double **x = atom->x;
fix_wall_lj126.cpp:  double **f = atom->f;
fix_wall_lj126.cpp:  int *mask = atom->mask;
fix_wall_lj126.cpp:  int nlocal = atom->nlocal;
fix_wall_lj93.cpp:  double **x = atom->x;
fix_wall_lj93.cpp:  double **f = atom->f;
fix_wall_lj93.cpp:  int *mask = atom->mask;
fix_wall_lj93.cpp:  int nlocal = atom->nlocal;
fix_wall_morse.cpp:  double **x = atom->x;
fix_wall_morse.cpp:  double **f = atom->f;
fix_wall_morse.cpp:  int *mask = atom->mask;
fix_wall_morse.cpp:  int nlocal = atom->nlocal;
fix_wall_reflect.cpp:  double **x = atom->x;
fix_wall_reflect.cpp:  double **v = atom->v;
fix_wall_reflect.cpp:  int *mask = atom->mask;
fix_wall_reflect.cpp:  int nlocal = atom->nlocal;
fix_wall_region.cpp:    if (!atom->sphere_flag)
fix_wall_region.cpp:    double *radius = atom->radius;
fix_wall_region.cpp:    int *mask = atom->mask;
fix_wall_region.cpp:    int nlocal = atom->nlocal;
fix_wall_region.cpp:  double **x = atom->x;
fix_wall_region.cpp:  double **f = atom->f;
fix_wall_region.cpp:  double *radius = atom->radius;
fix_wall_region.cpp:  int *mask = atom->mask;
fix_wall_region.cpp:  int nlocal = atom->nlocal;
force.cpp:    if (!bond && (atom->nbonds > 0)) {
force.cpp:    if (!angle && (atom->nangles > 0)) {
force.cpp:    if (!dihedral && (atom->ndihedrals > 0)) {
force.cpp:    if (!improper && (atom->nimpropers > 0))
group.cpp:    if (atom->firstgroupname && strcmp(arg[0],atom->firstgroupname) == 0)
group.cpp:    int *mask = atom->mask;
group.cpp:    int nlocal = atom->nlocal;
group.cpp:    int *mask = atom->mask;
group.cpp:    int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:      if ((category == MOLECULE) && (!atom->molecule_flag))
group.cpp:      if ((category == ID) && (!atom->tag_enable))
group.cpp:        if (category == TYPE) attribute = atom->type;
group.cpp:        else if (category == MOLECULE) tattribute = atom->molecule;
group.cpp:        else if (category == ID) tattribute = atom->tag;
group.cpp:        if (category == TYPE) attribute = atom->type;
group.cpp:        else if (category == MOLECULE) tattribute = atom->molecule;
group.cpp:        else if (category == ID) tattribute = atom->tag;
group.cpp:    // add to group if atom-atyle variable is non-zero
group.cpp:        if (!atom->molecule_flag)
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  tagint *molecule = atom->molecule;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  int nlocal = gptr->atom->nlocal;
group.cpp:  tagint *molecule = gptr->atom->molecule;
group.cpp:  int *mask = gptr->atom->mask;
group.cpp:  bigint nme = atom->nlocal;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double *q = atom->q;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double *q = atom->q;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **v = atom->v;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double **v = atom->v;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **f = atom->f;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double **f = atom->f;
group.cpp:  int *mask = atom->mask;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **v = atom->v;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double **v = atom->v;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double **v = atom->v;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double **v = atom->v;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double **f = atom->f;
group.cpp:  int *mask = atom->mask;
group.cpp:  imageint *image = atom->image;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  double **f = atom->f;
group.cpp:  int *mask = atom->mask;
group.cpp:  imageint *image = atom->image;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
group.cpp:  double **x = atom->x;
group.cpp:  int *mask = atom->mask;
group.cpp:  int *type = atom->type;
group.cpp:  imageint *image = atom->image;
group.cpp:  double *mass = atom->mass;
group.cpp:  double *rmass = atom->rmass;
group.cpp:  int nlocal = atom->nlocal;
imbalance_group.cpp:  const int *const mask = atom->mask;
imbalance_group.cpp:  const int nlocal = atom->nlocal;
imbalance_neigh.cpp:  int nlocal = atom->nlocal;
imbalance_store.cpp:  int index = atom->find_custom(name, flag, cols);
imbalance_store.cpp:  double *prop = atom->dvector[index];
imbalance_store.cpp:  const int nlocal = atom->nlocal;
imbalance_time.cpp:  int nlocal = atom->nlocal;
imbalance_var.cpp:  const int nlocal = atom->nlocal;
improper.cpp:  if (!allocated && atom->nimpropertypes)
improper.cpp:  for (int i = 1; i <= atom->nimpropertypes; i++)
improper.cpp:  if (eflag_atom && atom->nmax > maxeatom) {
improper.cpp:    maxeatom = atom->nmax;
improper.cpp:  if (vflag_atom && atom->nmax > maxvatom) {
improper.cpp:    maxvatom = atom->nmax;
improper.cpp:  if (cvflag_atom && atom->nmax > maxcvatom) {
improper.cpp:    maxcvatom = atom->nmax;
improper.cpp:    n = atom->nlocal;
improper.cpp:    if (force->newton_bond) n += atom->nghost;
improper.cpp:    n = atom->nlocal;
improper.cpp:    if (force->newton_bond) n += atom->nghost;
improper.cpp:    n = atom->nlocal;
improper.cpp:    if (force->newton_bond) n += atom->nghost;
improper.cpp:  const auto x = atom->x;
improper.cpp:                          comm->me, update->ntimestep, atom->tag[i1],
improper.cpp:                          atom->tag[i2], atom->tag[i3], atom->tag[i4]);
improper_hybrid.cpp:    const bigint nall = atom->nlocal + atom->nghost;
improper_hybrid.cpp:      n = atom->nlocal;
improper_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
improper_hybrid.cpp:      n = atom->nlocal;
improper_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
improper_hybrid.cpp:      n = atom->nlocal;
improper_hybrid.cpp:      if (force->newton_bond) n += atom->nghost;
improper_hybrid.cpp:  int n = atom->nimpropertypes;
improper_hybrid.cpp:  utils::bounds(FLERR, arg[0], 1, atom->nimpropertypes, ilo, ihi, error);
improper_zero.cpp:  int n = atom->nimpropertypes;
improper_zero.cpp:  utils::bounds(FLERR,arg[0],1,atom->nimpropertypes,ilo,ihi,error);
improper_zero.cpp:  for (int i = 1; i <= atom->nimpropertypes; i++) setflag[i] = 1;
improper_zero.cpp:  for (int i = 1; i <= atom->nimpropertypes; i++)
info.cpp:        for (int i=1; i <= atom->ntypes && neighbor->cuttype; ++i) {
info.cpp:    fmt::print(out,"Atom style    = {}\n", atom->atom_style);
info.cpp:    fmt::print(out,"Atom map      = {}\n", mapstyles[atom->map_style]);
info.cpp:    if (atom->molecular != Atom::ATOMIC) {
info.cpp:      msg = (atom->molecular == Atom::TEMPLATE) ? "template" : "standard";
info.cpp:               atom->natoms, atom->ntypes, force->pair_style);
info.cpp:    if (atom->molecular != Atom::ATOMIC) {
info.cpp:                 atom->nbonds, atom->nbondtypes, msg);
info.cpp:                 atom->nangles, atom->nangletypes, msg);
info.cpp:                 atom->ndihedrals, atom->ndihedraltypes, msg);
info.cpp:                 atom->nimpropers, atom->nimpropertypes, msg);
info.cpp:      for (int i=1; i <= atom->ntypes; ++i)
info.cpp:        for (int j=i; j <= atom->ntypes; ++j) {
info.cpp:        for (int i=1; i <= atom->nbondtypes; ++i) {
info.cpp:        for (int i=1; i <= atom->nangletypes; ++i) {
info.cpp:        for (int i=1; i <= atom->ndihedraltypes; ++i) {
info.cpp:        for (int i=1; i <= atom->nimpropertypes; ++i) {
info.cpp:  print_columns(out, atom->avec_map);
info.cpp:    style = atom->atom_style;
info.cpp:    return find_style(lmp, atom->avec_map, name, false);
info.cpp:    return get_style_names(atom->avec_map);
info.cpp:    bytes += atom->memory_usage();
input.cpp:  if (atom->avec->angles_allow == 0)
input.cpp:  if (atom->avec->angles_allow == 0)
input.cpp:  atom->modify_params(narg,arg);
input.cpp:  atom->create_avec(arg[0],narg-1,&arg[1],1);
input.cpp:  if (atom->avec->bonds_allow == 0)
input.cpp:  if (atom->avec->bonds_allow == 0)
input.cpp:  if (atom->avec->bonds_allow == 0)
input.cpp:  if (atom->avec->dihedrals_allow == 0)
input.cpp:  if (atom->avec->dihedrals_allow == 0)
input.cpp:  if (atom->avec->impropers_allow == 0)
input.cpp:  if (atom->avec->impropers_allow == 0)
input.cpp:  atom->set_mass(FLERR,narg,arg);
input.cpp:  atom->add_molecule(narg,arg);
input.cpp:  if (domain->box_exist && atom->molecular == Atom::MOLECULAR) {
irregular.cpp:  map_style = atom->map_style;
irregular.cpp:  if (map_style != Atom::MAP_NONE) atom->map_clear();
irregular.cpp:  atom->nghost = 0;
irregular.cpp:  atom->avec->clear_bonus();
irregular.cpp:  AtomVec *avec = atom->avec;
irregular.cpp:  double **x = atom->x;
irregular.cpp:  int nlocal = atom->nlocal;
irregular.cpp:  atom->nlocal = nlocal;
irregular.cpp:  if (map_style) atom->map_set();
irregular.cpp:  double **x = atom->x;
irregular.cpp:  int nlocal = atom->nlocal;
irregular.cpp:  int maxexchange = atom->avec->maxexchange + maxexchange_fix;
kspace.cpp:  if (eflag_atom && atom->nmax > maxeatom) {
kspace.cpp:    maxeatom = atom->nmax;
kspace.cpp:  if (vflag_atom && atom->nmax > maxvatom) {
kspace.cpp:    maxvatom = atom->nmax;
kspace.cpp:    n = atom->nlocal;
kspace.cpp:    if (tip4pflag) n += atom->nghost;
kspace.cpp:    n = atom->nlocal;
kspace.cpp:    if (tip4pflag) n += atom->nghost;
kspace.cpp:  const double * const q = atom->q;
kspace.cpp:  const int nlocal = atom->nlocal;
lammps.cpp:    atom->create_avec("atomic/kk",0,nullptr,1);
lammps.cpp:    atom->create_avec("atomic",0,nullptr,1);
lammps.cpp:  atom->init();          // atom must come after force and domain
library.cpp:  double natoms = static_cast<double>(lmp->atom->natoms);
library.cpp:    if (lmp->atom->natoms > 0)
library.cpp:  if (strcmp(keyword,"nlocal") == 0) return lmp->atom->nlocal;
library.cpp:  if (strcmp(keyword,"nghost") == 0) return lmp->atom->nghost;
library.cpp:  if (strcmp(keyword,"nall") == 0) return lmp->atom->nlocal+lmp->atom->nghost;
library.cpp:  if (strcmp(keyword,"nmax") == 0) return lmp->atom->nmax;
library.cpp:  if (strcmp(keyword,"ntypes") == 0) return lmp->atom->ntypes;
library.cpp:  if (strcmp(keyword,"nbondtypes") == 0) return lmp->atom->nbondtypes;
library.cpp:  if (strcmp(keyword,"nangletypes") == 0) return lmp->atom->nangletypes;
library.cpp:  if (strcmp(keyword,"ndihedraltypes") == 0) return lmp->atom->ndihedraltypes;
library.cpp:  if (strcmp(keyword,"nimpropertypes") == 0) return lmp->atom->nimpropertypes;
library.cpp:  if (strcmp(keyword,"molecule_flag") == 0) return lmp->atom->molecule_flag;
library.cpp:  if (strcmp(keyword,"q_flag") == 0) return lmp->atom->q_flag;
library.cpp:  if (strcmp(keyword,"mu_flag") == 0) return lmp->atom->mu_flag;
library.cpp:  if (strcmp(keyword,"rmass_flag") == 0) return lmp->atom->rmass_flag;
library.cpp:  if (strcmp(keyword,"radius_flag") == 0) return lmp->atom->radius_flag;
library.cpp:  if (strcmp(keyword,"sphere_flag") == 0) return lmp->atom->sphere_flag;
library.cpp:  if (strcmp(keyword,"ellipsoid_flag") == 0) return lmp->atom->ellipsoid_flag;
library.cpp:  if (strcmp(keyword,"omega_flag") == 0) return lmp->atom->omega_flag;
library.cpp:  if (strcmp(keyword,"torque_flag") == 0) return lmp->atom->torque_flag;
library.cpp:  if (strcmp(keyword,"angmom_flag") == 0) return lmp->atom->angmom_flag;
library.cpp:  if (strcmp(keyword,"peri_flag") == 0) return lmp->atom->peri_flag;
library.cpp:  if (strcmp(name,"natoms") == 0) return (void *) &lmp->atom->natoms;
library.cpp:  if (strcmp(name,"ntypes") == 0) return (void *) &lmp->atom->ntypes;
library.cpp:  if (strcmp(name,"nbonds") == 0) return (void *) &lmp->atom->nbonds;
library.cpp:  if (strcmp(name,"nangles") == 0) return (void *) &lmp->atom->nangles;
library.cpp:  if (strcmp(name,"ndihedrals") == 0) return (void *) &lmp->atom->ndihedrals;
library.cpp:  if (strcmp(name,"nimpropers") == 0) return (void *) &lmp->atom->nimpropers;
library.cpp:  if (strcmp(name,"nlocal") == 0) return (void *) &lmp->atom->nlocal;
library.cpp:  if (strcmp(name,"nghost") == 0) return (void *) &lmp->atom->nghost;
library.cpp:  if (strcmp(name,"nmax") == 0) return (void *) &lmp->atom->nmax;
library.cpp:  if (strcmp(name,"q_flag") == 0) return (void *) &lmp->atom->q_flag;
library.cpp:  return lmp->atom->extract_datatype(name);
library.cpp:(and per-atom-type properties in the case of the 'mass' keyword).
library.cpp:  return lmp->atom->extract(name);
library.cpp:allocated block of storage of double of the length ``atom->nlocal``.
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:   gather the named atom-based entity for all atoms
library.cpp:   return atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0 || lmp->atom->tag_consecutive() == 0)
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    int natoms = static_cast<int> (lmp->atom->natoms);
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:      tagint *tag = lmp->atom->tag;
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:      tagint *tag = lmp->atom->tag;
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:   gather the named atom-based entity for all atoms
library.cpp:   return atom-based values in 1d data, ordered by count, then by atom
library.cpp:    if (lmp->atom->tag_enable == 0) flag = 1;
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    int natoms = static_cast<int> (lmp->atom->natoms);
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:   gather the named atom-based entity for a subset of atoms
library.cpp:   return atom-based values in 1d data, ordered by count, then by atom
library.cpp:    if (lmp->atom->tag_enable == 0) flag = 1;
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal) {
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal) {
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal) {
library.cpp:   scatter the named atom-based entity in data to all atoms
library.cpp:   data = atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0 || lmp->atom->tag_consecutive() == 0)
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    if (lmp->atom->map_style == Atom::MAP_NONE) flag = 1;
library.cpp:    int natoms = static_cast<int> (lmp->atom->natoms);
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0)
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0)
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0) {
library.cpp:   scatter the named atom-based entity in data to a subset of atoms
library.cpp:   data = atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0) flag = 1;
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    if (lmp->atom->map_style == Atom::MAP_NONE) flag = 1;
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:          if ((m = lmp->atom->map(id)) >= 0)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(id)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(id)) >= 0)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0) {
library.cpp:    int localbonds = lmp->atom->avec->pack_bond(nullptr);
library.cpp:    lmp->atom->avec->pack_bond(bonds);
library.cpp:  gather the named atom-based entity for all atoms
library.cpp:         will return error if fix/compute isn't atom-based
library.cpp:  return atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0 || lmp->atom->tag_consecutive() == 0)
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    int natoms = static_cast<int> (lmp->atom->natoms);
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:      if (utils::strmatch(name,"^[id]_")) fcid = lmp->atom->find_custom(&name[2],ltype,icol);
library.cpp:      else fcid = lmp->atom->find_custom(&name[3],ltype,icol);
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->ivector[fcid];
library.cpp:        else vptr = (void *) lmp->atom->dvector[fcid];
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->iarray[fcid];
library.cpp:        else vptr = (void *) lmp->atom->darray[fcid];
library.cpp:      tagint *tag = lmp->atom->tag;
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:      tagint *tag = lmp->atom->tag;
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:  gather the named atom-based entity for all atoms
library.cpp:         will return error if fix/compute isn't atom-based
library.cpp:  return atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0) flag = 1;
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    int natoms = static_cast<int> (lmp->atom->natoms);
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:      if (utils::strmatch(name,"^[id]_")) fcid = lmp->atom->find_custom(&name[2],ltype,icol);
library.cpp:      else fcid = lmp->atom->find_custom(&name[3],ltype,icol);
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->ivector[fcid];
library.cpp:        else vptr = (void *) lmp->atom->dvector[fcid];
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->iarray[fcid];
library.cpp:        else vptr = (void *) lmp->atom->darray[fcid];
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:  gather the named atom-based entity for all atoms
library.cpp:         will return error if fix/compute isn't atom-based
library.cpp:  return atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0) flag = 1;
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:        fcid = lmp->atom->find_custom(&name[2],ltype,icol);
library.cpp:      else fcid = lmp->atom->find_custom(&name[3],ltype,icol);
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->ivector[fcid];
library.cpp:        else vptr = (void *) lmp->atom->dvector[fcid];
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->iarray[fcid];
library.cpp:        else vptr = (void *) lmp->atom->darray[fcid];
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal) {
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal) {
library.cpp:      int nlocal = lmp->atom->nlocal;
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0 && m < nlocal) {
library.cpp:  scatter the named atom-based entity in data to all atoms
library.cpp:         will return error if fix/compute isn't atom-based
library.cpp:  return atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0 || lmp->atom->tag_consecutive() == 0)
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    if (lmp->atom->map_style == Atom::MAP_NONE) flag = 1;
library.cpp:    int natoms = static_cast<int> (lmp->atom->natoms);
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:        fcid = lmp->atom->find_custom(&name[2],ltype,icol);
library.cpp:      else fcid = lmp->atom->find_custom(&name[3],ltype,icol);
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->ivector[fcid];
library.cpp:        else vptr = (void *) lmp->atom->dvector[fcid];
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->iarray[fcid];
library.cpp:        else vptr = (void *) lmp->atom->darray[fcid];
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0)
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0)
library.cpp:          if ((m = lmp->atom->map(i+1)) >= 0) {
library.cpp:   scatter the named atom-based entity in data to a subset of atoms
library.cpp:          will return error if fix/compute doesn't isn't atom-based
library.cpp:   data = atom-based values in 1d data, ordered by count, then by atom ID
library.cpp:    if (lmp->atom->tag_enable == 0) flag = 1;
library.cpp:    if (lmp->atom->natoms > MAXSMALLINT) flag = 1;
library.cpp:    if (lmp->atom->map_style == Atom::MAP_NONE) flag = 1;
library.cpp:    void *vptr = lmp->atom->extract(name);
library.cpp:        fcid = lmp->atom->find_custom(&name[2],ltype,icol);
library.cpp:      else fcid = lmp->atom->find_custom(&name[3],ltype,icol);
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->ivector[fcid];
library.cpp:        else vptr = (void *) lmp->atom->dvector[fcid];
library.cpp:        if (ltype==0) vptr = (void *) lmp->atom->iarray[fcid];
library.cpp:        else vptr = (void *) lmp->atom->darray[fcid];
library.cpp:          if ((m = lmp->atom->map(id)) >= 0)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(id)) >= 0) {
library.cpp:          if ((m = lmp->atom->map(id)) >= 0)
library.cpp:          if ((m = lmp->atom->map(id)) >= 0) {
library.cpp:and a list of atom types.  Additionally the atom-IDs, velocities, and
library.cpp:image flags may be provided.  If atom-IDs are not provided, they will be
library.cpp:atom-ID.
library.cpp:  bigint natoms_prev = lmp->atom->natoms;
library.cpp:    if (lmp->atom->tag_enable == 0) {
library.cpp:    int nlocal = atom->nlocal;
library.cpp:      atom->avec->create_atom(type[i],xdata);
library.cpp:      if (id) atom->tag[nlocal] = id[i];
library.cpp:      else atom->tag[nlocal] = 0;
library.cpp:        atom->v[nlocal][0] = v[3*i];
library.cpp:        atom->v[nlocal][1] = v[3*i+1];
library.cpp:        atom->v[nlocal][2] = v[3*i+2];
library.cpp:      if (image) atom->image[nlocal] = image[i];
library.cpp:    if (id == nullptr) atom->tag_extend();
library.cpp:    // need to reset atom->natoms inside LAMMPS
library.cpp:    MPI_Allreduce(&ncurrent,&lmp->atom->natoms,1,MPI_LMP_BIGINT,
library.cpp:    atom->data_fix_compute_variable(nlocal_prev,nlocal);
library.cpp:    if (lmp->atom->map_style != Atom::MAP_NONE) {
library.cpp:      lmp->atom->map_init();
library.cpp:      lmp->atom->map_set();
library.cpp:  return (int) lmp->atom->natoms - natoms_prev;
library.cpp:    int nmolecule = lmp->atom->nmolecule;
library.cpp:    Molecule **molecule = lmp->atom->molecules;
library.cpp:    return lmp->atom->nmolecule;
library.cpp:    if ((idx >=0) && (idx < lmp->atom->nmolecule)) {
library.cpp:      strncpy(buffer, lmp->atom->molecules[idx]->id, buf_size);
min_cg.cpp:    // line minimization along direction h from current atom->x
min.cpp:  // create fix needed for storing atom-based quantities
min.cpp:  if (atom->torque_flag) torqueflag = 1;
min.cpp:  if (atom->avec->forceclearflag) extraflag = 1;
min.cpp:  bigint ndofme = 3 * static_cast<bigint>(atom->nlocal);
min.cpp:    ndofme += extra_peratom[m]*static_cast<bigint>(atom->nlocal);
min.cpp:  atom->setup();
min.cpp:  if (triclinic) domain->x2lamda(atom->nlocal);
min.cpp:  if (atom->sortfreq > 0) atom->sort();
min.cpp:  if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
min.cpp:  if (atom->molecular != Atom::ATOMIC) {
min.cpp:  if (output->thermo->normflag) ecurrent /= atom->natoms;
min.cpp:    if (triclinic) domain->x2lamda(atom->nlocal);
min.cpp:    if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
min.cpp:  if (atom->molecular != Atom::ATOMIC) {
min.cpp:  if (output->thermo->normflag) ecurrent /= atom->natoms;
min.cpp:   return negative gradient stored in atom->f
min.cpp:    if (triclinic) domain->x2lamda(atom->nlocal);
min.cpp:    if (atom->sortfreq > 0 &&
min.cpp:        update->ntimestep >= atom->nextsort) atom->sort();
min.cpp:    if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
min.cpp:  if (atom->molecular != Atom::ATOMIC) {
min.cpp:  if (output->thermo->normflag) energy /= atom->natoms;
min.cpp:  size_t nbytes = sizeof(double) * atom->nlocal;
min.cpp:  if (force->newton) nbytes += sizeof(double) * atom->nghost;
min.cpp:    memset(&atom->f[0][0],0,3*nbytes);
min.cpp:    if (torqueflag) memset(&atom->torque[0][0],0,3*nbytes);
min.cpp:    if (extraflag) atom->avec->force_clear(0,nbytes);
min.cpp:  return nextra_atom-1;
min.cpp:  int nlocal = atom->nlocal;
min.cpp:  double **sp = atom->sp;
min.cpp:  double **fm = atom->fm;
min.cpp:  int nlocal = atom->nlocal;
min.cpp:  double **sp = atom->sp;
min.cpp:  double **fm = atom->fm;
min.cpp:  int nlocal = atom->nlocal;
min.cpp:  double **sp = atom->sp;
min.cpp:  double **fm = atom->fm;
min_fire.cpp:  double **v = atom->v;
min_fire.cpp:  int nlocal = atom->nlocal;
min_fire.cpp:  nvec = 3 * atom->nlocal;
min_fire.cpp:  if (nvec) xvec = atom->x[0];
min_fire.cpp:  if (nvec) fvec = atom->f[0];
min_fire.cpp:    double **f = atom->f;
min_fire.cpp:    double **v = atom->v;
min_fire.cpp:    double *rmass = atom->rmass;
min_fire.cpp:    double *mass = atom->mass;
min_fire.cpp:    int *type = atom->type;
min_fire.cpp:    int nlocal = atom->nlocal;
min_fire.cpp:    int nlocal = atom->nlocal;
min_fire.cpp:    double **v = atom->v;
min_fire.cpp:    double **f = atom->f;
min_fire.cpp:    double **x = atom->x;
min_fire.cpp:    double *rmass = atom->rmass;
min_fire.cpp:    double *mass = atom->mass;
min_fire.cpp:    int *type = atom->type;
min_fire_old.cpp:  double **v = atom->v;
min_fire_old.cpp:  int nlocal = atom->nlocal;
min_fire_old.cpp:  nvec = 3 * atom->nlocal;
min_fire_old.cpp:  if (nvec) xvec = atom->x[0];
min_fire_old.cpp:  if (nvec) fvec = atom->f[0];
min_fire_old.cpp:    double **v = atom->v;
min_fire_old.cpp:    double **f = atom->f;
min_fire_old.cpp:    int nlocal = atom->nlocal;
min_fire_old.cpp:    double *rmass = atom->rmass;
min_fire_old.cpp:    double *mass = atom->mass;
min_fire_old.cpp:    int *type = atom->type;
min_fire_old.cpp:    double **x = atom->x;
min_hftn.cpp:  nvec = 3 * atom->nlocal;
min_hftn.cpp:    xvec = atom->x[0];
min_hftn.cpp:    fvec = atom->f[0];
min_hftn.cpp:      extra_nlen[m] = extra_peratom[m] * atom->nlocal;
min_hftn.cpp:     atom->x  - positions at output x
min_hftn.cpp:     atom->f  - forces evaluated at output x
min_hftn.cpp:     atom->x   - positions at x
min_hftn.cpp:     atom->f   - ignored
min_hftn.cpp:     atom->x   - unchanged
min_hftn.cpp:     atom->f   - forces evaluated at x, but only if nStepType == NO_CGSTEP
min_hftn.cpp:     atom->x   - positions at x
min_hftn.cpp:     atom->f   - ignored
min_hftn.cpp:     atom->x   - unchanged
min_hftn.cpp:     atom->f   - forces evaluated at x, only if bEvaluateAtX is true
min_linesearch.cpp:  nvec = 3 * atom->nlocal;
min_linesearch.cpp:  if (nvec) xvec = atom->x[0];
min_linesearch.cpp:  if (nvec) fvec = atom->f[0];
min_linesearch.cpp:      extra_nlen[m] = extra_peratom[m] * atom->nlocal;
min_linesearch.cpp:                 atom->x = coords at new configuration
min_linesearch.cpp:                 atom->f = force at new configuration
min_linesearch.cpp:  if (output->thermo->normflag) fdothall /= atom->natoms;
min_linesearch.cpp:  if (output->thermo->normflag) fdothall /= atom->natoms;
min_linesearch.cpp:      ff /= atom->natoms;
min_linesearch.cpp:      fh /= atom->natoms;
min_linesearch.cpp:  if (output->thermo->normflag) fdothall /= atom->natoms;
min_linesearch.cpp:      ff /= atom->natoms;
min_linesearch.cpp:      fh /= atom->natoms;
min_quickmin.cpp:  double **v = atom->v;
min_quickmin.cpp:  int nlocal = atom->nlocal;
min_quickmin.cpp:  nvec = 3 * atom->nlocal;
min_quickmin.cpp:  if (nvec) xvec = atom->x[0];
min_quickmin.cpp:  if (nvec) fvec = atom->f[0];
min_quickmin.cpp:    double **v = atom->v;
min_quickmin.cpp:    double **f = atom->f;
min_quickmin.cpp:    int nlocal = atom->nlocal;
min_quickmin.cpp:    double *rmass = atom->rmass;
min_quickmin.cpp:    double *mass = atom->mass;
min_quickmin.cpp:    int *type = atom->type;
min_quickmin.cpp:    double **x = atom->x;
modify.cpp:  int nlocal = atom->nlocal;
modify.cpp:  int *mask = atom->mask;
modify.cpp:  // if yes, loop over atoms so they can extract info from atom->extra array
modify.cpp:      for (int j = 0; j < atom->nlocal; j++)
modify.cpp:  atom->update_callback(ifix);
modify.cpp:  const int * const mask = atom->mask;
modify.cpp:  const int nlocal = atom->nlocal;
modify.cpp:  const int * const mask = atom->mask;
modify.cpp:  const double * const * const x = atom->x;
modify.cpp:  const int nlocal = atom->nlocal;
modify.cpp:   check if the atoms in the selection list (length atom->nlocal,
modify.cpp:  const int nlocal = atom->nlocal;
molecule.cpp:  atom->check_mass(FLERR);
molecule.cpp:    else masstotal += atom->mass[type[i]];
molecule.cpp:    atom->check_mass(FLERR);
molecule.cpp:      else onemass = atom->mass[type[i]];
molecule.cpp:    atom->check_mass(FLERR);
molecule.cpp:      else onemass = atom->mass[type[i]];
molecule.cpp:        else onemass = atom->mass[type[i]];
molecule.cpp:        avec_body = (AtomVecBody *) atom->style_match("body");
molecule.cpp:    if ((type[i] <= 0) || (domain->box_exist && (type[i] > atom->ntypes)))
molecule.cpp:    if ((itype <= 0) || (domain->box_exist && (itype > atom->nbondtypes)))
molecule.cpp:    if ((itype <= 0) || (domain->box_exist && (itype > atom->nangletypes)))
molecule.cpp:    if ((itype <= 0) || (domain->box_exist && (itype > atom->ndihedraltypes)))
molecule.cpp:    if ((itype <= 0) || (domain->box_exist && (itype > atom->nimpropertypes)))
molecule.cpp:  memory->create(tmpspecial,natoms,atom->maxspecial,"molecule:tmpspecial");
molecule.cpp:  memset(&tmpspecial[0][0],0,sizeof(tagint)*natoms*atom->maxspecial);
molecule.cpp:        if (count[i] >= atom->maxspecial || count[atom2] >= atom->maxspecial)
molecule.cpp:        if (count[atom1] >= atom->maxspecial)
molecule.cpp:          if (count[i] >= atom->maxspecial)
molecule.cpp:          if (count[i] >= atom->maxspecial)
molecule.cpp:  int imol = atom->find_molecule(id);
molecule.cpp:    Molecule *onemol = atom->molecules[imol];
molecule.cpp:    if (onemol->qflag && !atom->q_flag) mismatch = 1;
molecule.cpp:    if (onemol->radiusflag && !atom->radius_flag) mismatch = 1;
molecule.cpp:    if (onemol->rmassflag && !atom->rmass_flag) mismatch = 1;
molecule.cpp:    if (atom->nbondtypes < onemol->nbondtypes) mismatch = 1;
molecule.cpp:    if (atom->nangletypes < onemol->nangletypes) mismatch = 1;
molecule.cpp:    if (atom->ndihedraltypes < onemol->ndihedraltypes) mismatch = 1;
molecule.cpp:    if (atom->nimpropertypes < onemol->nimpropertypes) mismatch = 1;
molecule.cpp:    if (atom->molecular == Atom::MOLECULAR) {
molecule.cpp:      if (atom->avec->bonds_allow &&
molecule.cpp:          atom->bond_per_atom < onemol->bond_per_atom) mismatch = 1;
molecule.cpp:      if (atom->avec->angles_allow &&
molecule.cpp:          atom->angle_per_atom < onemol->angle_per_atom) mismatch = 1;
molecule.cpp:      if (atom->avec->dihedrals_allow &&
molecule.cpp:          atom->dihedral_per_atom < onemol->dihedral_per_atom) mismatch = 1;
molecule.cpp:      if (atom->avec->impropers_allow &&
molecule.cpp:          atom->improper_per_atom < onemol->improper_per_atom) mismatch = 1;
molecule.cpp:      if (atom->maxspecial < onemol->maxspecial) mismatch = 1;
nbin_multi.cpp:  double **x = atom->x;
nbin_multi.cpp:  int *mask = atom->mask;
nbin_multi.cpp:  int nlocal = atom->nlocal;
nbin_multi.cpp:  int nall = nlocal + atom->nghost;
nbin_multi.cpp:    for (i = atom->nfirst-1; i >= 0; i--) {
nbin_standard.cpp:  double **x = atom->x;
nbin_standard.cpp:  int *mask = atom->mask;
nbin_standard.cpp:  int nlocal = atom->nlocal;
nbin_standard.cpp:  int nall = nlocal + atom->nghost;
nbin_standard.cpp:    for (i = atom->nfirst-1; i >= 0; i--) {
neighbor.cpp:  n = atom->ntypes;
neighbor.cpp:      maxhold = atom->nmax;
neighbor.cpp:  n = atom->ntypes;
neighbor.cpp:  // use atom->nmax for both grow() args
neighbor.cpp:  int maxatom = atom->nmax;
neighbor.cpp:  if (atom->molecular == Atom::ATOMIC) return;
neighbor.cpp:  // bonds,etc can only be broken for atom->molecular = Atom::MOLECULAR, not Atom::TEMPLATE
neighbor.cpp:  if (atom->avec->bonds_allow && atom->molecular == Atom::MOLECULAR) {
neighbor.cpp:    for (i = 0; i < atom->nlocal; i++) {
neighbor.cpp:      for (m = 0; m < atom->num_bond[i]; m++)
neighbor.cpp:        if (atom->bond_type[i][m] <= 0) bond_off = 1;
neighbor.cpp:  if (atom->avec->angles_allow && atom->molecular == Atom::MOLECULAR) {
neighbor.cpp:    for (i = 0; i < atom->nlocal; i++) {
neighbor.cpp:      for (m = 0; m < atom->num_angle[i]; m++)
neighbor.cpp:        if (atom->angle_type[i][m] <= 0) angle_off = 1;
neighbor.cpp:  if (atom->avec->dihedrals_allow && atom->molecular == Atom::MOLECULAR) {
neighbor.cpp:    for (i = 0; i < atom->nlocal; i++) {
neighbor.cpp:      for (m = 0; m < atom->num_dihedral[i]; m++)
neighbor.cpp:        if (atom->dihedral_type[i][m] <= 0) dihedral_off = 1;
neighbor.cpp:  if (atom->avec->impropers_allow && atom->molecular == Atom::MOLECULAR) {
neighbor.cpp:    for (i = 0; i < atom->nlocal; i++) {
neighbor.cpp:      for (m = 0; m < atom->num_improper[i]; m++)
neighbor.cpp:        if (atom->improper_type[i][m] <= 0) improper_off = 1;
neighbor.cpp:  if (atom->avec->bonds_allow) {
neighbor.cpp:    if (atom->molecular == Atom::TEMPLATE) bondwhich = TEMPLATE;
neighbor.cpp:  if (atom->avec->angles_allow) {
neighbor.cpp:    if (atom->molecular == Atom::TEMPLATE) anglewhich = TEMPLATE;
neighbor.cpp:  if (atom->avec->dihedrals_allow) {
neighbor.cpp:    if (atom->molecular == Atom::TEMPLATE) dihedralwhich = TEMPLATE;
neighbor.cpp:  if (atom->avec->impropers_allow) {
neighbor.cpp:    if (atom->molecular == Atom::TEMPLATE) improperwhich = TEMPLATE;
neighbor.cpp:  int molecular = atom->molecular;
neighbor.cpp:  double **x = atom->x;
neighbor.cpp:  int nlocal = atom->nlocal;
neighbor.cpp:  if (includegroup) nlocal = atom->nfirst;
neighbor.cpp:  int nlocal = atom->nlocal;
neighbor.cpp:  int nall = nlocal + atom->nghost;
neighbor.cpp:    double **x = atom->x;
neighbor.cpp:    if (includegroup) nlocal = atom->nfirst;
neighbor.cpp:    if (atom->nmax > maxhold) {
neighbor.cpp:      maxhold = atom->nmax;
neighbor.cpp:  if ((atom->molecular != Atom::ATOMIC) && topoflag) build_topology();
neighbor.cpp:    mylist->grow(atom->nlocal,atom->nlocal+atom->nghost);
neighbor.cpp:    ncollections = atom->ntypes;
neighbor.cpp:      if (includegroup && (atom->firstgroupname == nullptr ||
neighbor.cpp:                            strcmp(arg[iarg+1],atom->firstgroupname) != 0))
neighbor.cpp:        if (atom->molecule_flag == 0)
neighbor.cpp:      int ntypes = atom->ntypes;
neighbor.cpp:  int nmax = atom->nlocal+atom->nghost;
neighbor.cpp:    int *type = atom->type;
neigh_list.cpp:    int ntypes = atom->ntypes;
neigh_list.cpp:  else maxatom = atom->nmax;
neigh_request.cpp:  int ntypes = atom->ntypes;
neigh_request.cpp:  int ntypes = atom->ntypes;
npair.cpp:  molecular = atom->molecular;
npair.cpp:    int n = atom->ntypes;
npair_full_bin_atomonly.cpp:  double **x = atom->x;
npair_full_bin_atomonly.cpp:  int *type = atom->type;
npair_full_bin_atomonly.cpp:  int *mask = atom->mask;
npair_full_bin_atomonly.cpp:  tagint *molecule = atom->molecule;
npair_full_bin_atomonly.cpp:  int nlocal = atom->nlocal;
npair_full_bin_atomonly.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_full_bin.cpp:  double **x = atom->x;
npair_full_bin.cpp:  int *type = atom->type;
npair_full_bin.cpp:  int *mask = atom->mask;
npair_full_bin.cpp:  tagint *tag = atom->tag;
npair_full_bin.cpp:  tagint *molecule = atom->molecule;
npair_full_bin.cpp:  tagint **special = atom->special;
npair_full_bin.cpp:  int **nspecial = atom->nspecial;
npair_full_bin.cpp:  int nlocal = atom->nlocal;
npair_full_bin.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_full_bin.cpp:  int *molindex = atom->molindex;
npair_full_bin.cpp:  int *molatom = atom->molatom;
npair_full_bin.cpp:  Molecule **onemols = atom->avec->onemols;
npair_full_bin_ghost.cpp:  double **x = atom->x;
npair_full_bin_ghost.cpp:  int *type = atom->type;
npair_full_bin_ghost.cpp:  int *mask = atom->mask;
npair_full_bin_ghost.cpp:  tagint *tag = atom->tag;
npair_full_bin_ghost.cpp:  tagint *molecule = atom->molecule;
npair_full_bin_ghost.cpp:  tagint **special = atom->special;
npair_full_bin_ghost.cpp:  int **nspecial = atom->nspecial;
npair_full_bin_ghost.cpp:  int nlocal = atom->nlocal;
npair_full_bin_ghost.cpp:  int nall = nlocal + atom->nghost;
npair_full_bin_ghost.cpp:  int *molindex = atom->molindex;
npair_full_bin_ghost.cpp:  int *molatom = atom->molatom;
npair_full_bin_ghost.cpp:  Molecule **onemols = atom->avec->onemols;
npair_full_bin_ghost.cpp:  list->inum = atom->nlocal;
npair_full_bin_ghost.cpp:  list->gnum = inum - atom->nlocal;
npair_full_multi.cpp:  double **x = atom->x;
npair_full_multi.cpp:  int *type = atom->type;
npair_full_multi.cpp:  int *mask = atom->mask;
npair_full_multi.cpp:  tagint *tag = atom->tag;
npair_full_multi.cpp:  tagint *molecule = atom->molecule;
npair_full_multi.cpp:  tagint **special = atom->special;
npair_full_multi.cpp:  int **nspecial = atom->nspecial;
npair_full_multi.cpp:  int nlocal = atom->nlocal;
npair_full_multi.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_full_multi.cpp:  int *molindex = atom->molindex;
npair_full_multi.cpp:  int *molatom = atom->molatom;
npair_full_multi.cpp:  Molecule **onemols = atom->avec->onemols;
npair_full_multi_old.cpp:  double **x = atom->x;
npair_full_multi_old.cpp:  int *type = atom->type;
npair_full_multi_old.cpp:  int *mask = atom->mask;
npair_full_multi_old.cpp:  tagint *tag = atom->tag;
npair_full_multi_old.cpp:  tagint *molecule = atom->molecule;
npair_full_multi_old.cpp:  tagint **special = atom->special;
npair_full_multi_old.cpp:  int **nspecial = atom->nspecial;
npair_full_multi_old.cpp:  int nlocal = atom->nlocal;
npair_full_multi_old.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_full_multi_old.cpp:  int *molindex = atom->molindex;
npair_full_multi_old.cpp:  int *molatom = atom->molatom;
npair_full_multi_old.cpp:  Molecule **onemols = atom->avec->onemols;
npair_full_nsq.cpp:  double **x = atom->x;
npair_full_nsq.cpp:  int *type = atom->type;
npair_full_nsq.cpp:  int *mask = atom->mask;
npair_full_nsq.cpp:  tagint *tag = atom->tag;
npair_full_nsq.cpp:  tagint *molecule = atom->molecule;
npair_full_nsq.cpp:  tagint **special = atom->special;
npair_full_nsq.cpp:  int **nspecial = atom->nspecial;
npair_full_nsq.cpp:  int nlocal = atom->nlocal;
npair_full_nsq.cpp:  int nall = nlocal + atom->nghost;
npair_full_nsq.cpp:    nlocal = atom->nfirst;
npair_full_nsq.cpp:  int *molindex = atom->molindex;
npair_full_nsq.cpp:  int *molatom = atom->molatom;
npair_full_nsq.cpp:  Molecule **onemols = atom->avec->onemols;
npair_full_nsq_ghost.cpp:  double **x = atom->x;
npair_full_nsq_ghost.cpp:  int *type = atom->type;
npair_full_nsq_ghost.cpp:  int *mask = atom->mask;
npair_full_nsq_ghost.cpp:  tagint *tag = atom->tag;
npair_full_nsq_ghost.cpp:  tagint *molecule = atom->molecule;
npair_full_nsq_ghost.cpp:  tagint **special = atom->special;
npair_full_nsq_ghost.cpp:  int **nspecial = atom->nspecial;
npair_full_nsq_ghost.cpp:  int nlocal = atom->nlocal;
npair_full_nsq_ghost.cpp:  int nall = nlocal + atom->nghost;
npair_full_nsq_ghost.cpp:  int *molindex = atom->molindex;
npair_full_nsq_ghost.cpp:  int *molatom = atom->molatom;
npair_full_nsq_ghost.cpp:  Molecule **onemols = atom->avec->onemols;
npair_full_nsq_ghost.cpp:  list->inum = atom->nlocal;
npair_full_nsq_ghost.cpp:  list->gnum = inum - atom->nlocal;
npair_half_bin_atomonly_newton.cpp:  double **x = atom->x;
npair_half_bin_atomonly_newton.cpp:  int *type = atom->type;
npair_half_bin_atomonly_newton.cpp:  int *mask = atom->mask;
npair_half_bin_atomonly_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_bin_atomonly_newton.cpp:  int nlocal = atom->nlocal;
npair_half_bin_atomonly_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_bin_newtoff.cpp:  double **x = atom->x;
npair_half_bin_newtoff.cpp:  int *type = atom->type;
npair_half_bin_newtoff.cpp:  int *mask = atom->mask;
npair_half_bin_newtoff.cpp:  tagint *tag = atom->tag;
npair_half_bin_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_bin_newtoff.cpp:  tagint **special = atom->special;
npair_half_bin_newtoff.cpp:  int **nspecial = atom->nspecial;
npair_half_bin_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_bin_newtoff.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_bin_newtoff.cpp:  int *molindex = atom->molindex;
npair_half_bin_newtoff.cpp:  int *molatom = atom->molatom;
npair_half_bin_newtoff.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_bin_newtoff_ghost.cpp:  double **x = atom->x;
npair_half_bin_newtoff_ghost.cpp:  int *type = atom->type;
npair_half_bin_newtoff_ghost.cpp:  int *mask = atom->mask;
npair_half_bin_newtoff_ghost.cpp:  tagint *tag = atom->tag;
npair_half_bin_newtoff_ghost.cpp:  tagint *molecule = atom->molecule;
npair_half_bin_newtoff_ghost.cpp:  tagint **special = atom->special;
npair_half_bin_newtoff_ghost.cpp:  int **nspecial = atom->nspecial;
npair_half_bin_newtoff_ghost.cpp:  int nlocal = atom->nlocal;
npair_half_bin_newtoff_ghost.cpp:  int nall = nlocal + atom->nghost;
npair_half_bin_newtoff_ghost.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_bin_newtoff_ghost.cpp:  int *molindex = atom->molindex;
npair_half_bin_newtoff_ghost.cpp:  int *molatom = atom->molatom;
npair_half_bin_newtoff_ghost.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_bin_newtoff_ghost.cpp:  list->inum = atom->nlocal;
npair_half_bin_newtoff_ghost.cpp:  list->gnum = inum - atom->nlocal;
npair_half_bin_newton.cpp:  double **x = atom->x;
npair_half_bin_newton.cpp:  int *type = atom->type;
npair_half_bin_newton.cpp:  int *mask = atom->mask;
npair_half_bin_newton.cpp:  tagint *tag = atom->tag;
npair_half_bin_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_bin_newton.cpp:  tagint **special = atom->special;
npair_half_bin_newton.cpp:  int **nspecial = atom->nspecial;
npair_half_bin_newton.cpp:  int nlocal = atom->nlocal;
npair_half_bin_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_bin_newton.cpp:  int *molindex = atom->molindex;
npair_half_bin_newton.cpp:  int *molatom = atom->molatom;
npair_half_bin_newton.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_bin_newton_tri.cpp:  double **x = atom->x;
npair_half_bin_newton_tri.cpp:  int *type = atom->type;
npair_half_bin_newton_tri.cpp:  int *mask = atom->mask;
npair_half_bin_newton_tri.cpp:  tagint *tag = atom->tag;
npair_half_bin_newton_tri.cpp:  tagint *molecule = atom->molecule;
npair_half_bin_newton_tri.cpp:  tagint **special = atom->special;
npair_half_bin_newton_tri.cpp:  int **nspecial = atom->nspecial;
npair_half_bin_newton_tri.cpp:  int nlocal = atom->nlocal;
npair_half_bin_newton_tri.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_bin_newton_tri.cpp:  int *molindex = atom->molindex;
npair_half_bin_newton_tri.cpp:  int *molatom = atom->molatom;
npair_half_bin_newton_tri.cpp:  Molecule **onemols = atom->avec->onemols;
npair_halffull_newton.cpp:  double **x = atom->x;
npair_halffull_newton.cpp:  int nlocal = atom->nlocal;
npair_half_multi_newtoff.cpp:  double **x = atom->x;
npair_half_multi_newtoff.cpp:  int *type = atom->type;
npair_half_multi_newtoff.cpp:  int *mask = atom->mask;
npair_half_multi_newtoff.cpp:  tagint *tag = atom->tag;
npair_half_multi_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_multi_newtoff.cpp:  tagint **special = atom->special;
npair_half_multi_newtoff.cpp:  int **nspecial = atom->nspecial;
npair_half_multi_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_multi_newtoff.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_multi_newtoff.cpp:  int *molindex = atom->molindex;
npair_half_multi_newtoff.cpp:  int *molatom = atom->molatom;
npair_half_multi_newtoff.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_multi_newton.cpp:  double **x = atom->x;
npair_half_multi_newton.cpp:  int *type = atom->type;
npair_half_multi_newton.cpp:  int *mask = atom->mask;
npair_half_multi_newton.cpp:  tagint *tag = atom->tag;
npair_half_multi_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_multi_newton.cpp:  tagint **special = atom->special;
npair_half_multi_newton.cpp:  int **nspecial = atom->nspecial;
npair_half_multi_newton.cpp:  int nlocal = atom->nlocal;
npair_half_multi_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_multi_newton.cpp:  int *molindex = atom->molindex;
npair_half_multi_newton.cpp:  int *molatom = atom->molatom;
npair_half_multi_newton.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_multi_newton_tri.cpp:  double **x = atom->x;
npair_half_multi_newton_tri.cpp:  int *type = atom->type;
npair_half_multi_newton_tri.cpp:  int *mask = atom->mask;
npair_half_multi_newton_tri.cpp:  tagint *tag = atom->tag;
npair_half_multi_newton_tri.cpp:  tagint *molecule = atom->molecule;
npair_half_multi_newton_tri.cpp:  tagint **special = atom->special;
npair_half_multi_newton_tri.cpp:  int **nspecial = atom->nspecial;
npair_half_multi_newton_tri.cpp:  int nlocal = atom->nlocal;
npair_half_multi_newton_tri.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_multi_newton_tri.cpp:  int *molindex = atom->molindex;
npair_half_multi_newton_tri.cpp:  int *molatom = atom->molatom;
npair_half_multi_newton_tri.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_multi_old_newtoff.cpp:  double **x = atom->x;
npair_half_multi_old_newtoff.cpp:  int *type = atom->type;
npair_half_multi_old_newtoff.cpp:  int *mask = atom->mask;
npair_half_multi_old_newtoff.cpp:  tagint *tag = atom->tag;
npair_half_multi_old_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_multi_old_newtoff.cpp:  tagint **special = atom->special;
npair_half_multi_old_newtoff.cpp:  int **nspecial = atom->nspecial;
npair_half_multi_old_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_multi_old_newtoff.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_multi_old_newtoff.cpp:  int *molindex = atom->molindex;
npair_half_multi_old_newtoff.cpp:  int *molatom = atom->molatom;
npair_half_multi_old_newtoff.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_multi_old_newton.cpp:  double **x = atom->x;
npair_half_multi_old_newton.cpp:  int *type = atom->type;
npair_half_multi_old_newton.cpp:  int *mask = atom->mask;
npair_half_multi_old_newton.cpp:  tagint *tag = atom->tag;
npair_half_multi_old_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_multi_old_newton.cpp:  tagint **special = atom->special;
npair_half_multi_old_newton.cpp:  int **nspecial = atom->nspecial;
npair_half_multi_old_newton.cpp:  int nlocal = atom->nlocal;
npair_half_multi_old_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_multi_old_newton.cpp:  int *molindex = atom->molindex;
npair_half_multi_old_newton.cpp:  int *molatom = atom->molatom;
npair_half_multi_old_newton.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_multi_old_newton_tri.cpp:  double **x = atom->x;
npair_half_multi_old_newton_tri.cpp:  int *type = atom->type;
npair_half_multi_old_newton_tri.cpp:  int *mask = atom->mask;
npair_half_multi_old_newton_tri.cpp:  tagint *tag = atom->tag;
npair_half_multi_old_newton_tri.cpp:  tagint *molecule = atom->molecule;
npair_half_multi_old_newton_tri.cpp:  tagint **special = atom->special;
npair_half_multi_old_newton_tri.cpp:  int **nspecial = atom->nspecial;
npair_half_multi_old_newton_tri.cpp:  int nlocal = atom->nlocal;
npair_half_multi_old_newton_tri.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_multi_old_newton_tri.cpp:  int *molindex = atom->molindex;
npair_half_multi_old_newton_tri.cpp:  int *molatom = atom->molatom;
npair_half_multi_old_newton_tri.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_nsq_newtoff.cpp:  double **x = atom->x;
npair_half_nsq_newtoff.cpp:  int *type = atom->type;
npair_half_nsq_newtoff.cpp:  int *mask = atom->mask;
npair_half_nsq_newtoff.cpp:  tagint *tag = atom->tag;
npair_half_nsq_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_nsq_newtoff.cpp:  tagint **special = atom->special;
npair_half_nsq_newtoff.cpp:  int **nspecial = atom->nspecial;
npair_half_nsq_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_nsq_newtoff.cpp:  int nall = nlocal + atom->nghost;
npair_half_nsq_newtoff.cpp:    nlocal = atom->nfirst;
npair_half_nsq_newtoff.cpp:  int *molindex = atom->molindex;
npair_half_nsq_newtoff.cpp:  int *molatom = atom->molatom;
npair_half_nsq_newtoff.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_nsq_newtoff_ghost.cpp:  double **x = atom->x;
npair_half_nsq_newtoff_ghost.cpp:  int *type = atom->type;
npair_half_nsq_newtoff_ghost.cpp:  int *mask = atom->mask;
npair_half_nsq_newtoff_ghost.cpp:  tagint *tag = atom->tag;
npair_half_nsq_newtoff_ghost.cpp:  tagint *molecule = atom->molecule;
npair_half_nsq_newtoff_ghost.cpp:  tagint **special = atom->special;
npair_half_nsq_newtoff_ghost.cpp:  int **nspecial = atom->nspecial;
npair_half_nsq_newtoff_ghost.cpp:  int nlocal = atom->nlocal;
npair_half_nsq_newtoff_ghost.cpp:  int nall = nlocal + atom->nghost;
npair_half_nsq_newtoff_ghost.cpp:    nlocal = atom->nfirst;
npair_half_nsq_newtoff_ghost.cpp:  int *molindex = atom->molindex;
npair_half_nsq_newtoff_ghost.cpp:  int *molatom = atom->molatom;
npair_half_nsq_newtoff_ghost.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_nsq_newtoff_ghost.cpp:  list->inum = atom->nlocal;
npair_half_nsq_newtoff_ghost.cpp:  list->gnum = inum - atom->nlocal;
npair_half_nsq_newton.cpp:  double **x = atom->x;
npair_half_nsq_newton.cpp:  int *type = atom->type;
npair_half_nsq_newton.cpp:  int *mask = atom->mask;
npair_half_nsq_newton.cpp:  tagint *tag = atom->tag;
npair_half_nsq_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_nsq_newton.cpp:  tagint **special = atom->special;
npair_half_nsq_newton.cpp:  int **nspecial = atom->nspecial;
npair_half_nsq_newton.cpp:  int nlocal = atom->nlocal;
npair_half_nsq_newton.cpp:  int nall = nlocal + atom->nghost;
npair_half_nsq_newton.cpp:    nlocal = atom->nfirst;
npair_half_nsq_newton.cpp:  int *molindex = atom->molindex;
npair_half_nsq_newton.cpp:  int *molatom = atom->molatom;
npair_half_nsq_newton.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_respa_bin_newtoff.cpp:  double **x = atom->x;
npair_half_respa_bin_newtoff.cpp:  int *type = atom->type;
npair_half_respa_bin_newtoff.cpp:  int *mask = atom->mask;
npair_half_respa_bin_newtoff.cpp:  tagint *tag = atom->tag;
npair_half_respa_bin_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_respa_bin_newtoff.cpp:  tagint **special = atom->special;
npair_half_respa_bin_newtoff.cpp:  int **nspecial = atom->nspecial;
npair_half_respa_bin_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_respa_bin_newtoff.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_respa_bin_newtoff.cpp:  int *molindex = atom->molindex;
npair_half_respa_bin_newtoff.cpp:  int *molatom = atom->molatom;
npair_half_respa_bin_newtoff.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_respa_bin_newton.cpp:  double **x = atom->x;
npair_half_respa_bin_newton.cpp:  int *type = atom->type;
npair_half_respa_bin_newton.cpp:  int *mask = atom->mask;
npair_half_respa_bin_newton.cpp:  tagint *tag = atom->tag;
npair_half_respa_bin_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_respa_bin_newton.cpp:  tagint **special = atom->special;
npair_half_respa_bin_newton.cpp:  int **nspecial = atom->nspecial;
npair_half_respa_bin_newton.cpp:  int nlocal = atom->nlocal;
npair_half_respa_bin_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_respa_bin_newton.cpp:  int *molindex = atom->molindex;
npair_half_respa_bin_newton.cpp:  int *molatom = atom->molatom;
npair_half_respa_bin_newton.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_respa_bin_newton_tri.cpp:  double **x = atom->x;
npair_half_respa_bin_newton_tri.cpp:  int *type = atom->type;
npair_half_respa_bin_newton_tri.cpp:  int *mask = atom->mask;
npair_half_respa_bin_newton_tri.cpp:  tagint *tag = atom->tag;
npair_half_respa_bin_newton_tri.cpp:  tagint *molecule = atom->molecule;
npair_half_respa_bin_newton_tri.cpp:  tagint **special = atom->special;
npair_half_respa_bin_newton_tri.cpp:  int **nspecial = atom->nspecial;
npair_half_respa_bin_newton_tri.cpp:  int nlocal = atom->nlocal;
npair_half_respa_bin_newton_tri.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_respa_bin_newton_tri.cpp:  int *molindex = atom->molindex;
npair_half_respa_bin_newton_tri.cpp:  int *molatom = atom->molatom;
npair_half_respa_bin_newton_tri.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_respa_nsq_newtoff.cpp:  double **x = atom->x;
npair_half_respa_nsq_newtoff.cpp:  int *type = atom->type;
npair_half_respa_nsq_newtoff.cpp:  int *mask = atom->mask;
npair_half_respa_nsq_newtoff.cpp:  tagint *tag = atom->tag;
npair_half_respa_nsq_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_respa_nsq_newtoff.cpp:  tagint **special = atom->special;
npair_half_respa_nsq_newtoff.cpp:  int **nspecial = atom->nspecial;
npair_half_respa_nsq_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_respa_nsq_newtoff.cpp:  int nall = nlocal + atom->nghost;
npair_half_respa_nsq_newtoff.cpp:    nlocal = atom->nfirst;
npair_half_respa_nsq_newtoff.cpp:  int *molindex = atom->molindex;
npair_half_respa_nsq_newtoff.cpp:  int *molatom = atom->molatom;
npair_half_respa_nsq_newtoff.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_respa_nsq_newton.cpp:  double **x = atom->x;
npair_half_respa_nsq_newton.cpp:  int *type = atom->type;
npair_half_respa_nsq_newton.cpp:  int *mask = atom->mask;
npair_half_respa_nsq_newton.cpp:  tagint *tag = atom->tag;
npair_half_respa_nsq_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_respa_nsq_newton.cpp:  tagint **special = atom->special;
npair_half_respa_nsq_newton.cpp:  int **nspecial = atom->nspecial;
npair_half_respa_nsq_newton.cpp:  int nlocal = atom->nlocal;
npair_half_respa_nsq_newton.cpp:  int nall = nlocal + atom->nghost;
npair_half_respa_nsq_newton.cpp:    nlocal = atom->nfirst;
npair_half_respa_nsq_newton.cpp:  int *molindex = atom->molindex;
npair_half_respa_nsq_newton.cpp:  int *molatom = atom->molatom;
npair_half_respa_nsq_newton.cpp:  Molecule **onemols = atom->avec->onemols;
npair_half_size_bin_newtoff.cpp:  double **x = atom->x;
npair_half_size_bin_newtoff.cpp:  double *radius = atom->radius;
npair_half_size_bin_newtoff.cpp:  int *type = atom->type;
npair_half_size_bin_newtoff.cpp:  int *mask = atom->mask;
npair_half_size_bin_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_size_bin_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_size_bin_newtoff.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_bin_newton.cpp:  double **x = atom->x;
npair_half_size_bin_newton.cpp:  double *radius = atom->radius;
npair_half_size_bin_newton.cpp:  int *type = atom->type;
npair_half_size_bin_newton.cpp:  int *mask = atom->mask;
npair_half_size_bin_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_size_bin_newton.cpp:  int nlocal = atom->nlocal;
npair_half_size_bin_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_bin_newton_tri.cpp:  double **x = atom->x;
npair_half_size_bin_newton_tri.cpp:  double *radius = atom->radius;
npair_half_size_bin_newton_tri.cpp:  int *type = atom->type;
npair_half_size_bin_newton_tri.cpp:  int *mask = atom->mask;
npair_half_size_bin_newton_tri.cpp:  tagint *molecule = atom->molecule;
npair_half_size_bin_newton_tri.cpp:  int nlocal = atom->nlocal;
npair_half_size_bin_newton_tri.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_multi_newtoff.cpp:  double **x = atom->x;
npair_half_size_multi_newtoff.cpp:  double *radius = atom->radius;
npair_half_size_multi_newtoff.cpp:  int *type = atom->type;
npair_half_size_multi_newtoff.cpp:  int *mask = atom->mask;
npair_half_size_multi_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_size_multi_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_size_multi_newtoff.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_multi_newton.cpp:  double **x = atom->x;
npair_half_size_multi_newton.cpp:  double *radius = atom->radius;
npair_half_size_multi_newton.cpp:  int *type = atom->type;
npair_half_size_multi_newton.cpp:  int *mask = atom->mask;
npair_half_size_multi_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_size_multi_newton.cpp:  int nlocal = atom->nlocal;
npair_half_size_multi_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_multi_newton_tri.cpp:  double **x = atom->x;
npair_half_size_multi_newton_tri.cpp:  double *radius = atom->radius;
npair_half_size_multi_newton_tri.cpp:  int *type = atom->type;
npair_half_size_multi_newton_tri.cpp:  int *mask = atom->mask;
npair_half_size_multi_newton_tri.cpp:  tagint *molecule = atom->molecule;
npair_half_size_multi_newton_tri.cpp:  int nlocal = atom->nlocal;
npair_half_size_multi_newton_tri.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_multi_old_newtoff.cpp:  double **x = atom->x;
npair_half_size_multi_old_newtoff.cpp:  double *radius = atom->radius;
npair_half_size_multi_old_newtoff.cpp:  int *type = atom->type;
npair_half_size_multi_old_newtoff.cpp:  int *mask = atom->mask;
npair_half_size_multi_old_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_size_multi_old_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_size_multi_old_newtoff.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_multi_old_newton.cpp:  double **x = atom->x;
npair_half_size_multi_old_newton.cpp:  double *radius = atom->radius;
npair_half_size_multi_old_newton.cpp:  int *type = atom->type;
npair_half_size_multi_old_newton.cpp:  int *mask = atom->mask;
npair_half_size_multi_old_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_size_multi_old_newton.cpp:  int nlocal = atom->nlocal;
npair_half_size_multi_old_newton.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_multi_old_newton_tri.cpp:  double **x = atom->x;
npair_half_size_multi_old_newton_tri.cpp:  double *radius = atom->radius;
npair_half_size_multi_old_newton_tri.cpp:  int *type = atom->type;
npair_half_size_multi_old_newton_tri.cpp:  int *mask = atom->mask;
npair_half_size_multi_old_newton_tri.cpp:  tagint *molecule = atom->molecule;
npair_half_size_multi_old_newton_tri.cpp:  int nlocal = atom->nlocal;
npair_half_size_multi_old_newton_tri.cpp:  if (includegroup) nlocal = atom->nfirst;
npair_half_size_nsq_newtoff.cpp:  double **x = atom->x;
npair_half_size_nsq_newtoff.cpp:  double *radius = atom->radius;
npair_half_size_nsq_newtoff.cpp:  int *type = atom->type;
npair_half_size_nsq_newtoff.cpp:  int *mask = atom->mask;
npair_half_size_nsq_newtoff.cpp:  tagint *molecule = atom->molecule;
npair_half_size_nsq_newtoff.cpp:  int nlocal = atom->nlocal;
npair_half_size_nsq_newtoff.cpp:  int nall = nlocal + atom->nghost;
npair_half_size_nsq_newtoff.cpp:    nlocal = atom->nfirst;
npair_half_size_nsq_newton.cpp:  double **x = atom->x;
npair_half_size_nsq_newton.cpp:  double *radius = atom->radius;
npair_half_size_nsq_newton.cpp:  tagint *tag = atom->tag;
npair_half_size_nsq_newton.cpp:  int *type = atom->type;
npair_half_size_nsq_newton.cpp:  int *mask = atom->mask;
npair_half_size_nsq_newton.cpp:  tagint *molecule = atom->molecule;
npair_half_size_nsq_newton.cpp:  int nlocal = atom->nlocal;
npair_half_size_nsq_newton.cpp:  int nall = nlocal + atom->nghost;
npair_half_size_nsq_newton.cpp:    nlocal = atom->nfirst;
npair_skip.cpp:  int *type = atom->type;
npair_skip.cpp:  int nlocal = atom->nlocal;
npair_skip_respa.cpp:  int *type = atom->type;
npair_skip_size.cpp:  int *type = atom->type;
npair_skip_size_off2on.cpp:  tagint *tag = atom->tag;
npair_skip_size_off2on.cpp:  int *type = atom->type;
npair_skip_size_off2on.cpp:  int nlocal = atom->nlocal;
npair_skip_size_off2on_oneside.cpp:  int *type = atom->type;
npair_skip_size_off2on_oneside.cpp:  int nlocal = atom->nlocal;
npair_skip_size_off2on_oneside.cpp:  if (domain->dimension == 2) surf = atom->line;
npair_skip_size_off2on_oneside.cpp:  else surf = atom->tri;
nstencil.cpp:    int n = atom->ntypes;
nstencil.cpp:      int n = atom->ntypes;
nstencil.cpp:    bytes += (double)atom->ntypes*maxstencil_multi_old * sizeof(int);
nstencil.cpp:    bytes += (double)atom->ntypes*maxstencil_multi_old * sizeof(double);
nstencil_full_multi_old_2d.cpp:  int ntypes = atom->ntypes;
nstencil_full_multi_old_3d.cpp:  int ntypes = atom->ntypes;
nstencil_half_multi_old_2d.cpp:  int ntypes = atom->ntypes;
nstencil_half_multi_old_2d_tri.cpp:  int ntypes = atom->ntypes;
nstencil_half_multi_old_3d.cpp:  int ntypes = atom->ntypes;
nstencil_half_multi_old_3d_tri.cpp:  int ntypes = atom->ntypes;
ntopo_angle_all.cpp:  int nlocal = atom->nlocal;
ntopo_angle_all.cpp:  int *num_angle = atom->num_angle;
ntopo_angle_all.cpp:  tagint **angle_atom1 = atom->angle_atom1;
ntopo_angle_all.cpp:  tagint **angle_atom2 = atom->angle_atom2;
ntopo_angle_all.cpp:  tagint **angle_atom3 = atom->angle_atom3;
ntopo_angle_all.cpp:  int **angle_type = atom->angle_type;
ntopo_angle_all.cpp:      atom1 = atom->map(angle_atom1[i][m]);
ntopo_angle_all.cpp:      atom2 = atom->map(angle_atom2[i][m]);
ntopo_angle_all.cpp:      atom3 = atom->map(angle_atom3[i][m]);
ntopo_angle_partial.cpp:  int nlocal = atom->nlocal;
ntopo_angle_partial.cpp:  int *num_angle = atom->num_angle;
ntopo_angle_partial.cpp:  tagint **angle_atom1 = atom->angle_atom1;
ntopo_angle_partial.cpp:  tagint **angle_atom2 = atom->angle_atom2;
ntopo_angle_partial.cpp:  tagint **angle_atom3 = atom->angle_atom3;
ntopo_angle_partial.cpp:  int **angle_type = atom->angle_type;
ntopo_angle_partial.cpp:      atom1 = atom->map(angle_atom1[i][m]);
ntopo_angle_partial.cpp:      atom2 = atom->map(angle_atom2[i][m]);
ntopo_angle_partial.cpp:      atom3 = atom->map(angle_atom3[i][m]);
ntopo_angle_template.cpp:  Molecule **onemols = atom->avec->onemols;
ntopo_angle_template.cpp:  tagint *tag = atom->tag;
ntopo_angle_template.cpp:  int *molindex = atom->molindex;
ntopo_angle_template.cpp:  int *molatom = atom->molatom;
ntopo_angle_template.cpp:  int nlocal = atom->nlocal;
ntopo_angle_template.cpp:      atom1 = atom->map(angle_atom1[iatom][m]+tagprev);
ntopo_angle_template.cpp:      atom2 = atom->map(angle_atom2[iatom][m]+tagprev);
ntopo_angle_template.cpp:      atom3 = atom->map(angle_atom3[iatom][m]+tagprev);
ntopo_bond_all.cpp:  int nlocal = atom->nlocal;
ntopo_bond_all.cpp:  int *num_bond = atom->num_bond;
ntopo_bond_all.cpp:  tagint **bond_atom = atom->bond_atom;
ntopo_bond_all.cpp:  int **bond_type = atom->bond_type;
ntopo_bond_all.cpp:  tagint *tag = atom->tag;
ntopo_bond_all.cpp:      atom1 = atom->map(bond_atom[i][m]);
ntopo_bond_partial.cpp:  int nlocal = atom->nlocal;
ntopo_bond_partial.cpp:  int *num_bond = atom->num_bond;
ntopo_bond_partial.cpp:  tagint **bond_atom = atom->bond_atom;
ntopo_bond_partial.cpp:  int **bond_type = atom->bond_type;
ntopo_bond_partial.cpp:  tagint *tag = atom->tag;
ntopo_bond_partial.cpp:      atom1 = atom->map(bond_atom[i][m]);
ntopo_bond_template.cpp:  Molecule **onemols = atom->avec->onemols;
ntopo_bond_template.cpp:  tagint *tag = atom->tag;
ntopo_bond_template.cpp:  int *molindex = atom->molindex;
ntopo_bond_template.cpp:  int *molatom = atom->molatom;
ntopo_bond_template.cpp:  int nlocal = atom->nlocal;
ntopo_bond_template.cpp:      atom1 = atom->map(bond_atom[iatom][m]+tagprev);
ntopo.cpp:  if (nprocs == 1) maxbond = atom->nbonds;
ntopo.cpp:  else maxbond = static_cast<int> (LB_FACTOR * atom->nbonds / nprocs);
ntopo.cpp:  if (nprocs == 1) maxangle = atom->nangles;
ntopo.cpp:  else maxangle = static_cast<int> (LB_FACTOR * atom->nangles / nprocs);
ntopo.cpp:  if (nprocs == 1) maxdihedral = atom->ndihedrals;
ntopo.cpp:  else maxdihedral = static_cast<int> (LB_FACTOR * atom->ndihedrals / nprocs);
ntopo.cpp:  if (nprocs == 1) maximproper = atom->nimpropers;
ntopo.cpp:  else maximproper = static_cast<int> (LB_FACTOR * atom->nimpropers / nprocs);
ntopo.cpp:  double **x = atom->x;
ntopo.cpp:  double **x = atom->x;
ntopo.cpp:  double **x = atom->x;
ntopo_dihedral_all.cpp:  int nlocal = atom->nlocal;
ntopo_dihedral_all.cpp:  int *num_dihedral = atom->num_dihedral;
ntopo_dihedral_all.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
ntopo_dihedral_all.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
ntopo_dihedral_all.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
ntopo_dihedral_all.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
ntopo_dihedral_all.cpp:  int **dihedral_type = atom->dihedral_type;
ntopo_dihedral_all.cpp:      atom1 = atom->map(dihedral_atom1[i][m]);
ntopo_dihedral_all.cpp:      atom2 = atom->map(dihedral_atom2[i][m]);
ntopo_dihedral_all.cpp:      atom3 = atom->map(dihedral_atom3[i][m]);
ntopo_dihedral_all.cpp:      atom4 = atom->map(dihedral_atom4[i][m]);
ntopo_dihedral_partial.cpp:  int nlocal = atom->nlocal;
ntopo_dihedral_partial.cpp:  int *num_dihedral = atom->num_dihedral;
ntopo_dihedral_partial.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
ntopo_dihedral_partial.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
ntopo_dihedral_partial.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
ntopo_dihedral_partial.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
ntopo_dihedral_partial.cpp:  int **dihedral_type = atom->dihedral_type;
ntopo_dihedral_partial.cpp:      atom1 = atom->map(dihedral_atom1[i][m]);
ntopo_dihedral_partial.cpp:      atom2 = atom->map(dihedral_atom2[i][m]);
ntopo_dihedral_partial.cpp:      atom3 = atom->map(dihedral_atom3[i][m]);
ntopo_dihedral_partial.cpp:      atom4 = atom->map(dihedral_atom4[i][m]);
ntopo_dihedral_template.cpp:  Molecule **onemols = atom->avec->onemols;
ntopo_dihedral_template.cpp:  tagint *tag = atom->tag;
ntopo_dihedral_template.cpp:  int *molindex = atom->molindex;
ntopo_dihedral_template.cpp:  int *molatom = atom->molatom;
ntopo_dihedral_template.cpp:  int nlocal = atom->nlocal;
ntopo_dihedral_template.cpp:      atom1 = atom->map(dihedral_atom1[iatom][m]+tagprev);
ntopo_dihedral_template.cpp:      atom2 = atom->map(dihedral_atom2[iatom][m]+tagprev);
ntopo_dihedral_template.cpp:      atom3 = atom->map(dihedral_atom3[iatom][m]+tagprev);
ntopo_dihedral_template.cpp:      atom4 = atom->map(dihedral_atom4[iatom][m]+tagprev);
ntopo_improper_all.cpp:  int nlocal = atom->nlocal;
ntopo_improper_all.cpp:  int *num_improper = atom->num_improper;
ntopo_improper_all.cpp:  tagint **improper_atom1 = atom->improper_atom1;
ntopo_improper_all.cpp:  tagint **improper_atom2 = atom->improper_atom2;
ntopo_improper_all.cpp:  tagint **improper_atom3 = atom->improper_atom3;
ntopo_improper_all.cpp:  tagint **improper_atom4 = atom->improper_atom4;
ntopo_improper_all.cpp:  int **improper_type = atom->improper_type;
ntopo_improper_all.cpp:      atom1 = atom->map(improper_atom1[i][m]);
ntopo_improper_all.cpp:      atom2 = atom->map(improper_atom2[i][m]);
ntopo_improper_all.cpp:      atom3 = atom->map(improper_atom3[i][m]);
ntopo_improper_all.cpp:      atom4 = atom->map(improper_atom4[i][m]);
ntopo_improper_partial.cpp:  int nlocal = atom->nlocal;
ntopo_improper_partial.cpp:  int *num_improper = atom->num_improper;
ntopo_improper_partial.cpp:  tagint **improper_atom1 = atom->improper_atom1;
ntopo_improper_partial.cpp:  tagint **improper_atom2 = atom->improper_atom2;
ntopo_improper_partial.cpp:  tagint **improper_atom3 = atom->improper_atom3;
ntopo_improper_partial.cpp:  tagint **improper_atom4 = atom->improper_atom4;
ntopo_improper_partial.cpp:  int **improper_type = atom->improper_type;
ntopo_improper_partial.cpp:      atom1 = atom->map(improper_atom1[i][m]);
ntopo_improper_partial.cpp:      atom2 = atom->map(improper_atom2[i][m]);
ntopo_improper_partial.cpp:      atom3 = atom->map(improper_atom3[i][m]);
ntopo_improper_partial.cpp:      atom4 = atom->map(improper_atom4[i][m]);
ntopo_improper_template.cpp:  Molecule **onemols = atom->avec->onemols;
ntopo_improper_template.cpp:  tagint *tag = atom->tag;
ntopo_improper_template.cpp:  int *molindex = atom->molindex;
ntopo_improper_template.cpp:  int *molatom = atom->molatom;
ntopo_improper_template.cpp:  int nlocal = atom->nlocal;
ntopo_improper_template.cpp:      atom1 = atom->map(improper_atom1[iatom][m]+tagprev);
ntopo_improper_template.cpp:      atom2 = atom->map(improper_atom2[iatom][m]+tagprev);
ntopo_improper_template.cpp:      atom3 = atom->map(improper_atom3[iatom][m]+tagprev);
ntopo_improper_template.cpp:      atom4 = atom->map(improper_atom4[iatom][m]+tagprev);
pair_born.cpp:  double **x = atom->x;
pair_born.cpp:  double **f = atom->f;
pair_born.cpp:  int *type = atom->type;
pair_born.cpp:  int nlocal = atom->nlocal;
pair_born.cpp:  int n = atom->ntypes;
pair_born.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_born.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_born.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_born.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_born.cpp:     int *type = atom->type;
pair_born.cpp:     int nlocal = atom->nlocal;
pair_born.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_born.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_born.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_born.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_born.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_born.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_born.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_buck_coul_cut.cpp:  double **x = atom->x;
pair_buck_coul_cut.cpp:  double **f = atom->f;
pair_buck_coul_cut.cpp:  double *q = atom->q;
pair_buck_coul_cut.cpp:  int *type = atom->type;
pair_buck_coul_cut.cpp:  int nlocal = atom->nlocal;
pair_buck_coul_cut.cpp:  int n = atom->ntypes;
pair_buck_coul_cut.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_buck_coul_cut.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_buck_coul_cut.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_buck_coul_cut.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_buck_coul_cut.cpp:  if (!atom->q_flag)
pair_buck_coul_cut.cpp:    int *type = atom->type;
pair_buck_coul_cut.cpp:    int nlocal = atom->nlocal;
pair_buck_coul_cut.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_buck_coul_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_buck_coul_cut.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_buck_coul_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_buck_coul_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_buck_coul_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_buck_coul_cut.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_buck_coul_cut.cpp:    forcecoul = force->qqrd2e * atom->q[i]*atom->q[j]*sqrt(r2inv);
pair_buck_coul_cut.cpp:    phicoul = force->qqrd2e * atom->q[i]*atom->q[j]*sqrt(r2inv);
pair_buck.cpp:  double **x = atom->x;
pair_buck.cpp:  double **f = atom->f;
pair_buck.cpp:  int *type = atom->type;
pair_buck.cpp:  int nlocal = atom->nlocal;
pair_buck.cpp:  int n = atom->ntypes;
pair_buck.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_buck.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_buck.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_buck.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_buck.cpp:    int *type = atom->type;
pair_buck.cpp:    int nlocal = atom->nlocal;
pair_buck.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_buck.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_buck.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_buck.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_buck.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_buck.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_buck.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_coul_cut.cpp:  double **x = atom->x;
pair_coul_cut.cpp:  double **f = atom->f;
pair_coul_cut.cpp:  double *q = atom->q;
pair_coul_cut.cpp:  int *type = atom->type;
pair_coul_cut.cpp:  int nlocal = atom->nlocal;
pair_coul_cut.cpp:  int n = atom->ntypes;
pair_coul_cut.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_coul_cut.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_coul_cut.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_coul_cut.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_coul_cut.cpp:  if (!atom->q_flag)
pair_coul_cut.cpp:  for (i = 1; i <= atom->ntypes; i++) {
pair_coul_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_coul_cut.cpp:  for (i = 1; i <= atom->ntypes; i++) {
pair_coul_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_coul_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_coul_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_coul_cut.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_coul_cut.cpp:  forcecoul = force->qqrd2e * atom->q[i]*atom->q[j]*rinv;
pair_coul_cut.cpp:  phicoul = force->qqrd2e * atom->q[i]*atom->q[j]*rinv;
pair_coul_debye.cpp:  double **x = atom->x;
pair_coul_debye.cpp:  double **f = atom->f;
pair_coul_debye.cpp:  double *q = atom->q;
pair_coul_debye.cpp:  int *type = atom->type;
pair_coul_debye.cpp:  int nlocal = atom->nlocal;
pair_coul_debye.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_coul_debye.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_coul_debye.cpp:  forcecoul = force->qqrd2e * atom->q[i]*atom->q[j] *
pair_coul_debye.cpp:  phicoul = force->qqrd2e * atom->q[i]*atom->q[j] * rinv * screening;
pair_coul_dsf.cpp:  double **x = atom->x;
pair_coul_dsf.cpp:  double **f = atom->f;
pair_coul_dsf.cpp:  double *q = atom->q;
pair_coul_dsf.cpp:  int nlocal = atom->nlocal;
pair_coul_dsf.cpp:  int n = atom->ntypes;
pair_coul_dsf.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_coul_dsf.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_coul_dsf.cpp:  if (!atom->q_flag)
pair_coul_dsf.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_coul_dsf.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_coul_dsf.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_coul_dsf.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_coul_dsf.cpp:    prefactor = force->qqrd2e * atom->q[i]*atom->q[j]/r;
pair_coul_wolf.cpp:  double **x = atom->x;
pair_coul_wolf.cpp:  double **f = atom->f;
pair_coul_wolf.cpp:  double *q = atom->q;
pair_coul_wolf.cpp:  int nlocal = atom->nlocal;
pair_coul_wolf.cpp:  int n = atom->ntypes;
pair_coul_wolf.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_coul_wolf.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_coul_wolf.cpp:  if (!atom->q_flag)
pair_coul_wolf.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_coul_wolf.cpp:    for (j = i; j <= atom->ntypes; j++)
pair_coul_wolf.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_coul_wolf.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_coul_wolf.cpp:    prefactor = force->qqrd2e * atom->q[i]*atom->q[j]/r;
pair.cpp:  if (manybody_flag && (atom->molecular != Atom::ATOMIC)) {
pair.cpp:    if (atom->nbonds > 0 && force->special_lj[1] == 0.0 &&
pair.cpp:    if (atom->nangles > 0 && force->special_lj[2] == 0.0 &&
pair.cpp:    if (atom->ndihedrals > 0 && force->special_lj[3] == 0.0 &&
pair.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair.cpp:    for (int j = i; j <= atom->ntypes; j++) {
pair.cpp:  const int ntypes = atom->ntypes;
pair.cpp:  if (eflag_atom && atom->nmax > maxeatom) {
pair.cpp:    maxeatom = atom->nmax;
pair.cpp:  if (vflag_atom && atom->nmax > maxvatom) {
pair.cpp:    maxvatom = atom->nmax;
pair.cpp:  if (cvflag_atom && atom->nmax > maxcvatom) {
pair.cpp:    maxcvatom = atom->nmax;
pair.cpp:    n = atom->nlocal;
pair.cpp:    if (force->newton) n += atom->nghost;
pair.cpp:    n = atom->nlocal;
pair.cpp:    if (force->newton) n += atom->nghost;
pair.cpp:    n = atom->nlocal;
pair.cpp:    if (force->newton) n += atom->nghost;
pair.cpp:   at this point, only pairwise forces have been accumulated in atom->f
pair.cpp:  double **x = atom->x;
pair.cpp:  double **f = atom->f;
pair.cpp:    int nall = atom->nlocal + atom->nghost;
pair.cpp:    int nall = atom->nfirst;
pair.cpp:    nall = atom->nlocal + atom->nghost;
pair.cpp:    for (int i = atom->nlocal; i < nall; i++) {
pair.cpp:  if (itype < 1 || itype > atom->ntypes || jtype < 1 || jtype > atom->ntypes)
pair.cpp:  if (atom->q) {
pair.cpp:    q_hold = atom->q;
pair.cpp:    atom->q = q;
pair.cpp:  if (atom->q) atom->q = q_hold;
pair_hybrid.cpp:      n = atom->nlocal;
pair_hybrid.cpp:      if (force->newton_pair) n += atom->nghost;
pair_hybrid.cpp:      n = atom->nlocal;
pair_hybrid.cpp:      if (force->newton_pair) n += atom->nghost;
pair_hybrid.cpp:      n = atom->nlocal;
pair_hybrid.cpp:      if (force->newton_pair) n += atom->nghost;
pair_hybrid.cpp:  int n = atom->ntypes;
pair_hybrid.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_hybrid.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_hybrid.cpp:    for (int i = 1; i <= atom->ntypes; i++)
pair_hybrid.cpp:      for (int j = i; j <= atom->ntypes; j++)
pair_hybrid.cpp:  int ntypes = atom->ntypes;
pair_hybrid_overlay.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_hybrid_overlay.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_hybrid_scaled.cpp:  if (atom->nmax > nmaxfsum) {
pair_hybrid_scaled.cpp:    if (atom->torque_flag) memory->destroy(tsum);
pair_hybrid_scaled.cpp:    nmaxfsum = atom->nmax;
pair_hybrid_scaled.cpp:    if (atom->torque_flag) memory->create(tsum, nmaxfsum, 3, "pair:tsum");
pair_hybrid_scaled.cpp:  const int nall = atom->nlocal + atom->nghost;
pair_hybrid_scaled.cpp:  auto f = atom->f;
pair_hybrid_scaled.cpp:  auto t = atom->torque;
pair_hybrid_scaled.cpp:    if (atom->torque_flag) {
pair_hybrid_scaled.cpp:    if (atom->torque_flag) memset(&t[0][0], 0, nall * 3 * sizeof(double));
pair_hybrid_scaled.cpp:      if (atom->torque_flag) {
pair_hybrid_scaled.cpp:      n = atom->nlocal;
pair_hybrid_scaled.cpp:      if (force->newton_pair) n += atom->nghost;
pair_hybrid_scaled.cpp:      n = atom->nlocal;
pair_hybrid_scaled.cpp:      if (force->newton_pair) n += atom->nghost;
pair_hybrid_scaled.cpp:      n = atom->nlocal;
pair_hybrid_scaled.cpp:      if (force->newton_pair) n += atom->nghost;
pair_hybrid_scaled.cpp:    if (atom->torque_flag) {
pair_hybrid_scaled.cpp:  if (atom->avec->forceclearflag)
pair_hybrid_scaled.cpp:  utils::bounds(FLERR, arg[0], 1, atom->ntypes, ilo, ihi, error);
pair_hybrid_scaled.cpp:  utils::bounds(FLERR, arg[1], 1, atom->ntypes, jlo, jhi, error);
pair_lj_cut_coul_cut.cpp:  double **x = atom->x;
pair_lj_cut_coul_cut.cpp:  double **f = atom->f;
pair_lj_cut_coul_cut.cpp:  double *q = atom->q;
pair_lj_cut_coul_cut.cpp:  int *type = atom->type;
pair_lj_cut_coul_cut.cpp:  int nlocal = atom->nlocal;
pair_lj_cut_coul_cut.cpp:  int n = atom->ntypes;
pair_lj_cut_coul_cut.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_lj_cut_coul_cut.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_lj_cut_coul_cut.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_lj_cut_coul_cut.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_lj_cut_coul_cut.cpp:  if (!atom->q_flag)
pair_lj_cut_coul_cut.cpp:    int *type = atom->type;
pair_lj_cut_coul_cut.cpp:    int nlocal = atom->nlocal;
pair_lj_cut_coul_cut.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_lj_cut_coul_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_lj_cut_coul_cut.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_lj_cut_coul_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_lj_cut_coul_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_lj_cut_coul_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_lj_cut_coul_cut.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_lj_cut_coul_cut.cpp:    forcecoul = force->qqrd2e * atom->q[i]*atom->q[j]*sqrt(r2inv);
pair_lj_cut_coul_cut.cpp:    phicoul = force->qqrd2e * atom->q[i]*atom->q[j]*sqrt(r2inv);
pair_lj_cut.cpp:  double **x = atom->x;
pair_lj_cut.cpp:  double **f = atom->f;
pair_lj_cut.cpp:  int *type = atom->type;
pair_lj_cut.cpp:  int nlocal = atom->nlocal;
pair_lj_cut.cpp:  double **x = atom->x;
pair_lj_cut.cpp:  double **f = atom->f;
pair_lj_cut.cpp:  int *type = atom->type;
pair_lj_cut.cpp:  int nlocal = atom->nlocal;
pair_lj_cut.cpp:  double **x = atom->x;
pair_lj_cut.cpp:  double **f = atom->f;
pair_lj_cut.cpp:  int *type = atom->type;
pair_lj_cut.cpp:  int nlocal = atom->nlocal;
pair_lj_cut.cpp:  double **x = atom->x;
pair_lj_cut.cpp:  double **f = atom->f;
pair_lj_cut.cpp:  int *type = atom->type;
pair_lj_cut.cpp:  int nlocal = atom->nlocal;
pair_lj_cut.cpp:  int n = atom->ntypes + 1;
pair_lj_cut.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_lj_cut.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_lj_cut.cpp:  utils::bounds(FLERR, arg[0], 1, atom->ntypes, ilo, ihi, error);
pair_lj_cut.cpp:  utils::bounds(FLERR, arg[1], 1, atom->ntypes, jlo, jhi, error);
pair_lj_cut.cpp:    int *type = atom->type;
pair_lj_cut.cpp:    int nlocal = atom->nlocal;
pair_lj_cut.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_lj_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_lj_cut.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_lj_cut.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_lj_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++) fprintf(fp, "%d %g %g\n", i, epsilon[i][i], sigma[i][i]);
pair_lj_cut.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_lj_cut.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_lj_expand.cpp:  double **x = atom->x;
pair_lj_expand.cpp:  double **f = atom->f;
pair_lj_expand.cpp:  int *type = atom->type;
pair_lj_expand.cpp:  int nlocal = atom->nlocal;
pair_lj_expand.cpp:  int n = atom->ntypes;
pair_lj_expand.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_lj_expand.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_lj_expand.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_lj_expand.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_lj_expand.cpp:    int *type = atom->type;
pair_lj_expand.cpp:    int nlocal = atom->nlocal;
pair_lj_expand.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_lj_expand.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_lj_expand.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_lj_expand.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_lj_expand.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_lj_expand.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_lj_expand.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_morse.cpp:  double **x = atom->x;
pair_morse.cpp:  double **f = atom->f;
pair_morse.cpp:  int *type = atom->type;
pair_morse.cpp:  int nlocal = atom->nlocal;
pair_morse.cpp:  int n = atom->ntypes;
pair_morse.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_morse.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_morse.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_morse.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_morse.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_morse.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_morse.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_morse.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_morse.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_morse.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_morse.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_soft.cpp:  double **x = atom->x;
pair_soft.cpp:  double **f = atom->f;
pair_soft.cpp:  int *type = atom->type;
pair_soft.cpp:  int nlocal = atom->nlocal;
pair_soft.cpp:  int n = atom->ntypes;
pair_soft.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_soft.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_soft.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_soft.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_soft.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_soft.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_soft.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_soft.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_soft.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_soft.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_soft.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_table.cpp:  double **x = atom->x;
pair_table.cpp:  double **f = atom->f;
pair_table.cpp:  int *type = atom->type;
pair_table.cpp:  int nlocal = atom->nlocal;
pair_table.cpp:  const int nt = atom->ntypes + 1;
pair_table.cpp:  utils::bounds(FLERR, arg[0], 1, atom->ntypes, ilo, ihi, error);
pair_table.cpp:  utils::bounds(FLERR, arg[1], 1, atom->ntypes, jlo, jhi, error);
pair_yukawa.cpp:  double **x = atom->x;
pair_yukawa.cpp:  double **f = atom->f;
pair_yukawa.cpp:  int *type = atom->type;
pair_yukawa.cpp:  int nlocal = atom->nlocal;
pair_yukawa.cpp:  int n = atom->ntypes;
pair_yukawa.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_yukawa.cpp:      for (j = i; j <= atom->ntypes; j++)
pair_yukawa.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_yukawa.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_yukawa.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_yukawa.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_yukawa.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_yukawa.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_yukawa.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_yukawa.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_yukawa.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_zbl.cpp:  double **x = atom->x;
pair_zbl.cpp:  double **f = atom->f;
pair_zbl.cpp:  int *type = atom->type;
pair_zbl.cpp:  int nlocal = atom->nlocal;
pair_zbl.cpp:  int n = atom->ntypes;
pair_zbl.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_zbl.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_zbl.cpp:  for (i = 1; i <= atom->ntypes; i++) {
pair_zbl.cpp:  for (i = 1; i <= atom->ntypes; i++) {
pair_zbl.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_zbl.cpp:    for (j = 1; j <= atom->ntypes; j++)
pair_zbl.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_zbl.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_zbl.cpp:    for (int j = i; j <= atom->ntypes; j++)
pair_zero.cpp:  int n = atom->ntypes;
pair_zero.cpp:    for (i = 1; i <= atom->ntypes; i++)
pair_zero.cpp:      for (j = i+1; j <= atom->ntypes; j++)
pair_zero.cpp:  utils::bounds(FLERR,arg[0],1,atom->ntypes,ilo,ihi,error);
pair_zero.cpp:  utils::bounds(FLERR,arg[1],1,atom->ntypes,jlo,jhi,error);
pair_zero.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_zero.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_zero.cpp:  for (i = 1; i <= atom->ntypes; i++)
pair_zero.cpp:    for (j = i; j <= atom->ntypes; j++) {
pair_zero.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_zero.cpp:  for (int i = 1; i <= atom->ntypes; i++)
pair_zero.cpp:    for (int j = i; j <= atom->ntypes; j++)
read_data.cpp:  avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
read_data.cpp:  avec_line = (AtomVecLine *) atom->style_match("line");
read_data.cpp:  avec_tri = (AtomVecTri *) atom->style_match("tri");
read_data.cpp:  avec_body = (AtomVecBody *) atom->style_match("body");
read_data.cpp:        if (atom->molecule_flag && (iarg+3 > narg))
read_data.cpp:        if (atom->molecule_flag) {
read_data.cpp:      if (!atom->avec->bonds_allow)
read_data.cpp:      if (!atom->avec->angles_allow)
read_data.cpp:      if (!atom->avec->dihedrals_allow)
read_data.cpp:      if (!atom->avec->impropers_allow)
read_data.cpp:      if (atom->molecular == Atom::ATOMIC)
read_data.cpp:      atom->extra_bond_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
read_data.cpp:      if (atom->extra_bond_per_atom < 0)
read_data.cpp:      if (atom->molecular == Atom::ATOMIC)
read_data.cpp:      atom->extra_angle_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
read_data.cpp:      if (atom->extra_angle_per_atom < 0)
read_data.cpp:      if (atom->molecular == Atom::ATOMIC)
read_data.cpp:      atom->extra_dihedral_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
read_data.cpp:      if (atom->extra_dihedral_per_atom < 0)
read_data.cpp:      if (atom->molecular == Atom::ATOMIC)
read_data.cpp:      atom->extra_improper_per_atom = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
read_data.cpp:      if (atom->extra_improper_per_atom < 0)
read_data.cpp:      if (atom->molecular == Atom::ATOMIC)
read_data.cpp:    tagint *tag = atom->tag;
read_data.cpp:    tagint *molecule = atom->molecule;
read_data.cpp:    int nlocal = atom->nlocal;
read_data.cpp:    if (atom->molecule_flag)
read_data.cpp:  nlocal_previous = atom->nlocal;
read_data.cpp:      atom->bond_per_atom = atom->extra_bond_per_atom;
read_data.cpp:      atom->angle_per_atom = atom->extra_angle_per_atom;
read_data.cpp:      atom->dihedral_per_atom = atom->extra_dihedral_per_atom;
read_data.cpp:      atom->improper_per_atom = atom->extra_improper_per_atom;
read_data.cpp:      if (comm->nprocs == 1) n = static_cast<int> (atom->natoms);
read_data.cpp:      else n = static_cast<int> (LB_FACTOR * atom->natoms / comm->nprocs);
read_data.cpp:      atom->allocate_type_arrays();
read_data.cpp:      atom->deallocate_topology();
read_data.cpp:      nbig = atom->avec->roundup(nbig);
read_data.cpp:      atom->avec->grow(n);
read_data.cpp:          if (me == 0 && !style_match(style,atom->atom_style))
read_data.cpp:        if (atom->avec->bonds_allow == 0)
read_data.cpp:        if (atom->avec->angles_allow == 0)
read_data.cpp:        if (atom->avec->dihedrals_allow == 0)
read_data.cpp:        if (atom->avec->impropers_allow == 0)
read_data.cpp:        if (atom->avec->angles_allow == 0)
read_data.cpp:        if (atom->avec->angles_allow == 0)
read_data.cpp:        if (atom->avec->dihedrals_allow == 0)
read_data.cpp:        if (atom->avec->dihedrals_allow == 0)
read_data.cpp:        if (atom->avec->dihedrals_allow == 0)
read_data.cpp:        if (atom->avec->dihedrals_allow == 0)
read_data.cpp:        if (atom->avec->dihedrals_allow == 0)
read_data.cpp:        if (atom->avec->impropers_allow == 0)
read_data.cpp:    if (addflag == NONE) atom->deallocate_topology();
read_data.cpp:    atom->avec->grow(atom->nmax);
read_data.cpp:  atom->data_fix_compute_variable(nlocal_previous,atom->nlocal);
read_data.cpp:    int *mask = atom->mask;
read_data.cpp:    int nlocal = atom->nlocal;
read_data.cpp:  if (atom->molecular == Atom::MOLECULAR) {
read_data.cpp:  if (atom->molecular == Atom::TEMPLATE) {
read_data.cpp:    Molecule **onemols = atom->avec->onemols;
read_data.cpp:    int *molindex = atom->molindex;
read_data.cpp:    int *molatom = atom->molatom;
read_data.cpp:    int nlocal = atom->nlocal;
read_data.cpp:    MPI_Allreduce(&nbonds,&atom->nbonds,1,MPI_LMP_BIGINT,MPI_SUM,world);
read_data.cpp:    MPI_Allreduce(&nangles,&atom->nangles,1,MPI_LMP_BIGINT,MPI_SUM,world);
read_data.cpp:    MPI_Allreduce(&ndihedrals,&atom->ndihedrals,1,MPI_LMP_BIGINT,MPI_SUM,world);
read_data.cpp:    MPI_Allreduce(&nimpropers,&atom->nimpropers,1,MPI_LMP_BIGINT,MPI_SUM,world);
read_data.cpp:      if (atom->nbonds)
read_data.cpp:        mesg += fmt::format("  {} template bonds\n",atom->nbonds);
read_data.cpp:      if (atom->nangles)
read_data.cpp:        mesg += fmt::format("  {} template angles\n",atom->nangles);
read_data.cpp:      if (atom->ndihedrals)
read_data.cpp:        mesg += fmt::format("  {} template dihedrals\n",atom->ndihedrals);
read_data.cpp:      if (atom->nimpropers)
read_data.cpp:        mesg += fmt::format("  {} template impropers\n",atom->nimpropers);
read_data.cpp:  if (atom->molecular == Atom::TEMPLATE) atom->avec->onemols[0]->check_attributes(1);
read_data.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
read_data.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal);
read_data.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
read_data.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal);
read_data.cpp:    bigint nblocal = atom->nlocal;
read_data.cpp:    if (natoms != atom->natoms)
read_data.cpp:    atom->ntypes = extra_atom_types;
read_data.cpp:    atom->nbondtypes = extra_bond_types;
read_data.cpp:    atom->nangletypes = extra_angle_types;
read_data.cpp:    atom->ndihedraltypes = extra_dihedral_types;
read_data.cpp:    atom->nimpropertypes = extra_improper_types;
read_data.cpp:      if (addflag == NONE) atom->natoms = natoms;
read_data.cpp:      else if (firstpass) atom->natoms += natoms;
read_data.cpp:      if (addflag == NONE) atom->nellipsoids = nellipsoids;
read_data.cpp:      else if (firstpass) atom->nellipsoids += nellipsoids;
read_data.cpp:      if (addflag == NONE) atom->nlines = nlines;
read_data.cpp:      else if (firstpass) atom->nlines += nlines;
read_data.cpp:      if (addflag == NONE) atom->ntris = ntris;
read_data.cpp:      else if (firstpass) atom->ntris += ntris;
read_data.cpp:      if (addflag == NONE) atom->nbodies = nbodies;
read_data.cpp:      else if (firstpass) atom->nbodies += nbodies;
read_data.cpp:      if (addflag == NONE) atom->nbonds = nbonds;
read_data.cpp:      else if (firstpass) atom->nbonds += nbonds;
read_data.cpp:      if (addflag == NONE) atom->nangles = nangles;
read_data.cpp:      else if (firstpass) atom->nangles += nangles;
read_data.cpp:      if (addflag == NONE) atom->ndihedrals = ndihedrals;
read_data.cpp:      else if (firstpass) atom->ndihedrals += ndihedrals;
read_data.cpp:      if (addflag == NONE) atom->nimpropers = nimpropers;
read_data.cpp:      else if (firstpass) atom->nimpropers += nimpropers;
read_data.cpp:      if (addflag == NONE) atom->ntypes = ntypes + extra_atom_types;
read_data.cpp:      if (addflag == NONE) atom->nbondtypes = nbondtypes + extra_bond_types;
read_data.cpp:      if (addflag == NONE) atom->nangletypes = nangletypes + extra_angle_types;
read_data.cpp:        atom->ndihedraltypes = ndihedraltypes + extra_dihedral_types;
read_data.cpp:        atom->nimpropertypes = nimpropertypes + extra_improper_types;
read_data.cpp:      atom->extra_bond_per_atom = MAX(atom->extra_bond_per_atom,extra_flag_value);
read_data.cpp:      atom->extra_angle_per_atom = MAX(atom->extra_angle_per_atom,extra_flag_value);
read_data.cpp:      atom->extra_dihedral_per_atom = MAX(atom->extra_dihedral_per_atom,extra_flag_value);
read_data.cpp:      atom->extra_improper_per_atom = MAX(atom->extra_improper_per_atom,extra_flag_value);
read_data.cpp:  if (atom->natoms < 0 || atom->natoms >= MAXBIGINT ||
read_data.cpp:      atom->nellipsoids < 0 || atom->nellipsoids >= MAXBIGINT ||
read_data.cpp:      atom->nlines < 0 || atom->nlines >= MAXBIGINT ||
read_data.cpp:      atom->ntris < 0 || atom->ntris >= MAXBIGINT ||
read_data.cpp:      atom->nbodies < 0 || atom->nbodies >= MAXBIGINT ||
read_data.cpp:      atom->nbonds < 0 || atom->nbonds >= MAXBIGINT ||
read_data.cpp:      atom->nangles < 0 || atom->nangles >= MAXBIGINT ||
read_data.cpp:      atom->ndihedrals < 0 || atom->ndihedrals >= MAXBIGINT ||
read_data.cpp:      atom->nimpropers < 0 || atom->nimpropers >= MAXBIGINT)
read_data.cpp:  if ((atom->nbonds || atom->nbondtypes) &&
read_data.cpp:      atom->avec->bonds_allow == 0)
read_data.cpp:  if ((atom->nangles || atom->nangletypes) &&
read_data.cpp:      atom->avec->angles_allow == 0)
read_data.cpp:  if ((atom->ndihedrals || atom->ndihedraltypes) &&
read_data.cpp:      atom->avec->dihedrals_allow == 0)
read_data.cpp:  if ((atom->nimpropers || atom->nimpropertypes) &&
read_data.cpp:      atom->avec->impropers_allow == 0)
read_data.cpp:  if (atom->nbonds > 0 && atom->nbondtypes <= 0)
read_data.cpp:  if (atom->nangles > 0 && atom->nangletypes <= 0)
read_data.cpp:  if (atom->ndihedrals > 0 && atom->ndihedraltypes <= 0)
read_data.cpp:  if (atom->nimpropers > 0 && atom->nimpropertypes <= 0)
read_data.cpp:  if (atom->molecular == Atom::TEMPLATE) {
read_data.cpp:    if (atom->nbonds || atom->nangles || atom->ndihedrals || atom->nimpropers)
read_data.cpp:    atom->data_atoms(nchunk,buffer,id_offset,mol_offset,toffset,shiftflag,shift);
read_data.cpp:  bigint n = atom->nlocal;
read_data.cpp:  bigint nassign = sum - (atom->natoms - natoms);
read_data.cpp:  if (sum != atom->natoms)
read_data.cpp:  atom->tag_check();
read_data.cpp:  atom->bonus_check();
read_data.cpp:  if (atom->map_style != Atom::MAP_NONE) {
read_data.cpp:    atom->map_init();
read_data.cpp:    atom->map_set();
read_data.cpp:  if (atom->map_style == Atom::MAP_NONE) {
read_data.cpp:    atom->map_init();
read_data.cpp:    atom->map_set();
read_data.cpp:    atom->data_vels(nchunk,buffer,id_offset);
read_data.cpp:    atom->map_delete();
read_data.cpp:    atom->map_style = Atom::MAP_NONE;
read_data.cpp:  int nlocal = atom->nlocal;
read_data.cpp:    atom->data_bonds(nchunk,buffer,count,id_offset,boffset);
read_data.cpp:    if (addflag == NONE) maxall += atom->extra_bond_per_atom;
read_data.cpp:      if (maxall > atom->bond_per_atom)
read_data.cpp:    } else atom->bond_per_atom = maxall;
read_data.cpp:  for (int i = nlocal_previous; i < nlocal; i++) n += atom->num_bond[i];
read_data.cpp:  int nlocal = atom->nlocal;
read_data.cpp:    atom->data_angles(nchunk,buffer,count,id_offset,aoffset);
read_data.cpp:    if (addflag == NONE) maxall += atom->extra_angle_per_atom;
read_data.cpp:      if (maxall > atom->angle_per_atom)
read_data.cpp:    } else atom->angle_per_atom = maxall;
read_data.cpp:  for (int i = nlocal_previous; i < nlocal; i++) n += atom->num_angle[i];
read_data.cpp:  int nlocal = atom->nlocal;
read_data.cpp:    atom->data_dihedrals(nchunk,buffer,count,id_offset,doffset);
read_data.cpp:    if (addflag == NONE) maxall += atom->extra_dihedral_per_atom;
read_data.cpp:      if (maxall > atom->dihedral_per_atom)
read_data.cpp:    } else atom->dihedral_per_atom = maxall;
read_data.cpp:  for (int i = nlocal_previous; i < nlocal; i++) n += atom->num_dihedral[i];
read_data.cpp:  int nlocal = atom->nlocal;
read_data.cpp:    atom->data_impropers(nchunk,buffer,count,id_offset,ioffset);
read_data.cpp:    if (addflag == NONE) maxall += atom->extra_improper_per_atom;
read_data.cpp:      if (maxall > atom->improper_per_atom)
read_data.cpp:    } else atom->improper_per_atom = maxall;
read_data.cpp:  for (int i = nlocal_previous; i < nlocal; i++) n += atom->num_improper[i];
read_data.cpp:  if (atom->map_style == Atom::MAP_NONE) {
read_data.cpp:    atom->map_init();
read_data.cpp:    atom->map_set();
read_data.cpp:    atom->data_bonus(nchunk,buffer,ptr,id_offset);
read_data.cpp:    atom->map_delete();
read_data.cpp:    atom->map_style = Atom::MAP_NONE;
read_data.cpp:  if (atom->map_style == Atom::MAP_NONE && firstpass) {
read_data.cpp:    atom->map_init();
read_data.cpp:    atom->map_set();
read_data.cpp:    if (firstpass) atom->data_bodies(nchunk,buffer,ptr,id_offset);
read_data.cpp:    atom->map_delete();
read_data.cpp:    atom->map_style = Atom::MAP_NONE;
read_data.cpp:    atom->set_mass(FLERR,buf,toffset);
read_dump.cpp:  bigint natoms_prev = atom->natoms;
read_dump.cpp:                   npurge_all,nreplace_all,ntrim_all,nadd_all,atom->natoms);
read_dump.cpp:    if (atom->map_style != Atom::MAP_NONE) atom->map_clear();
read_dump.cpp:    npurge = atom->nlocal;
read_dump.cpp:    atom->nlocal = atom->nghost = 0;
read_dump.cpp:    atom->natoms = 0;
read_dump.cpp:  if (atom->map_style == Atom::MAP_NONE) {
read_dump.cpp:    atom->map_init();
read_dump.cpp:    atom->map_set();
read_dump.cpp:  atom->tag_check();
read_dump.cpp:    atom->map_delete();
read_dump.cpp:    atom->map_style = Atom::MAP_NONE;
read_dump.cpp:    atom->nghost = 0;
read_dump.cpp:    atom->map_init();
read_dump.cpp:    atom->map_set();
read_dump.cpp:  int nlocal = atom->nlocal;
read_dump.cpp:  double **x = atom->x;
read_dump.cpp:  double **v = atom->v;
read_dump.cpp:  double *q = atom->q;
read_dump.cpp:  double **f = atom->f;
read_dump.cpp:  tagint *tag = atom->tag;
read_dump.cpp:  imageint *image = atom->image;
read_dump.cpp:  tagint map_tag_max = atom->map_tag_max;
read_dump.cpp:    if (mtag <= map_tag_max) m = atom->map(mtag);
read_dump.cpp:    AtomVec *avec = atom->avec;
read_dump.cpp:    atom->nlocal = nlocal;
read_dump.cpp:    bigint nblocal = atom->nlocal;
read_dump.cpp:    MPI_Allreduce(&nblocal,&atom->natoms,1,MPI_LMP_BIGINT,MPI_SUM,world);
read_dump.cpp:  int nlocal_previous = atom->nlocal;
read_dump.cpp:    m = atom->nlocal;
read_dump.cpp:    atom->avec->create_atom(itype,one);
read_dump.cpp:    tag = atom->tag;
read_dump.cpp:    v = atom->v;
read_dump.cpp:    q = atom->q;
read_dump.cpp:    image = atom->image;
read_dump.cpp:    bigint nblocal = atom->nlocal;
read_dump.cpp:    MPI_Allreduce(&nblocal,&atom->natoms,1,MPI_LMP_BIGINT,MPI_SUM,world);
read_dump.cpp:    if (atom->natoms < 0 || atom->natoms >= MAXBIGINT)
read_dump.cpp:    if (atom->tag_enable) atom->tag_extend();
read_dump.cpp:  atom->data_fix_compute_variable(nlocal_previous,atom->nlocal);
read_dump.cpp:  tagint *tag = atom->tag;
read_dump.cpp:  int nlocal = atom->nlocal;
read_dump.cpp:  double **x = atom->x;
read_dump.cpp:  imageint *image = atom->image;
read_dump.cpp:  int nlocal = atom->nlocal;
read_dump.cpp:  if (triclinic) domain->x2lamda(atom->nlocal);
read_dump.cpp:  if (triclinic) domain->lamda2x(atom->nlocal);
read_dump.cpp:    if (type == Q && !atom->q_flag)
read_dump.cpp:  if (addflag == KEEPADD && atom->tag_enable == 0)
read_restart.cpp:  if (nprocs == 1) n = static_cast<int> (atom->natoms);
read_restart.cpp:  else n = static_cast<int> (LB_FACTOR * atom->natoms / nprocs);
read_restart.cpp:  atom->allocate_type_arrays();
read_restart.cpp:  atom->deallocate_topology();
read_restart.cpp:  nbig = atom->avec->roundup(nbig);
read_restart.cpp:  atom->avec->grow(n);
read_restart.cpp:  n = atom->nmax;
read_restart.cpp:  atom->nextra_store = nextra;
read_restart.cpp:  memory->create(atom->extra,n,nextra,"atom:extra");
read_restart.cpp:  AtomVec *avec = atom->avec;
read_restart.cpp:      atom->nlocal = 1; // temporarily claim there is one atom...
read_restart.cpp:      atom->nlocal = 0; // restore nlocal to zero atoms
read_restart.cpp:      if (atomCt > atom->nmax) avec->grow(atomCt);
read_restart.cpp:      double **x = atom->x;
read_restart.cpp:      imageint *image = atom->image;
read_restart.cpp:      int nlocal = atom->nlocal;
read_restart.cpp:    if (atom->map_style != Atom::MAP_NONE) {
read_restart.cpp:      atom->map_init();
read_restart.cpp:      atom->map_set();
read_restart.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
read_restart.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal);
read_restart.cpp:    // put extra atom info held by fix back into atom->extra
read_restart.cpp:      memory->destroy(atom->extra);
read_restart.cpp:      memory->create(atom->extra,atom->nmax,nextra,"atom:extra");
read_restart.cpp:      double **atom_extra = atom->extra;
read_restart.cpp:      int nlocal = atom->nlocal;
read_restart.cpp:  bigint nblocal = atom->nlocal;
read_restart.cpp:  if (natoms != atom->natoms)
read_restart.cpp:  if ((atom->molecular == Atom::TEMPLATE) && (me == 0)) {
read_restart.cpp:    if (atom->nbonds)
read_restart.cpp:      mesg += fmt::format("  {} template bonds\n",atom->nbonds);
read_restart.cpp:    if (atom->nangles)
read_restart.cpp:      mesg += fmt::format("  {} template angles\n",atom->nangles);
read_restart.cpp:    if (atom->ndihedrals)
read_restart.cpp:      mesg += fmt::format("  {} template dihedrals\n",atom->ndihedrals);
read_restart.cpp:    if (atom->nimpropers)
read_restart.cpp:      mesg += fmt::format("  {} template impropers\n",atom->nimpropers);
read_restart.cpp:  if ((atom->molecular == Atom::MOLECULAR) && (me == 0)) {
read_restart.cpp:    if (atom->nbonds)
read_restart.cpp:      mesg += fmt::format("  {} bonds\n",atom->nbonds);
read_restart.cpp:    if (atom->nangles)
read_restart.cpp:      mesg += fmt::format("  {} angles\n",atom->nangles);
read_restart.cpp:    if (atom->ndihedrals)
read_restart.cpp:      mesg += fmt::format("  {} dihedrals\n",atom->ndihedrals);
read_restart.cpp:    if (atom->nimpropers)
read_restart.cpp:      mesg += fmt::format("  {} impropers\n",atom->nimpropers);
read_restart.cpp:  atom->tag_check();
read_restart.cpp:  if (atom->map_style != Atom::MAP_NONE) {
read_restart.cpp:    atom->map_init();
read_restart.cpp:    atom->map_set();
read_restart.cpp:  if (atom->molecular == Atom::MOLECULAR) {
read_restart.cpp:      atom->create_avec(style,nargcopy,argcopy,1);
read_restart.cpp:      atom->natoms = read_bigint();
read_restart.cpp:      atom->ntypes = read_int();
read_restart.cpp:      atom->nbonds = read_bigint();
read_restart.cpp:      atom->nbondtypes = read_int();
read_restart.cpp:      atom->bond_per_atom = read_int();
read_restart.cpp:      atom->nangles = read_bigint();
read_restart.cpp:      atom->nangletypes = read_int();
read_restart.cpp:      atom->angle_per_atom = read_int();
read_restart.cpp:      atom->ndihedrals = read_bigint();
read_restart.cpp:      atom->ndihedraltypes = read_int();
read_restart.cpp:      atom->dihedral_per_atom = read_int();
read_restart.cpp:      atom->nimpropers = read_bigint();
read_restart.cpp:      atom->nimpropertypes = read_int();
read_restart.cpp:      atom->improper_per_atom = read_int();
read_restart.cpp:      atom->tag_enable = read_int();
read_restart.cpp:      atom->map_style = read_int();
read_restart.cpp:      atom->map_user  = read_int();
read_restart.cpp:      atom->sortfreq = read_int();
read_restart.cpp:      atom->userbinsize = read_double();
read_restart.cpp:      atom->extra_bond_per_atom = read_int();
read_restart.cpp:      atom->extra_angle_per_atom = read_int();
read_restart.cpp:      atom->extra_dihedral_per_atom = read_int();
read_restart.cpp:      atom->extra_improper_per_atom = read_int();
read_restart.cpp:      atom->maxspecial = read_int();
read_restart.cpp:      atom->nellipsoids = read_bigint();
read_restart.cpp:      atom->nlines = read_bigint();
read_restart.cpp:      atom->ntris = read_bigint();
read_restart.cpp:      atom->nbodies = read_bigint();
read_restart.cpp:      double *mass = new double[atom->ntypes+1];
read_restart.cpp:      read_double_vec(atom->ntypes,&mass[1]);
read_restart.cpp:      atom->set_mass(mass);
read_restart.cpp:          if ((nprocs != nprocs_file) && !(atom->nextra_store)) {
read_restart.cpp:            atom->nlocal = 1; // temporarily claim there is one atom...
read_restart.cpp:            int perAtomSize = atom->avec->size_restart(); // ...so we can get its size
read_restart.cpp:            atom->nlocal = 0; // restore nlocal to zero atoms
replicate.cpp:  if (atom->nextra_grow || atom->nextra_restart || atom->nextra_store)
replicate.cpp:  if (atom->tag_enable) {
replicate.cpp:    for (i = 0; i < atom->nlocal; i++) maxtag = MAX(atom->tag[i],maxtag);
replicate.cpp:  if (atom->molecule_flag) {
replicate.cpp:    for (i = 0; i < atom->nlocal; i++) maxmol = MAX(atom->molecule[i],maxmol);
replicate.cpp:    for (i=0; i<atom->nlocal; ++i) {
replicate.cpp:      imageint image = atom->image[i];
replicate.cpp:  for (i = 0; i < atom->nlocal; i++)
replicate.cpp:    domain->unmap(atom->x[i],atom->image[i]);
replicate.cpp:  //   since size_restart() uses atom->nlocal
replicate.cpp:  int send_size = atom->avec->size_restart();
replicate.cpp:  atom->settings(old);
replicate.cpp:    atom->molecules = (Molecule **) memory->smalloc((old->nmolecule)*sizeof(Molecule *),
replicate.cpp:    atom->nmolecule = old->nmolecule;
replicate.cpp:      atom->molecules[i] = old->molecules[i];
replicate.cpp:  atom->create_avec(old->atom_style,old->avec->nargcopy,old->avec->argcopy,0);
replicate.cpp:  if (atom->tag_enable) {
replicate.cpp:  atom->natoms = old->natoms * nrep;
replicate.cpp:  atom->nbonds = old->nbonds * nrep;
replicate.cpp:  atom->nangles = old->nangles * nrep;
replicate.cpp:  atom->ndihedrals = old->ndihedrals * nrep;
replicate.cpp:  atom->nimpropers = old->nimpropers * nrep;
replicate.cpp:  atom->nellipsoids = old->nellipsoids * nrep;
replicate.cpp:  atom->nlines = old->nlines * nrep;
replicate.cpp:  atom->ntris = old->ntris * nrep;
replicate.cpp:  atom->nbodies = old->nbodies * nrep;
replicate.cpp:  atom->ntypes = old->ntypes;
replicate.cpp:  atom->nbondtypes = old->nbondtypes;
replicate.cpp:  atom->nangletypes = old->nangletypes;
replicate.cpp:  atom->ndihedraltypes = old->ndihedraltypes;
replicate.cpp:  atom->nimpropertypes = old->nimpropertypes;
replicate.cpp:  atom->bond_per_atom = old->bond_per_atom;
replicate.cpp:  atom->angle_per_atom = old->angle_per_atom;
replicate.cpp:  atom->dihedral_per_atom = old->dihedral_per_atom;
replicate.cpp:  atom->improper_per_atom = old->improper_per_atom;
replicate.cpp:  atom->extra_bond_per_atom = old->extra_bond_per_atom;
replicate.cpp:  atom->extra_angle_per_atom = old->extra_angle_per_atom;
replicate.cpp:  atom->extra_dihedral_per_atom = old->extra_dihedral_per_atom;
replicate.cpp:  atom->extra_improper_per_atom = old->extra_improper_per_atom;
replicate.cpp:  atom->maxspecial = old->maxspecial;
replicate.cpp:  if (nprocs == 1) n = static_cast<int> (atom->natoms);
replicate.cpp:  else n = static_cast<int> (LB_FACTOR * atom->natoms / nprocs);
replicate.cpp:  atom->allocate_type_arrays();
replicate.cpp:  nbig = atom->avec->roundup(nbig);
replicate.cpp:  atom->avec->grow(n);
replicate.cpp:  n = atom->nmax;
replicate.cpp:  if (atom->mass) {
replicate.cpp:    for (int itype = 1; itype <= atom->ntypes; itype++) {
replicate.cpp:      atom->mass_setflag[itype] = old->mass_setflag[itype];
replicate.cpp:      if (atom->mass_setflag[itype]) atom->mass[itype] = old->mass[itype];
replicate.cpp:  AtomVec *avec = atom->avec;
replicate.cpp:  int tag_enable = atom->tag_enable;
replicate.cpp:                i = atom->nlocal - 1;
replicate.cpp:                atom->x[i][0] = x[0];
replicate.cpp:                atom->x[i][1] = x[1];
replicate.cpp:                atom->x[i][2] = x[2];
replicate.cpp:                atom->tag[i] += atom_offset;
replicate.cpp:                atom->image[i] = image;
replicate.cpp:                if (atom->molecular != Atom::ATOMIC) {
replicate.cpp:                  if (atom->molecule[i] > 0)
replicate.cpp:                    atom->molecule[i] += mol_offset;
replicate.cpp:                  if (atom->molecular == Atom::MOLECULAR) {
replicate.cpp:                    if (atom->avec->bonds_allow)
replicate.cpp:                      for (j = 0; j < atom->num_bond[i]; j++)
replicate.cpp:                        atom->bond_atom[i][j] += atom_offset;
replicate.cpp:                    if (atom->avec->angles_allow)
replicate.cpp:                      for (j = 0; j < atom->num_angle[i]; j++) {
replicate.cpp:                        atom->angle_atom1[i][j] += atom_offset;
replicate.cpp:                        atom->angle_atom2[i][j] += atom_offset;
replicate.cpp:                        atom->angle_atom3[i][j] += atom_offset;
replicate.cpp:                    if (atom->avec->dihedrals_allow)
replicate.cpp:                      for (j = 0; j < atom->num_dihedral[i]; j++) {
replicate.cpp:                        atom->dihedral_atom1[i][j] += atom_offset;
replicate.cpp:                        atom->dihedral_atom2[i][j] += atom_offset;
replicate.cpp:                        atom->dihedral_atom3[i][j] += atom_offset;
replicate.cpp:                        atom->dihedral_atom4[i][j] += atom_offset;
replicate.cpp:                    if (atom->avec->impropers_allow)
replicate.cpp:                      for (j = 0; j < atom->num_improper[i]; j++) {
replicate.cpp:                        atom->improper_atom1[i][j] += atom_offset;
replicate.cpp:                        atom->improper_atom2[i][j] += atom_offset;
replicate.cpp:                        atom->improper_atom3[i][j] += atom_offset;
replicate.cpp:                        atom->improper_atom4[i][j] += atom_offset;
replicate.cpp:                i = atom->nlocal - 1;
replicate.cpp:                atom->x[i][0] = x[0];
replicate.cpp:                atom->x[i][1] = x[1];
replicate.cpp:                atom->x[i][2] = x[2];
replicate.cpp:                atom->tag[i] += atom_offset;
replicate.cpp:                atom->image[i] = image;
replicate.cpp:                if (atom->molecular != Atom::ATOMIC) {
replicate.cpp:                  if (atom->molecule[i] > 0)
replicate.cpp:                    atom->molecule[i] += mol_offset;
replicate.cpp:                  if (atom->molecular == Atom::MOLECULAR) {
replicate.cpp:                    if (atom->avec->bonds_allow)
replicate.cpp:                      for (j = 0; j < atom->num_bond[i]; j++)
replicate.cpp:                        atom->bond_atom[i][j] += atom_offset;
replicate.cpp:                    if (atom->avec->angles_allow)
replicate.cpp:                      for (j = 0; j < atom->num_angle[i]; j++) {
replicate.cpp:                        atom->angle_atom1[i][j] += atom_offset;
replicate.cpp:                        atom->angle_atom2[i][j] += atom_offset;
replicate.cpp:                        atom->angle_atom3[i][j] += atom_offset;
replicate.cpp:                    if (atom->avec->dihedrals_allow)
replicate.cpp:                      for (j = 0; j < atom->num_dihedral[i]; j++) {
replicate.cpp:                        atom->dihedral_atom1[i][j] += atom_offset;
replicate.cpp:                        atom->dihedral_atom2[i][j] += atom_offset;
replicate.cpp:                        atom->dihedral_atom3[i][j] += atom_offset;
replicate.cpp:                        atom->dihedral_atom4[i][j] += atom_offset;
replicate.cpp:                    if (atom->avec->impropers_allow)
replicate.cpp:                      for (j = 0; j < atom->num_improper[i]; j++) {
replicate.cpp:                        atom->improper_atom1[i][j] += atom_offset;
replicate.cpp:                        atom->improper_atom2[i][j] += atom_offset;
replicate.cpp:                        atom->improper_atom3[i][j] += atom_offset;
replicate.cpp:                        atom->improper_atom4[i][j] += atom_offset;
replicate.cpp:  bigint nblocal = atom->nlocal;
replicate.cpp:  if (natoms != atom->natoms)
replicate.cpp:    if (atom->molecular == Atom::TEMPLATE) molstyle = "template ";
replicate.cpp:    if (atom->nbonds) {
replicate.cpp:      utils::logmesg(lmp,"  {} {}bonds\n",atom->nbonds,molstyle);
replicate.cpp:    if (atom->nangles) {
replicate.cpp:      utils::logmesg(lmp,"  {} {}angles\n",atom->nangles,molstyle);
replicate.cpp:    if (atom->ndihedrals) {
replicate.cpp:      utils::logmesg(lmp,"  {} {}dihedrals\n",atom->ndihedrals,molstyle);
replicate.cpp:    if (atom->nimpropers) {
replicate.cpp:      utils::logmesg(lmp,"  {} {}impropers\n",atom->nimpropers,molstyle);
replicate.cpp:  atom->tag_check();
replicate.cpp:  if (atom->map_style != Atom::MAP_NONE) {
replicate.cpp:    atom->map_init();
replicate.cpp:    atom->map_set();
replicate.cpp:  if (atom->molecular == Atom::MOLECULAR) {
reset_atom_ids.cpp:  if (atom->tag_enable == 0)
reset_atom_ids.cpp:  if (atom->map_style == Atom::MAP_NONE) {
reset_atom_ids.cpp:    atom->nghost = 0;
reset_atom_ids.cpp:    atom->map_init();
reset_atom_ids.cpp:    atom->map_set();
reset_atom_ids.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
reset_atom_ids.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
reset_atom_ids.cpp:  tagint *tag = atom->tag;
reset_atom_ids.cpp:  int nlocal = atom->nlocal;
reset_atom_ids.cpp:  int nall = nlocal + atom->nghost;
reset_atom_ids.cpp:  if (sortflag == 0) atom->tag_extend();
reset_atom_ids.cpp:  if (atom->molecular == Atom::MOLECULAR) {
reset_atom_ids.cpp:    if (atom->avec->bonds_allow) {
reset_atom_ids.cpp:      int *num_bond = atom->num_bond;
reset_atom_ids.cpp:      tagint **bond_atom = atom->bond_atom;
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:    if (atom->avec->angles_allow) {
reset_atom_ids.cpp:      int *num_angle = atom->num_angle;
reset_atom_ids.cpp:      tagint **angle_atom1 = atom->angle_atom1;
reset_atom_ids.cpp:      tagint **angle_atom2 = atom->angle_atom2;
reset_atom_ids.cpp:      tagint **angle_atom3 = atom->angle_atom3;
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:    if (atom->avec->dihedrals_allow) {
reset_atom_ids.cpp:      int *num_dihedral = atom->num_dihedral;
reset_atom_ids.cpp:      tagint **dihedral_atom1 = atom->dihedral_atom1;
reset_atom_ids.cpp:      tagint **dihedral_atom2 = atom->dihedral_atom2;
reset_atom_ids.cpp:      tagint **dihedral_atom3 = atom->dihedral_atom3;
reset_atom_ids.cpp:      tagint **dihedral_atom4 = atom->dihedral_atom4;
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:    if (atom->avec->impropers_allow) {
reset_atom_ids.cpp:      int *num_improper = atom->num_improper;
reset_atom_ids.cpp:      tagint **improper_atom1 = atom->improper_atom1;
reset_atom_ids.cpp:      tagint **improper_atom2 = atom->improper_atom2;
reset_atom_ids.cpp:      tagint **improper_atom3 = atom->improper_atom3;
reset_atom_ids.cpp:      tagint **improper_atom4 = atom->improper_atom4;
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:          m = atom->map(oldID);
reset_atom_ids.cpp:  atom->map_clear();
reset_atom_ids.cpp:  atom->nghost = 0;
reset_atom_ids.cpp:  atom->map_init();
reset_atom_ids.cpp:  atom->map_set();
reset_atom_ids.cpp:  if (atom->molecular == Atom::MOLECULAR) {
reset_atom_ids.cpp:    atom->map_delete();
reset_atom_ids.cpp:    atom->map_style = Atom::MAP_NONE;
reset_atom_ids.cpp:  double **x = atom->x;
reset_atom_ids.cpp:  int nlocal = atom->nlocal;
reset_atom_ids.cpp:  bigint nbin_estimate = atom->natoms / PERBIN + 1;
reset_atom_ids.cpp:    atom->tag[ilocal] = outbuf[i].newID;
reset_mol_ids.cpp:  if (atom->tag_enable == 0)
reset_mol_ids.cpp:  if (atom->molecular != Atom::MOLECULAR)
reset_mol_ids.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
reset_mol_ids.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
reset_mol_ids.cpp:  tagint *molecule = atom->molecule;
reset_mol_ids.cpp:  int *mask = atom->mask;
reset_mol_ids.cpp:  int nlocal = atom->nlocal;
respa.cpp:  // create fix needed for storing atom-based respa level forces
respa.cpp:  if (atom->torque_flag) cmd += " torque";
respa.cpp:  if (atom->torque_flag) torqueflag = 1;
respa.cpp:  if (atom->avec->forceclearflag) extraflag = 1;
respa.cpp:  atom->setup();
respa.cpp:  if (triclinic) domain->x2lamda(atom->nlocal);
respa.cpp:  if (atom->sortfreq > 0) atom->sort();
respa.cpp:  if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
respa.cpp:    if (triclinic) domain->x2lamda(atom->nlocal);
respa.cpp:    if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
respa.cpp:        if (triclinic) domain->x2lamda(atom->nlocal);
respa.cpp:        if (atom->sortfreq > 0 &&
respa.cpp:            update->ntimestep >= atom->nextsort) atom->sort();
respa.cpp:        if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
respa.cpp:  size_t nbytes = sizeof(double) * atom->nlocal;
respa.cpp:  if (force->newton) nbytes += sizeof(double) * atom->nghost;
respa.cpp:    memset(&atom->f[0][0],0,3*nbytes);
respa.cpp:    if (torqueflag) memset(&atom->torque[0][0],0,3*nbytes);
respa.cpp:    if (extraflag) atom->avec->force_clear(0,nbytes);
respa.cpp:   copy force components from atom->f to FixRespa->f_level
respa.cpp:  double **f = atom->f;
respa.cpp:  double **t = atom->torque;
respa.cpp:  int n = atom->nlocal;
respa.cpp:   copy force components from FixRespa->f_level to atom->f
respa.cpp:  double **f = atom->f;
respa.cpp:  double **t = atom->torque;
respa.cpp:  int n = atom->nlocal;
respa.cpp:   sum all force components from FixRespa->f_level to create full atom->f
respa.cpp:  double **f = atom->f;
respa.cpp:  double **t = atom->torque;
respa.cpp:  int n = atom->nlocal;
set.cpp:  if (atom->natoms == 0)
set.cpp:  selection(atom->nlocal);
set.cpp:      if (newtype <= 0 || newtype > atom->ntypes)
set.cpp:      if (newtype <= 0 || newtype > atom->ntypes)
set.cpp:      if (newtype <= 0 || newtype > atom->ntypes)
set.cpp:      if (!atom->molecule_flag)
set.cpp:      if (!atom->q_flag)
set.cpp:      if (!atom->rmass_flag)
set.cpp:      if (!atom->ellipsoid_flag)
set.cpp:      if (!atom->line_flag)
set.cpp:      if (!atom->tri_flag)
set.cpp:      if (!atom->mu_flag)
set.cpp:      if (!atom->mu_flag)
set.cpp:      if (!atom->sp_flag)
set.cpp:      if (!atom->sp_flag)
set.cpp:      if (!atom->ellipsoid_flag && !atom->tri_flag && !atom->body_flag)
set.cpp:      if (!atom->ellipsoid_flag && !atom->tri_flag && !atom->body_flag)
set.cpp:      if (!atom->line_flag)
set.cpp:      if (!atom->line_flag)
set.cpp:      if (!atom->angmom_flag)
set.cpp:      if (!atom->omega_flag)
set.cpp:      if (!atom->radius_flag)
set.cpp:      if (!atom->rmass_flag)
set.cpp:      if (!atom->vfrac_flag)
set.cpp:      if (atom->avec->bonds_allow == 0)
set.cpp:      if (ivalue <= 0 || ivalue > atom->nbondtypes)
set.cpp:      if (atom->avec->angles_allow == 0)
set.cpp:      if (ivalue <= 0 || ivalue > atom->nangletypes)
set.cpp:      if (atom->avec->dihedrals_allow == 0)
set.cpp:      if (ivalue <= 0 || ivalue > atom->ndihedraltypes)
set.cpp:      if (atom->avec->impropers_allow == 0)
set.cpp:      if (ivalue <= 0 || ivalue > atom->nimpropertypes)
set.cpp:      if (!atom->esph_flag)
set.cpp:      if (!atom->cv_flag)
set.cpp:      if (!atom->rho_flag)
set.cpp:      if (!atom->edpd_flag)
set.cpp:      if (!atom->edpd_flag)
set.cpp:      if (!atom->tdpd_flag)
set.cpp:          if (!atom->smd_flag)
set.cpp:          if (!atom->smd_flag)
set.cpp:      if (!atom->dpd_flag)
set.cpp:      index_custom = atom->find_custom(argi.get_name(),flag,cols);
set.cpp:    if (atom->tag_enable == 0)
set.cpp:    tagint *tag = atom->tag;
set.cpp:    if (atom->molecule_flag == 0)
set.cpp:    tagint *molecule = atom->molecule;
set.cpp:    utils::bounds(FLERR,id,1,atom->ntypes,nlo,nhi,error);
set.cpp:    int *type = atom->type;
set.cpp:    int *mask = atom->mask;
set.cpp:    double **x = atom->x;
set.cpp:   either scalar or per-atom values from atom-style variable(s)
set.cpp:  // evaluate atom-style variable(s) if necessary
set.cpp:    int nlocal = atom->nlocal;
set.cpp:    (AtomVecEllipsoid *) atom->style_match("ellipsoid");
set.cpp:  AtomVecLine *avec_line = (AtomVecLine *) atom->style_match("line");
set.cpp:  AtomVecTri *avec_tri = (AtomVecTri *) atom->style_match("tri");
set.cpp:  AtomVecBody *avec_body = (AtomVecBody *) atom->style_match("body");
set.cpp:  int nlocal = atom->nlocal;
set.cpp:    // error check here in case atom-style variables generated bogus value
set.cpp:      if (ivalue <= 0 || ivalue > atom->ntypes)
set.cpp:      atom->type[i] = ivalue;
set.cpp:    else if (keyword == MOLECULE) atom->molecule[i] = ivalue;
set.cpp:    else if (keyword == X) atom->x[i][0] = dvalue;
set.cpp:    else if (keyword == Y) atom->x[i][1] = dvalue;
set.cpp:    else if (keyword == Z) atom->x[i][2] = dvalue;
set.cpp:    else if (keyword == VX) atom->v[i][0] = dvalue;
set.cpp:    else if (keyword == VY) atom->v[i][1] = dvalue;
set.cpp:    else if (keyword == VZ) atom->v[i][2] = dvalue;
set.cpp:    else if (keyword == CHARGE) atom->q[i] = dvalue;
set.cpp:      atom->rmass[i] = dvalue;
set.cpp:      atom->radius[i] = 0.5 * dvalue;
set.cpp:      atom->vfrac[i] = dvalue;
set.cpp:    else if (keyword == SPH_E) atom->esph[i] = dvalue;
set.cpp:    else if (keyword == SPH_CV) atom->cv[i] = dvalue;
set.cpp:    else if (keyword == SPH_RHO) atom->rho[i] = dvalue;
set.cpp:    else if (keyword == EDPD_TEMP) atom->edpd_temp[i] = dvalue;
set.cpp:    else if (keyword == EDPD_CV) atom->edpd_cv[i] = dvalue;
set.cpp:    else if (keyword == CC) atom->cc[i][cc_index-1] = dvalue;
set.cpp:      atom->rmass[i] = atom->vfrac[i] * dvalue;
set.cpp:    else if (keyword == SMD_CONTACT_RADIUS) atom->contact_radius[i] = dvalue;
set.cpp:      if (dvalue >= 0.0) atom->dpdTheta[i] = dvalue;
set.cpp:        if (atom->rmass) onemass = atom->rmass[i];
set.cpp:        else onemass = atom->mass[atom->type[i]];
set.cpp:        double vx = atom->v[i][0];
set.cpp:        double vy = atom->v[i][1];
set.cpp:        double vz = atom->v[i][2];
set.cpp:        atom->dpdTheta[i] = tfactor * onemass * (vx*vx + vy*vy + vz*vz);
set.cpp:      if (atom->radius_flag && atom->radius[i] > 0.0)
set.cpp:          atom->rmass[i] = MY_PI*atom->radius[i]*atom->radius[i] * dvalue;
set.cpp:          atom->rmass[i] = 4.0*MY_PI/3.0 *
set.cpp:            atom->radius[i]*atom->radius[i]*atom->radius[i] * dvalue;
set.cpp:      else if (atom->ellipsoid_flag && atom->ellipsoid[i] >= 0) {
set.cpp:        double *shape = avec_ellipsoid->bonus[atom->ellipsoid[i]].shape;
set.cpp:        // atom->rmass[i] = MY_PI*shape[0]*shape[1] * dvalue;
set.cpp:        atom->rmass[i] = 4.0*MY_PI/3.0 * shape[0]*shape[1]*shape[2] * dvalue;
set.cpp:      } else if (atom->line_flag && atom->line[i] >= 0) {
set.cpp:        double length = avec_line->bonus[atom->line[i]].length;
set.cpp:        atom->rmass[i] = length * dvalue;
set.cpp:      } else if (atom->tri_flag && atom->tri[i] >= 0) {
set.cpp:        double *c1 = avec_tri->bonus[atom->tri[i]].c1;
set.cpp:        double *c2 = avec_tri->bonus[atom->tri[i]].c2;
set.cpp:        double *c3 = avec_tri->bonus[atom->tri[i]].c3;
set.cpp:        atom->rmass[i] = area * dvalue;
set.cpp:      } else atom->rmass[i] = dvalue;
set.cpp:      double **mu = atom->mu;
set.cpp:      double **sp = atom->sp;
set.cpp:      if (avec_ellipsoid && atom->ellipsoid[i] >= 0)
set.cpp:        quat = avec_ellipsoid->bonus[atom->ellipsoid[i]].quat;
set.cpp:      else if (avec_tri && atom->tri[i] >= 0)
set.cpp:        quat = avec_tri->bonus[atom->tri[i]].quat;
set.cpp:      else if (avec_body && atom->body[i] >= 0)
set.cpp:        quat = avec_body->bonus[atom->body[i]].quat;
set.cpp:      if (atom->line[i] < 0)
set.cpp:      avec_line->bonus[atom->line[i]].theta = dvalue;
set.cpp:      atom->angmom[i][0] = xvalue;
set.cpp:      atom->angmom[i][1] = yvalue;
set.cpp:      atom->angmom[i][2] = zvalue;
set.cpp:      atom->omega[i][0] = xvalue;
set.cpp:      atom->omega[i][1] = yvalue;
set.cpp:      atom->omega[i][2] = zvalue;
set.cpp:      int xbox = (atom->image[i] & IMGMASK) - IMGMAX;
set.cpp:      int ybox = (atom->image[i] >> IMGBITS & IMGMASK) - IMGMAX;
set.cpp:      int zbox = (atom->image[i] >> IMG2BITS) - IMGMAX;
set.cpp:      atom->image[i] = ((imageint) (xbox + IMGMAX) & IMGMASK) |
set.cpp:      atom->ivector[index_custom][i] = ivalue;
set.cpp:      atom->dvector[index_custom][i] = dvalue;
set.cpp:      atom->iarray[index_custom][i][icol_custom-1] = ivalue;
set.cpp:      atom->darray[index_custom][i][icol_custom-1] = dvalue;
set.cpp:    MPI_Allreduce(&nlocal_bonus,&atom->nellipsoids,1,
set.cpp:    MPI_Allreduce(&nlocal_bonus,&atom->nlines,1,MPI_LMP_BIGINT,MPI_SUM,world);
set.cpp:    MPI_Allreduce(&nlocal_bonus,&atom->ntris,1,MPI_LMP_BIGINT,MPI_SUM,world);
set.cpp:    (AtomVecEllipsoid *) atom->style_match("ellipsoid");
set.cpp:  AtomVecLine *avec_line = (AtomVecLine *) atom->style_match("line");
set.cpp:  AtomVecTri *avec_tri = (AtomVecTri *) atom->style_match("tri");
set.cpp:  AtomVecBody *avec_body = (AtomVecBody *) atom->style_match("body");
set.cpp:  double **x = atom->x;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:        atom->type[i] = newtype;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:        atom->type[i] = newtype;
set.cpp:    double **mu = atom->mu;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:    double **sp = atom->sp;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:          if (avec_ellipsoid && atom->ellipsoid[i] >= 0)
set.cpp:            quat = avec_ellipsoid->bonus[atom->ellipsoid[i]].quat;
set.cpp:          else if (avec_tri && atom->tri[i] >= 0)
set.cpp:            quat = avec_tri->bonus[atom->tri[i]].quat;
set.cpp:          else if (avec_body && atom->body[i] >= 0)
set.cpp:            quat = avec_body->bonus[atom->body[i]].quat;
set.cpp:          if (avec_ellipsoid && atom->ellipsoid[i] >= 0)
set.cpp:            quat = avec_ellipsoid->bonus[atom->ellipsoid[i]].quat;
set.cpp:          else if (avec_body && atom->body[i] >= 0)
set.cpp:            quat = avec_body->bonus[atom->body[i]].quat;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:        if (atom->line[i] < 0)
set.cpp:        avec_line->bonus[atom->line[i]].theta = MY_2PI*ranpark->uniform();
set.cpp:  if (atom->molecular == Atom::TEMPLATE)
set.cpp:  if (domain->triclinic) domain->x2lamda(atom->nlocal);
set.cpp:  if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
set.cpp:  selection(atom->nlocal + atom->nghost);
set.cpp:    int nlocal = atom->nlocal;
set.cpp:      for (m = 0; m < atom->num_bond[i]; m++) {
set.cpp:        atom1 = atom->map(atom->bond_atom[i][m]);
set.cpp:          atom->bond_type[i][m] = ivalue;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:      for (m = 0; m < atom->num_angle[i]; m++) {
set.cpp:        atom1 = atom->map(atom->angle_atom1[i][m]);
set.cpp:        atom2 = atom->map(atom->angle_atom2[i][m]);
set.cpp:        atom3 = atom->map(atom->angle_atom3[i][m]);
set.cpp:          atom->angle_type[i][m] = ivalue;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:      for (m = 0; m < atom->num_dihedral[i]; m++) {
set.cpp:        atom1 = atom->map(atom->dihedral_atom1[i][m]);
set.cpp:        atom2 = atom->map(atom->dihedral_atom2[i][m]);
set.cpp:        atom3 = atom->map(atom->dihedral_atom3[i][m]);
set.cpp:        atom4 = atom->map(atom->dihedral_atom4[i][m]);
set.cpp:          atom->dihedral_type[i][m] = ivalue;
set.cpp:    int nlocal = atom->nlocal;
set.cpp:      for (m = 0; m < atom->num_improper[i]; m++) {
set.cpp:        atom1 = atom->map(atom->improper_atom1[i][m]);
set.cpp:        atom2 = atom->map(atom->improper_atom2[i][m]);
set.cpp:        atom3 = atom->map(atom->improper_atom3[i][m]);
set.cpp:        atom4 = atom->map(atom->improper_atom4[i][m]);
set.cpp:          atom->improper_type[i][m] = ivalue;
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:  tagint *tag = atom->tag;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:  tagint *tag = atom->tag;
special.cpp:  int *num_bond = atom->num_bond;
special.cpp:  tagint **bond_atom = atom->bond_atom;
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:      m = atom->map(bond_atom[i][j]);
special.cpp:      m = atom->map(bond_atom[i][j]);
special.cpp:      m = atom->map(bond_atom[i][j]);
special.cpp:    i = atom->map(outbuf[m].atomID);
special.cpp:      m = atom->map(bond_atom[i][j]);
special.cpp:    i = atom->map(outbuf[m].atomID);
special.cpp:  int *num_bond = atom->num_bond;
special.cpp:  tagint **bond_atom = atom->bond_atom;
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:      m = atom->map(onetwo[i][j]);
special.cpp:      m = atom->map(onetwo[i][j]);
special.cpp:      m = atom->map(onetwo[i][j]);
special.cpp:    i = atom->map(outbuf[m].atomID);
special.cpp:      m = atom->map(onetwo[i][j]);
special.cpp:    i = atom->map(outbuf[m].atomID);
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:      m = atom->map(onethree[i][j]);
special.cpp:      m = atom->map(onethree[i][j]);
special.cpp:      m = atom->map(onethree[i][j]);
special.cpp:    i = atom->map(outbuf[m].atomID);
special.cpp:      m = atom->map(onethree[i][j]);
special.cpp:    i = atom->map(outbuf[m].atomID);
special.cpp:  atom->map_clear();
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  tagint *tag = atom->tag;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:    atom->map_one(tag[i],0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:    atom->map_one(tag[i],-1);
special.cpp:    for (j = 0; j < unique; j++) atom->map_one(onetwo[i][j],-1);
special.cpp:    atom->map_one(tag[i],0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:    atom->map_one(tag[i],-1);
special.cpp:    for (j = 0; j < unique; j++) atom->map_one(onethree[i][j],-1);
special.cpp:    atom->map_one(tag[i],0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:    atom->map_one(tag[i],-1);
special.cpp:    for (j = 0; j < unique; j++) atom->map_one(onefour[i][j],-1);
special.cpp:  atom->map_init(0);
special.cpp:  atom->nghost = 0;
special.cpp:  atom->map_set();
special.cpp:   concatenate onetwo, onethree, onefour into master atom->special list
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  tagint *tag = atom->tag;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:  atom->map_clear();
special.cpp:    atom->map_one(tag[i],0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:    atom->map_one(tag[i],-1);
special.cpp:    for (j = 0; j < nspecial[i][0]; j++) atom->map_one(onetwo[i][j],-1);
special.cpp:    for (j = 0; j < nspecial[i][1]; j++) atom->map_one(onethree[i][j],-1);
special.cpp:    for (j = 0; j < nspecial[i][2]; j++) atom->map_one(onefour[i][j],-1);
special.cpp:  // if atom->maxspecial has been updated before, make certain
special.cpp:  // we do not reset it to a smaller value. Since atom->maxspecial
special.cpp:  maxspecial = MAX(atom->maxspecial,maxspecial);
special.cpp:  MPI_Allreduce(&maxspecial,&atom->maxspecial,1,MPI_INT,MPI_MAX,world);
special.cpp:  atom->maxspecial += force->special_extra;
special.cpp:    utils::logmesg(lmp,"{:>6} = max # of special neighbors\n",atom->maxspecial);
special.cpp:    memoryKK->grow_kokkos(atomKK->k_special,atom->special,
special.cpp:                        atom->nmax,atom->maxspecial,"atom:special");
special.cpp:    atom->avec->grow_pointers();
special.cpp:    memory->destroy(atom->special);
special.cpp:    memory->create(atom->special,atom->nmax,atom->maxspecial,"atom:special");
special.cpp:  tagint **special = atom->special;
special.cpp:    atom->map_one(tag[i],0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:      if (atom->map(m) < 0) {
special.cpp:        atom->map_one(m,0);
special.cpp:    atom->map_one(tag[i],-1);
special.cpp:    for (j = 0; j < nspecial[i][2]; j++) atom->map_one(special[i][j],-1);
special.cpp:  atom->map_init(0);
special.cpp:  atom->nghost = 0;
special.cpp:  atom->map_set();
special.cpp:  int *num_angle = atom->num_angle;
special.cpp:  int *num_dihedral = atom->num_dihedral;
special.cpp:  tagint **angle_atom1 = atom->angle_atom1;
special.cpp:  tagint **angle_atom2 = atom->angle_atom2;
special.cpp:  tagint **angle_atom3 = atom->angle_atom3;
special.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
special.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
special.cpp:  tagint **dihedral_atom3 = atom->dihedral_atom3;
special.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  tagint *tag = atom->tag;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:  if ((num_angle && atom->nangles) || (num_dihedral && atom->ndihedrals)) {
special.cpp:          m = atom->map(angle_atom1[i][j]);
special.cpp:          m = atom->map(angle_atom3[i][j]);
special.cpp:          m = atom->map(dihedral_atom1[i][j]);
special.cpp:          m = atom->map(dihedral_atom3[i][j]);
special.cpp:          m = atom->map(dihedral_atom4[i][j]);
special.cpp:          m = atom->map(angle_atom1[i][j]);
special.cpp:          m = atom->map(angle_atom3[i][j]);
special.cpp:          m = atom->map(dihedral_atom1[i][j]);
special.cpp:          m = atom->map(dihedral_atom3[i][j]);
special.cpp:          m = atom->map(dihedral_atom4[i][j]);
special.cpp:          m = atom->map(angle_atom1[i][j]);
special.cpp:          m = atom->map(angle_atom3[i][j]);
special.cpp:          m = atom->map(dihedral_atom1[i][j]);
special.cpp:          m = atom->map(dihedral_atom3[i][j]);
special.cpp:          m = atom->map(dihedral_atom4[i][j]);
special.cpp:      i = atom->map(outbuf[m].atomID);
special.cpp:  int *num_dihedral = atom->num_dihedral;
special.cpp:  tagint **dihedral_atom1 = atom->dihedral_atom1;
special.cpp:  tagint **dihedral_atom2 = atom->dihedral_atom2;
special.cpp:  tagint **dihedral_atom4 = atom->dihedral_atom4;
special.cpp:  int **nspecial = atom->nspecial;
special.cpp:  tagint *tag = atom->tag;
special.cpp:  int nlocal = atom->nlocal;
special.cpp:  if (num_dihedral && atom->ndihedrals) {
special.cpp:        m = atom->map(dihedral_atom1[i][j]);
special.cpp:        m = atom->map(dihedral_atom4[i][j]);
special.cpp:        m = atom->map(dihedral_atom1[i][j]);
special.cpp:        m = atom->map(dihedral_atom4[i][j]);
special.cpp:        m = atom->map(dihedral_atom1[i][j]);
special.cpp:        m = atom->map(dihedral_atom4[i][j]);
special.cpp:      i = atom->map(outbuf[m].atomID);
special.cpp:  atom->map_clear();
special.cpp:    atom->map_one(atomIDs[i],i);
special.cpp:    m = atom->map(in[i].atomID);
special.cpp:  atom->map_init(0);
special.cpp:  atom->nghost = 0;
special.cpp:  atom->map_set();
thermo.cpp:  natoms = atom->natoms = lost_check();
thermo.cpp:  nlocal[0] = atom->nlocal;
thermo.cpp:  if (ntotal[0] == atom->natoms) return ntotal[0];
thermo.cpp:               atom->natoms,ntotal[0]);
thermo.cpp:                   atom->natoms,ntotal[0]);
thermo.cpp:  atom->natoms = ntotal[0];
thermo.cpp:  natoms = atom->natoms;
thermo.cpp:  if (atom->molecular != Atom::ATOMIC) {
thermo.cpp:  bivalue = atom->nbonds;
thermo.cpp:  bivalue = atom->nangles;
thermo.cpp:  bivalue = atom->ndihedrals;
thermo.cpp:  bivalue = atom->nimpropers;
thermo.cpp:  double **f = atom->f;
thermo.cpp:  int nlocal = atom->nlocal;
thermo.cpp:  double **f = atom->f;
thermo.cpp:  int nlocal = atom->nlocal;
utils.cpp:        int icustom = lmp->atom->find_custom(id.c_str(), flag, cols);
variable.cpp:   compute result of atom-style and atomfile-style variable evaluation
variable.cpp:  int *mask = atom->mask;
variable.cpp:  int nlocal = atom->nlocal;
variable.cpp:   str is an equal-style or atom-style or vector-style formula
variable.cpp:   atom-style and vector-style variables pass in tree = non-nullptr:
variable.cpp:                            "atom-style variable formula",ivar);
variable.cpp:                            "atom-style variable formula",ivar);
variable.cpp:                            "atom-style variable formula",ivar);
variable.cpp:                            "atom-style variable formula",ivar);
variable.cpp:        // v_name = per-atom vector from atom-style variable
variable.cpp:        // evaluate the atom-style variable as newtree
variable.cpp:                            "atom-style variable formula",ivar);
variable.cpp:        // v_name[N] = scalar from atom-style variable
variable.cpp:          memory->create(result,atom->nlocal,"variable:result");
variable.cpp:  // for atom-style variable, return remaining tree
variable.cpp:   one-time collapse of an atom-style variable parse tree
variable.cpp:   evaluate an atom-style or vector-style variable parse tree
variable.cpp:  if (tree->type == TYPEARRAY) return tree->array[atom->type[i]];
variable.cpp:    return randomatom->uniform()*(upper-lower)+lower;
variable.cpp:    return mu + sigma*randomatom->gaussian();
variable.cpp:    if (atom->mask[i] & tree->ivalue1) return 1.0;
variable.cpp:    if (domain->regions[tree->ivalue1]->match(atom->x[i][0],
variable.cpp:                                              atom->x[i][1],
variable.cpp:                                              atom->x[i][2])) return 1.0;
variable.cpp:    if ((atom->mask[i] & tree->ivalue1) &&
variable.cpp:        (domain->regions[tree->ivalue2]->match(atom->x[i][0],
variable.cpp:                                               atom->x[i][1],
variable.cpp:                                               atom->x[i][2]))) return 1.0;
variable.cpp:    atom->check_mass(FLERR);
variable.cpp:    atom->check_mass(FLERR);
variable.cpp:    atom->check_mass(FLERR);
variable.cpp:    atom->check_mass(FLERR);
variable.cpp:    atom->check_mass(FLERR);
variable.cpp:    atom->check_mass(FLERR);
variable.cpp:    atom->check_mass(FLERR);
variable.cpp:      memory->create(result,atom->nlocal,"variable:result");
variable.cpp:      memcpy(result,reader[ivar]->fixstore->vstore,atom->nlocal*sizeof(double));
variable.cpp:  if (atom->map_style == Atom::MAP_NONE)
variable.cpp:  if (id > atom->map_tag_max)
variable.cpp:  int index = atom->map(id);
variable.cpp:  if (index >= 0 && index < atom->nlocal) {
variable.cpp:      if (strcmp(word,"id") == 0) mine = atom->tag[index];
variable.cpp:        if (atom->rmass) mine = atom->rmass[index];
variable.cpp:        else mine = atom->mass[atom->type[index]];
variable.cpp:      else if (strcmp(word,"type") == 0) mine = atom->type[index];
variable.cpp:        if (!atom->molecule_flag)
variable.cpp:        mine = atom->molecule[index];
variable.cpp:      else if (strcmp(word,"x") == 0) mine = atom->x[index][0];
variable.cpp:      else if (strcmp(word,"y") == 0) mine = atom->x[index][1];
variable.cpp:      else if (strcmp(word,"z") == 0) mine = atom->x[index][2];
variable.cpp:      else if (strcmp(word,"vx") == 0) mine = atom->v[index][0];
variable.cpp:      else if (strcmp(word,"vy") == 0) mine = atom->v[index][1];
variable.cpp:      else if (strcmp(word,"vz") == 0) mine = atom->v[index][2];
variable.cpp:      else if (strcmp(word,"fx") == 0) mine = atom->f[index][0];
variable.cpp:      else if (strcmp(word,"fy") == 0) mine = atom->f[index][1];
variable.cpp:      else if (strcmp(word,"fz") == 0) mine = atom->f[index][2];
variable.cpp:        if (!atom->q_flag)
variable.cpp:        mine = atom->q[index];
variable.cpp:      newtree->iarray = (int *) atom->tag;
variable.cpp:      newtree->barray = (bigint *) atom->tag;
variable.cpp:    if (atom->rmass) {
variable.cpp:      newtree->array = atom->rmass;
variable.cpp:      newtree->array = atom->mass;
variable.cpp:    newtree->iarray = atom->type;
variable.cpp:    if (!atom->molecule_flag)
variable.cpp:      newtree->iarray = (int *) atom->molecule;
variable.cpp:      newtree->barray = (bigint *) atom->molecule;
variable.cpp:  else if (strcmp(word,"x") == 0) newtree->array = &atom->x[0][0];
variable.cpp:  else if (strcmp(word,"y") == 0) newtree->array = &atom->x[0][1];
variable.cpp:  else if (strcmp(word,"z") == 0) newtree->array = &atom->x[0][2];
variable.cpp:  else if (strcmp(word,"vx") == 0) newtree->array = &atom->v[0][0];
variable.cpp:  else if (strcmp(word,"vy") == 0) newtree->array = &atom->v[0][1];
variable.cpp:  else if (strcmp(word,"vz") == 0) newtree->array = &atom->v[0][2];
variable.cpp:  else if (strcmp(word,"fx") == 0) newtree->array = &atom->f[0][0];
variable.cpp:  else if (strcmp(word,"fy") == 0) newtree->array = &atom->f[0][1];
variable.cpp:  else if (strcmp(word,"fz") == 0) newtree->array = &atom->f[0][2];
variable.cpp:    newtree->array = atom->q;
variable.cpp:    if (atom->map_style == Atom::MAP_NONE)
variable.cpp:  int nlocal = atom->nlocal;
variable.cpp:  tagint map_tag_max = atom->map_tag_max;
variable.cpp:      if ((m = atom->map(tag)) >= 0) vstore[m] = value;
velocity.cpp:  if (atom->natoms == 0)
velocity.cpp:  atom->check_mass(FLERR);
velocity.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
velocity.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
velocity.cpp:    double **v = atom->v;
velocity.cpp:    int nlocal = atom->nlocal;
velocity.cpp:  //   ALL = loop over all natoms, only set those I own via atom->map
velocity.cpp:  double **v = atom->v;
velocity.cpp:  double *rmass = atom->rmass;
velocity.cpp:  double *mass = atom->mass;
velocity.cpp:  int *type = atom->type;
velocity.cpp:  int *mask = atom->mask;
velocity.cpp:  int nlocal = atom->nlocal;
velocity.cpp:    if (atom->map_style == Atom::MAP_NONE) {
velocity.cpp:      atom->nghost = 0;
velocity.cpp:      atom->map_init();
velocity.cpp:      atom->map_set();
velocity.cpp:    if (atom->natoms > MAXSMALLINT)
velocity.cpp:    if (atom->tag_enable == 0)
velocity.cpp:    if (atom->tag_consecutive() == 0)
velocity.cpp:    int natoms = static_cast<int> (atom->natoms);
velocity.cpp:      m = atom->map(i);
velocity.cpp:      atom->map_delete();
velocity.cpp:      atom->map_style = Atom::MAP_NONE;
velocity.cpp:    double **x = atom->x;
velocity.cpp:  if (varflag == ATOM) memory->create(vfield,atom->nlocal,3,"velocity:vfield");
velocity.cpp:  double **v = atom->v;
velocity.cpp:  int *mask = atom->mask;
velocity.cpp:  int nlocal = atom->nlocal;
velocity.cpp:  double **x = atom->x;
velocity.cpp:  double **v = atom->v;
velocity.cpp:  int *mask = atom->mask;
velocity.cpp:  int nlocal = atom->nlocal;
velocity.cpp:  double **v = atom->v;
velocity.cpp:  int *mask = atom->mask;
velocity.cpp:  int nlocal = atom->nlocal;
velocity.cpp:  double **v = atom->v;
velocity.cpp:  int *mask = atom->mask;
velocity.cpp:  int nlocal = atom->nlocal;
velocity.cpp:  double **x = atom->x;
velocity.cpp:  double **v = atom->v;
velocity.cpp:  int *mask = atom->mask;
velocity.cpp:  imageint *image = atom->image;
velocity.cpp:  int nlocal = atom->nlocal;
verlet.cpp:  if (atom->torque_flag) torqueflag = 1;
verlet.cpp:  if (atom->avec->forceclearflag) extraflag = 1;
verlet.cpp:  atom->setup();
verlet.cpp:  if (triclinic) domain->x2lamda(atom->nlocal);
verlet.cpp:  if (atom->sortfreq > 0) atom->sort();
verlet.cpp:  if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
verlet.cpp:  if (atom->molecular != Atom::ATOMIC) {
verlet.cpp:    if (triclinic) domain->x2lamda(atom->nlocal);
verlet.cpp:    if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
verlet.cpp:  if (atom->molecular != Atom::ATOMIC) {
verlet.cpp:  if (atom->sortfreq > 0) sortflag = 1;
verlet.cpp:      if (triclinic) domain->x2lamda(atom->nlocal);
verlet.cpp:      if (sortflag && ntimestep >= atom->nextsort) atom->sort();
verlet.cpp:      if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
verlet.cpp:    if (atom->molecular != Atom::ATOMIC) {
verlet.cpp:  int nlocal = atom->nlocal;
verlet.cpp:    if (force->newton) nbytes += sizeof(double) * atom->nghost;
verlet.cpp:      memset(&atom->f[0][0],0,3*nbytes);
verlet.cpp:      if (torqueflag) memset(&atom->torque[0][0],0,3*nbytes);
verlet.cpp:      if (extraflag) atom->avec->force_clear(0,nbytes);
verlet.cpp:    nbytes = sizeof(double) * atom->nfirst;
verlet.cpp:      memset(&atom->f[0][0],0,3*nbytes);
verlet.cpp:      if (torqueflag) memset(&atom->torque[0][0],0,3*nbytes);
verlet.cpp:      if (extraflag) atom->avec->force_clear(0,nbytes);
verlet.cpp:      nbytes = sizeof(double) * atom->nghost;
verlet.cpp:        memset(&atom->f[nlocal][0],0,3*nbytes);
verlet.cpp:        if (torqueflag) memset(&atom->torque[nlocal][0],0,3*nbytes);
verlet.cpp:        if (extraflag) atom->avec->force_clear(nlocal,nbytes);
write_data.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
write_data.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
write_data.cpp:  bigint nblocal = atom->nlocal;
write_data.cpp:  if (natoms != atom->natoms && output->thermo->lostflag == Thermo::ERROR)
write_data.cpp:  // may be different than atom->nbonds,nangles, etc. if broken/turned-off
write_data.cpp:  if (atom->molecular == Atom::MOLECULAR && (atom->nbonds || atom->nbondtypes)) {
write_data.cpp:    nbonds_local = atom->avec->pack_bond(nullptr);
write_data.cpp:  if (atom->molecular == Atom::MOLECULAR && (atom->nangles || atom->nangletypes)) {
write_data.cpp:    nangles_local = atom->avec->pack_angle(nullptr);
write_data.cpp:  if (atom->molecular == Atom::MOLECULAR && (atom->ndihedrals || atom->ndihedraltypes)) {
write_data.cpp:    ndihedrals_local = atom->avec->pack_dihedral(nullptr);
write_data.cpp:  if (atom->molecular == Atom::MOLECULAR && (atom->nimpropers || atom->nimpropertypes)) {
write_data.cpp:    nimpropers_local = atom->avec->pack_improper(nullptr);
write_data.cpp:  if (atom->molecular == Atom::MOLECULAR) {
write_data.cpp:    if (atom->nbonds && nbonds) bonds();
write_data.cpp:    if (atom->nangles && nangles) angles();
write_data.cpp:    if (atom->ndihedrals) dihedrals();
write_data.cpp:    if (atom->nimpropers) impropers();
write_data.cpp:  if (natoms && atom->ellipsoid_flag) bonus(ELLIPSOID);
write_data.cpp:  if (natoms && atom->line_flag) bonus(LINE);
write_data.cpp:  if (natoms && atom->tri_flag) bonus(TRIANGLE);
write_data.cpp:  if (natoms && atom->body_flag) bonus(BODY);
write_data.cpp:  fmt::print(fp,"{} atoms\n{} atom types\n",atom->natoms,atom->ntypes);
write_data.cpp:  if (atom->molecular == Atom::MOLECULAR) {
write_data.cpp:    if (atom->nbonds || atom->nbondtypes)
write_data.cpp:                 nbonds,atom->nbondtypes);
write_data.cpp:    if (atom->nangles || atom->nangletypes)
write_data.cpp:                 nangles,atom->nangletypes);
write_data.cpp:    if (atom->ndihedrals || atom->ndihedraltypes)
write_data.cpp:                 ndihedrals,atom->ndihedraltypes);
write_data.cpp:    if (atom->nimpropers || atom->nimpropertypes)
write_data.cpp:                 nimpropers,atom->nimpropertypes);
write_data.cpp:  if (atom->molecular == Atom::TEMPLATE) {
write_data.cpp:    if (atom->nbondtypes) fmt::print(fp,"{} bond types\n",atom->nbondtypes);
write_data.cpp:    if (atom->nangletypes) fmt::print(fp,"{} angle types\n",atom->nangletypes);
write_data.cpp:    if (atom->ndihedraltypes) fmt::print(fp,"{} dihedral types\n",atom->ndihedraltypes);
write_data.cpp:    if (atom->nimpropertypes) fmt::print(fp,"{} improper types\n",atom->nimpropertypes);
write_data.cpp:  if (atom->ellipsoid_flag) fmt::print(fp,"{} ellipsoids\n",atom->nellipsoids);
write_data.cpp:  if (atom->line_flag) fmt::print(fp,"{} lines\n",atom->nlines);
write_data.cpp:  if (atom->tri_flag) fmt::print(fp,"{} triangles\n",atom->ntris);
write_data.cpp:  if (atom->body_flag) fmt::print(fp,"{} bodies\n",atom->nbodies);
write_data.cpp:  if (atom->mass) {
write_data.cpp:    double *mass = atom->mass;
write_data.cpp:    for (int i = 1; i <= atom->ntypes; i++)
write_data.cpp:  if (force->bond && force->bond->writedata && atom->nbondtypes) {
write_data.cpp:  if (force->angle && force->angle->writedata && atom->nangletypes) {
write_data.cpp:  if (force->dihedral && force->dihedral->writedata && atom->ndihedraltypes) {
write_data.cpp:  if (force->improper && force->improper->writedata && atom->nimpropertypes) {
write_data.cpp:  int ncol = atom->avec->size_data_atom + 3;
write_data.cpp:  int sendrow = atom->nlocal;
write_data.cpp:  atom->avec->pack_data(buf);
write_data.cpp:    fmt::print(fp,"\nAtoms # {}\n\n",atom->atom_style);
write_data.cpp:      atom->avec->write_data(fp,recvrow,buf);
write_data.cpp:  int ncol = atom->avec->size_velocity + 1;
write_data.cpp:  int sendrow = atom->nlocal;
write_data.cpp:  atom->avec->pack_vel(buf);
write_data.cpp:      atom->avec->write_vel(fp,recvrow,buf);
write_data.cpp:  atom->avec->pack_bond(buf);
write_data.cpp:      atom->avec->write_bond(fp,recvrow,buf,index);
write_data.cpp:  atom->avec->pack_angle(buf);
write_data.cpp:      atom->avec->write_angle(fp,recvrow,buf,index);
write_data.cpp:  atom->avec->pack_dihedral(buf);
write_data.cpp:      atom->avec->write_dihedral(fp,recvrow,buf,index);
write_data.cpp:  atom->avec->pack_improper(buf);
write_data.cpp:      atom->avec->write_improper(fp,recvrow,buf,index);
write_data.cpp:  int nvalues = atom->avec->pack_data_bonus(nullptr,flag);
write_data.cpp:  atom->avec->pack_data_bonus(buf,flag);
write_data.cpp:      atom->avec->write_data_bonus(fp,nvalues,buf,flag);
write_restart.cpp:    if (domain->triclinic) domain->x2lamda(atom->nlocal);
write_restart.cpp:    if (domain->triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
write_restart.cpp:  bigint nblocal = atom->nlocal;
write_restart.cpp:  if (natoms != atom->natoms && output->thermo->lostflag == Thermo::ERROR)
write_restart.cpp:  int send_size = atom->avec->size_restart();
write_restart.cpp:  AtomVec *avec = atom->avec;
write_restart.cpp:  for (int i = 0; i < atom->nlocal; i++) n += avec->pack_restart(i,&buf[n]);
write_restart.cpp:    for (int i = 0; i < atom->nlocal; i++) {
write_restart.cpp:  write_string(ATOM_STYLE,atom->atom_style);
write_restart.cpp:  fwrite(&atom->avec->nargcopy,sizeof(int),1,fp);
write_restart.cpp:  for (int i = 0; i < atom->avec->nargcopy; i++) {
write_restart.cpp:    int n = strlen(atom->avec->argcopy[i]) + 1;
write_restart.cpp:    fwrite(atom->avec->argcopy[i],sizeof(char),n,fp);
write_restart.cpp:  write_int(NTYPES,atom->ntypes);
write_restart.cpp:  write_bigint(NBONDS,atom->nbonds);
write_restart.cpp:  write_int(NBONDTYPES,atom->nbondtypes);
write_restart.cpp:  write_int(BOND_PER_ATOM,atom->bond_per_atom);
write_restart.cpp:  write_bigint(NANGLES,atom->nangles);
write_restart.cpp:  write_int(NANGLETYPES,atom->nangletypes);
write_restart.cpp:  write_int(ANGLE_PER_ATOM,atom->angle_per_atom);
write_restart.cpp:  write_bigint(NDIHEDRALS,atom->ndihedrals);
write_restart.cpp:  write_int(NDIHEDRALTYPES,atom->ndihedraltypes);
write_restart.cpp:  write_int(DIHEDRAL_PER_ATOM,atom->dihedral_per_atom);
write_restart.cpp:  write_bigint(NIMPROPERS,atom->nimpropers);
write_restart.cpp:  write_int(NIMPROPERTYPES,atom->nimpropertypes);
write_restart.cpp:  write_int(IMPROPER_PER_ATOM,atom->improper_per_atom);
write_restart.cpp:  write_int(ATOM_ID,atom->tag_enable);
write_restart.cpp:  write_int(ATOM_MAP_STYLE,atom->map_style);
write_restart.cpp:  write_int(ATOM_MAP_USER,atom->map_user);
write_restart.cpp:  write_int(ATOM_SORTFREQ,atom->sortfreq);
write_restart.cpp:  write_double(ATOM_SORTBIN,atom->userbinsize);
write_restart.cpp:  write_int(EXTRA_BOND_PER_ATOM,atom->extra_bond_per_atom);
write_restart.cpp:  write_int(EXTRA_ANGLE_PER_ATOM,atom->extra_angle_per_atom);
write_restart.cpp:  write_int(EXTRA_DIHEDRAL_PER_ATOM,atom->extra_dihedral_per_atom);
write_restart.cpp:  write_int(EXTRA_IMPROPER_PER_ATOM,atom->extra_improper_per_atom);
write_restart.cpp:  write_int(ATOM_MAXSPECIAL,atom->maxspecial);
write_restart.cpp:  write_bigint(NELLIPSOIDS,atom->nellipsoids);
write_restart.cpp:  write_bigint(NLINES,atom->nlines);
write_restart.cpp:  write_bigint(NTRIS,atom->ntris);
write_restart.cpp:  write_bigint(NBODIES,atom->nbodies);
write_restart.cpp:  if (atom->mass) write_double_vec(MASS,atom->ntypes,&atom->mass[1]);
write_restart.cpp:  if (atom->avec->bonds_allow && force->bond) {
write_restart.cpp:  if (atom->avec->angles_allow && force->angle) {
write_restart.cpp:  if (atom->avec->dihedrals_allow && force->dihedral) {
write_restart.cpp:  if (atom->avec->impropers_allow && force->improper) {
